"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[204],{77351:function(e,t,a){a.r(t),a.d(t,{AbstractCryptoEngine:function(){return ss},AccessDescription:function(){return x},Accuracy:function(){return K},AlgorithmIdentifier:function(){return L},AltName:function(){return W},ArgumentError:function(){return g},AsnError:function(){return S},AttCertValidityPeriod:function(){return ee},Attribute:function(){return Q},AttributeCertificateInfoV1:function(){return rr},AttributeCertificateInfoV2:function(){return rq},AttributeCertificateV1:function(){return ro},AttributeCertificateV2:function(){return rT},AttributeTypeAndValue:function(){return A},AuthenticatedSafe:function(){return lt},AuthorityKeyIdentifier:function(){return e4},BasicConstraints:function(){return e5},BasicOCSPResponse:function(){return lz},CAVersion:function(){return e7},CRLBag:function(){return iY},CRLDistributionPoints:function(){return tN},CertBag:function(){return iA},CertID:function(){return lu},Certificate:function(){return ip},CertificateChainValidationEngine:function(){return lq},CertificatePolicies:function(){return tc},CertificateRevocationList:function(){return iz},CertificateSet:function(){return nS},CertificateTemplate:function(){return tg},CertificationRequest:function(){return l5},ChainValidationCode:function(){return u},ChainValidationError:function(){return l$},ContentInfo:function(){return r_},CryptoEngine:function(){return si},DigestInfo:function(){return oe},DistributionPoint:function(){return tA},ECCCMSSharedInfo:function(){return uY},ECNamedCurves:function(){return an},ECPrivateKey:function(){return aA},ECPublicKey:function(){return al},EncapsulatedContentInfo:function(){return or},EncryptedContentInfo:function(){return aX},EncryptedData:function(){return i3},EnvelopedData:function(){return u6},ExtKeyUsage:function(){return tB},Extension:function(){return sF},ExtensionValueFactory:function(){return sj},Extensions:function(){return sX},GeneralName:function(){return E},GeneralNames:function(){return es},GeneralSubtree:function(){return tM},HASHED_MESSAGE:function(){return oh},HASH_ALGORITHM:function(){return oc},Holder:function(){return rN},InfoAccess:function(){return tH},IssuerAndSerialNumber:function(){return nx},IssuerSerial:function(){return s2},IssuingDistributionPoint:function(){return tJ},KEKIdentifier:function(){return uv},KEKRecipientInfo:function(){return uI},KeyAgreeRecipientIdentifier:function(){return ue},KeyAgreeRecipientInfo:function(){return ug},KeyBag:function(){return oi},KeyTransRecipientInfo:function(){return nL},MICROS:function(){return q},MILLIS:function(){return $},MacData:function(){return oo},MessageImprint:function(){return of},NameConstraints:function(){return tF},OCSPRequest:function(){return oq},OCSPResponse:function(){return oL},ObjectDigestInfo:function(){return rg},OriginatorIdentifierOrKey:function(){return nX},OriginatorInfo:function(){return nE},OriginatorPublicKey:function(){return nz},OtherCertificateFormat:function(){return nd},OtherKeyAttribute:function(){return n0},OtherPrimeInfo:function(){return aI},OtherRecipientInfo:function(){return uR},OtherRevocationInfoFormat:function(){return nb},PBES2Params:function(){return sa},PBKDF2Params:function(){return a9},PFX:function(){return c_},PKCS8ShroudedKeyBag:function(){return i9},PKIStatus:function(){return l},PKIStatusInfo:function(){return cQ},POLICY_IDENTIFIER:function(){return tr},POLICY_QUALIFIERS:function(){return ti},ParameterError:function(){return p},PasswordRecipientinfo:function(){return uP},PkiObject:function(){return y},PolicyConstraints:function(){return tY},PolicyInformation:function(){return tu},PolicyMapping:function(){return t2},PolicyMappings:function(){return t8},PolicyQualifierInfo:function(){return ts},PrivateKeyInfo:function(){return aW},PrivateKeyUsagePeriod:function(){return t7},PublicKeyInfo:function(){return ap},QCStatement:function(){return ar},QCStatements:function(){return ai},RDN:function(){return N},RSAESOAEPParams:function(){return uz},RSAPrivateKey:function(){return aJ},RSAPublicKey:function(){return am},RSASSAPSSParams:function(){return a3},RecipientEncryptedKey:function(){return us},RecipientEncryptedKeys:function(){return uu},RecipientIdentifier:function(){return nK},RecipientInfo:function(){return uj},RecipientKeyIdentifier:function(){return n5},RelativeDistinguishedNames:function(){return V},Request:function(){return oS},ResponseBytes:function(){return oU},ResponseData:function(){return lI},RevocationInfoChoices:function(){return nN},RevokedCertificate:function(){return iI},SECONDS:function(){return P},SafeBag:function(){return nl},SafeBagValueFactory:function(){return ns},SafeContents:function(){return nc},SecretBag:function(){return na},Signature:function(){return oO},SignedAndUnsignedAttributes:function(){return oF},SignedCertificateTimestamp:function(){return s$},SignedCertificateTimestampList:function(){return sR},SignedData:function(){return cJ},SignedDataVerifyError:function(){return cR},SignerInfo:function(){return ce},SingleResponse:function(){return ld},SubjectDirectoryAttributes:function(){return sT},TBSRequest:function(){return oB},TSTInfo:function(){return cA},TYPE:function(){return I},TYPE_AND_VALUES:function(){return k},Time:function(){return rX},TimeStampReq:function(){return ht},TimeStampResp:function(){return hl},TimeType:function(){return n},V2Form:function(){return rv},VALUE:function(){return B},VALUE_BEFORE_DECODE:function(){return C},checkCA:function(){return iS},createCMSECDSASignature:function(){return sd},createECDSASignatureFromCMS:function(){return sg},engine:function(){return sn},getAlgorithmByOID:function(){return sp},getAlgorithmParameters:function(){return sf},getCrypto:function(){return sc},getEngine:function(){return so},getHashAlgorithm:function(){return sS},getOIDByAlgorithm:function(){return sm},getRandomValues:function(){return sh},id_AnyPolicy:function(){return eb},id_AuthorityInfoAccess:function(){return eB},id_AuthorityKeyIdentifier:function(){return eC},id_BaseCRLNumber:function(){return em},id_BasicConstraints:function(){return ec},id_CRLBag_X509CRL:function(){return eM},id_CRLDistributionPoints:function(){return ey},id_CRLNumber:function(){return eh},id_CRLReason:function(){return ef},id_CertBag_AttributeCertificate:function(){return eL},id_CertBag_SDSICertificate:function(){return ej},id_CertBag_X509Certificate:function(){return eT},id_CertificateIssuer:function(){return ep},id_CertificatePolicies:function(){return ev},id_ContentType_Data:function(){return eq},id_ContentType_EncryptedData:function(){return eJ},id_ContentType_EnvelopedData:function(){return eR},id_ContentType_SignedData:function(){return eK},id_ExtKeyUsage:function(){return eV},id_FreshestCRL:function(){return ew},id_InhibitAnyPolicy:function(){return eI},id_InvalidityDate:function(){return ed},id_IssuerAltName:function(){return eo},id_IssuingDistributionPoint:function(){return eg},id_KeyUsage:function(){return en},id_MicrosoftAppPolicies:function(){return eA},id_MicrosoftCaVersion:function(){return eP},id_MicrosoftCertTemplateV1:function(){return eD},id_MicrosoftCertTemplateV2:function(){return ex},id_MicrosoftPrevCaCertHash:function(){return eO},id_NameConstraints:function(){return eS},id_PKIX_OCSP_Basic:function(){return ez},id_PolicyConstraints:function(){return eN},id_PolicyMappings:function(){return ek},id_PrivateKeyUsagePeriod:function(){return eu},id_QCStatements:function(){return e$},id_SignedCertificateTimestampList:function(){return eH},id_SubjectAltName:function(){return el},id_SubjectDirectoryAttributes:function(){return er},id_SubjectInfoAccess:function(){return eE},id_SubjectKeyIdentifier:function(){return ei},id_ad:function(){return eW},id_ad_caIssuers:function(){return eF},id_ad_ocsp:function(){return eG},id_eContentType_TSTInfo:function(){return eU},id_pkix:function(){return e_},id_sha1:function(){return eQ},id_sha256:function(){return eX},id_sha384:function(){return eY},id_sha512:function(){return eZ},kdf:function(){return sw},setEngine:function(){return sl},stringPrep:function(){return w},verifySCTsForCertificate:function(){return sq}});var s,r,i,n,u,l,o=a(73494),c=a(72043),h=a(51225),m=a(97262),f=a(34155);/*!
 * Copyright (c) 2014, GlobalSign
 * Copyright (c) 2015-2019, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the {organization} nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */let d=new ArrayBuffer(0);class g extends TypeError{constructor(){super(...arguments),this.name=g.NAME}static isType(e,t){if("string"==typeof t){if("Array"===t&&Array.isArray(e)||"ArrayBuffer"===t&&e instanceof ArrayBuffer)return!0;if("ArrayBufferView"===t&&ArrayBuffer.isView(e))return!0;if(typeof e===t)return!0}else if(e instanceof t)return!0;return!1}static assert(e,t,...a){for(let t of a)if(this.isType(e,t))return;let s=a.map(e=>e instanceof Function&&"name"in e?e.name:`${e}`);throw new g(`Parameter '${t}' is not of type ${s.length>1?`(${s.join(" or ")})`:s[0]}`)}}g.NAME="ArgumentError";class p extends TypeError{constructor(e,t=null,a){super(),this.name=p.NAME,this.field=e,t&&(this.target=t),a?this.message=a:this.message=`Absent mandatory parameter '${e}' ${t?` in '${t}'`:""}`}static assert(...e){let t,a,s=null;for(let r of("string"==typeof e[0]?(s=e[0],t=e[1],a=e.slice(2)):(t=e[0],a=e.slice(1)),g.assert(t,"parameters","object"),a)){let e=t[r];if(null==e)throw new p(r,s)}}static assertEmpty(e,t,a){if(null==e)throw new p(t,a)}}p.NAME="ParameterError";class S extends Error{static assertSchema(e,t){if(!e.verified)throw Error(`Object's schema was not verified against input data for ${t}`)}static assert(e,t){if(-1===e.offset)throw new S(`Error during parsing of ASN.1 data. Data is not correct for '${t}'.`)}constructor(e){super(e),this.name="AsnError"}}class y{static blockName(){return this.CLASS_NAME}static fromBER(e){let t=o.fromBER(e);S.assert(t,this.name);try{return new this({schema:t.result})}catch(e){throw new S(`Cannot create '${this.CLASS_NAME}' from ASN.1 object`)}}static defaultValues(e){throw Error(`Invalid member name for ${this.CLASS_NAME} class: ${e}`)}static schema(e={}){throw Error(`Method '${this.CLASS_NAME}.schema' should be overridden`)}get className(){return this.constructor.CLASS_NAME}toString(e="hex"){let t;try{t=this.toSchema()}catch{t=this.toSchema(!0)}return c.ep.ToString(t.toBER(),e)}}function w(e){let t=!1,a="",s=e.trim();for(let e=0;e<s.length;e++)32===s.charCodeAt(e)?!1===t&&(t=!0):(t&&(a+=" ",t=!1),a+=s[e]);return a.toLowerCase()}y.CLASS_NAME="PkiObject";let v="type",b="value";class A extends y{constructor(e={}){super(),this.type=h.H$(e,v,A.defaultValues(v)),this.value=h.H$(e,b,A.defaultValues(b)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case v:return"";case b:return{};default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.type||""}),new o.Any({name:t.value||""})]})}fromSchema(e){h.ze(e,[v,"typeValue"]);let t=o.compareSchema(e,e,A.schema({names:{type:v,value:"typeValue"}}));S.assertSchema(t,this.className),this.type=t.result.type.valueBlock.toString(),this.value=t.result.typeValue}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.type}),this.value]})}toJSON(){let e={type:this.type};return 0!==Object.keys(this.value).length?e.value=this.value.toJSON():e.value=this.value,e}isEqual(e){let t=[o.Utf8String.blockName(),o.BmpString.blockName(),o.UniversalString.blockName(),o.NumericString.blockName(),o.PrintableString.blockName(),o.TeletexString.blockName(),o.VideotexString.blockName(),o.IA5String.blockName(),o.GraphicString.blockName(),o.VisibleString.blockName(),o.GeneralString.blockName(),o.CharacterString.blockName()];if(e instanceof ArrayBuffer)return c.vJ.isEqual(this.value.valueBeforeDecodeView,e);if(e.constructor.blockName()===A.blockName()){if(this.type!==e.type)return!1;let a=[!1,!1],s=this.value.constructor.blockName();for(let r of t)s===r&&(a[0]=!0),e.value.constructor.blockName()===r&&(a[1]=!0);if(a[0]!==a[1])return!1;let r=a[0]&&a[1];if(r){let t=w(this.value.valueBlock.value),a=w(e.value.valueBlock.value);if(0!==t.localeCompare(a))return!1}else if(!c.vJ.isEqual(this.value.valueBeforeDecodeView,e.value.valueBeforeDecodeView))return!1;return!0}return!1}}A.CLASS_NAME="AttributeTypeAndValue";let k="typesAndValues",C="valueBeforeDecode",N="RDN";class V extends y{constructor(e={}){super(),this.typesAndValues=h.H$(e,k,V.defaultValues(k)),this.valueBeforeDecode=h.H$(e,C,V.defaultValues(C)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case k:return[];case C:return d;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case k:return 0===t.length;case C:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.repeatedSequence||"",value:new o.Set({value:[new o.Repeated({name:t.repeatedSet||"",value:A.schema(t.typeAndValue||{})})]})})]})}fromSchema(e){h.ze(e,[N,k]);let t=o.compareSchema(e,e,V.schema({names:{blockName:N,repeatedSet:k}}));S.assertSchema(t,this.className),k in t.result&&(this.typesAndValues=Array.from(t.result.typesAndValues,e=>new A({schema:e}))),this.valueBeforeDecode=t.result.RDN.valueBeforeDecodeView.slice().buffer}toSchema(){if(0===this.valueBeforeDecode.byteLength)return new o.Sequence({value:[new o.Set({value:Array.from(this.typesAndValues,e=>e.toSchema())})]});let e=o.fromBER(this.valueBeforeDecode);if(S.assert(e,"RelativeDistinguishedNames"),!(e.result instanceof o.Sequence))throw Error("ASN.1 result should be SEQUENCE");return e.result}toJSON(){return{typesAndValues:Array.from(this.typesAndValues,e=>e.toJSON())}}isEqual(e){if(e instanceof V){if(this.typesAndValues.length!==e.typesAndValues.length)return!1;for(let[t,a]of this.typesAndValues.entries())if(!1===a.isEqual(e.typesAndValues[t]))return!1;return!0}return e instanceof ArrayBuffer&&h.dN(this.valueBeforeDecode,e)}}V.CLASS_NAME="RelativeDistinguishedNames";let I="type",B="value";class E extends y{constructor(e={}){super(),this.type=h.H$(e,I,E.defaultValues(I)),this.value=h.H$(e,B,E.defaultValues(B)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case I:return 9;case B:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case I:return t===E.defaultValues(e);case B:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Choice({value:[new o.Constructed({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||"",value:[new o.ObjectIdentifier,new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Any]})]}),new o.Primitive({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:1}}),new o.Primitive({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:2}}),new o.Constructed({idBlock:{tagClass:3,tagNumber:3},name:t.blockName||"",value:[function(e={},t=!1){let a=h.H$(e,"names",{});return new o.Sequence({optional:t,value:[new o.Constructed({optional:!0,idBlock:{tagClass:2,tagNumber:1},name:a.country_name||"",value:[new o.Choice({value:[new o.NumericString,new o.PrintableString]})]}),new o.Constructed({optional:!0,idBlock:{tagClass:2,tagNumber:2},name:a.administration_domain_name||"",value:[new o.Choice({value:[new o.NumericString,new o.PrintableString]})]}),new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:0},name:a.network_address||"",isHexOnly:!0}),new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:1},name:a.terminal_identifier||"",isHexOnly:!0}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:2},name:a.private_domain_name||"",value:[new o.Choice({value:[new o.NumericString,new o.PrintableString]})]}),new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:3},name:a.organization_name||"",isHexOnly:!0}),new o.Primitive({optional:!0,name:a.numeric_user_identifier||"",idBlock:{tagClass:3,tagNumber:4},isHexOnly:!0}),new o.Constructed({optional:!0,name:a.personal_name||"",idBlock:{tagClass:3,tagNumber:5},value:[new o.Primitive({idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:1},isHexOnly:!0}),new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:2},isHexOnly:!0}),new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:3},isHexOnly:!0})]}),new o.Constructed({optional:!0,name:a.organizational_unit_names||"",idBlock:{tagClass:3,tagNumber:6},value:[new o.Repeated({value:new o.PrintableString})]})]})}(t.builtInStandardAttributes||{},!1),function(e=!1){return new o.Sequence({optional:e,value:[new o.PrintableString,new o.PrintableString]})}(!0),function(e=!1){return new o.Set({optional:e,value:[new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.Any]})]})}(!0)]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:4},name:t.blockName||"",value:[V.schema(t.directoryName||{})]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:5},name:t.blockName||"",value:[new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Choice({value:[new o.TeletexString,new o.PrintableString,new o.UniversalString,new o.Utf8String,new o.BmpString]})]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new o.Choice({value:[new o.TeletexString,new o.PrintableString,new o.UniversalString,new o.Utf8String,new o.BmpString]})]})]}),new o.Primitive({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:6}}),new o.Primitive({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:7}}),new o.Primitive({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:8}})]})}fromSchema(e){h.ze(e,["blockName","otherName","rfc822Name","dNSName","x400Address","directoryName","ediPartyName","uniformResourceIdentifier","iPAddress","registeredID"]);let t=o.compareSchema(e,e,E.schema({names:{blockName:"blockName",otherName:"otherName",rfc822Name:"rfc822Name",dNSName:"dNSName",x400Address:"x400Address",directoryName:{names:{blockName:"directoryName"}},ediPartyName:"ediPartyName",uniformResourceIdentifier:"uniformResourceIdentifier",iPAddress:"iPAddress",registeredID:"registeredID"}}));switch(S.assertSchema(t,this.className),this.type=t.result.blockName.idBlock.tagNumber,this.type){case 0:case 3:this.value=t.result.blockName;break;case 1:case 2:case 6:{let e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=22;let a=e.toBER(!1),s=o.fromBER(a);S.assert(s,"GeneralName value"),this.value=s.result.valueBlock.value}break;case 4:this.value=new V({schema:t.result.directoryName});break;case 5:this.value=t.result.ediPartyName;break;case 7:this.value=new o.OctetString({valueHex:t.result.blockName.valueBlock.valueHex});break;case 8:{let e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=6;let a=e.toBER(!1),s=o.fromBER(a);S.assert(s,"GeneralName registeredID"),this.value=s.result.valueBlock.toString()}}}toSchema(){switch(this.type){case 0:case 3:case 5:return new o.Constructed({idBlock:{tagClass:3,tagNumber:this.type},value:[this.value]});case 1:case 2:case 6:{let e=new o.IA5String({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 4:return new o.Constructed({idBlock:{tagClass:3,tagNumber:4},value:[this.value.toSchema()]});case 7:{let e=this.value;return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 8:{let e=new o.ObjectIdentifier({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}default:return E.schema()}}toJSON(){let e={type:this.type,value:""};if("string"==typeof this.value)e.value=this.value;else try{e.value=this.value.toJSON()}catch(e){}return e}}E.CLASS_NAME="GeneralName";let H="accessMethod",D="accessLocation",O=[H,D];class x extends y{constructor(e={}){super(),this.accessMethod=h.H$(e,H,x.defaultValues(H)),this.accessLocation=h.H$(e,D,x.defaultValues(D)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case H:return"";case D:return new E;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.accessMethod||""}),E.schema(t.accessLocation||{})]})}fromSchema(e){h.ze(e,O);let t=o.compareSchema(e,e,x.schema({names:{accessMethod:H,accessLocation:{names:{blockName:D}}}}));S.assertSchema(t,this.className),this.accessMethod=t.result.accessMethod.valueBlock.toString(),this.accessLocation=new E({schema:t.result.accessLocation})}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.accessMethod}),this.accessLocation.toSchema()]})}toJSON(){return{accessMethod:this.accessMethod,accessLocation:this.accessLocation.toJSON()}}}x.CLASS_NAME="AccessDescription";let P="seconds",$="millis",q="micros";class K extends y{constructor(e={}){super(),P in e&&(this.seconds=h.H$(e,P,K.defaultValues(P))),$ in e&&(this.millis=h.H$(e,$,K.defaultValues($))),q in e&&(this.micros=h.H$(e,q,K.defaultValues(q))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case P:case $:case q:return 0;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case P:case $:case q:return t===K.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",optional:!0,value:[new o.Integer({optional:!0,name:t.seconds||""}),new o.Primitive({name:t.millis||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new o.Primitive({name:t.micros||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){h.ze(e,[P,$,q]);let t=o.compareSchema(e,e,K.schema({names:{seconds:P,millis:$,micros:q}}));if(S.assertSchema(t,this.className),"seconds"in t.result&&(this.seconds=t.result.seconds.valueBlock.valueDec),"millis"in t.result){let e=new o.Integer({valueHex:t.result.millis.valueBlock.valueHex});this.millis=e.valueBlock.valueDec}if("micros"in t.result){let e=new o.Integer({valueHex:t.result.micros.valueBlock.valueHex});this.micros=e.valueBlock.valueDec}}toSchema(){let e=[];if(void 0!==this.seconds&&e.push(new o.Integer({value:this.seconds})),void 0!==this.millis){let t=new o.Integer({value:this.millis});e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:t.valueBlock.valueHexView}))}if(void 0!==this.micros){let t=new o.Integer({value:this.micros});e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:t.valueBlock.valueHexView}))}return new o.Sequence({value:e})}toJSON(){let e={};return void 0!==this.seconds&&(e.seconds=this.seconds),void 0!==this.millis&&(e.millis=this.millis),void 0!==this.micros&&(e.micros=this.micros),e}}K.CLASS_NAME="Accuracy";let R="algorithmId",J="algorithmParams",U="algorithm",T="params",j=[U,T];class L extends y{constructor(e={}){super(),this.algorithmId=h.H$(e,R,L.defaultValues(R)),J in e&&(this.algorithmParams=h.H$(e,J,L.defaultValues(J))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case R:return"";case J:return new o.Any;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case R:return""===t;case J:return t instanceof o.Any;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",optional:t.optional||!1,value:[new o.ObjectIdentifier({name:t.algorithmIdentifier||""}),new o.Any({name:t.algorithmParams||"",optional:!0})]})}fromSchema(e){h.ze(e,j);let t=o.compareSchema(e,e,L.schema({names:{algorithmIdentifier:U,algorithmParams:T}}));S.assertSchema(t,this.className),this.algorithmId=t.result.algorithm.valueBlock.toString(),T in t.result&&(this.algorithmParams=t.result.params)}toSchema(){let e=[];return e.push(new o.ObjectIdentifier({value:this.algorithmId})),!this.algorithmParams||this.algorithmParams instanceof o.Any||e.push(this.algorithmParams),new o.Sequence({value:e})}toJSON(){let e={algorithmId:this.algorithmId};return!this.algorithmParams||this.algorithmParams instanceof o.Any||(e.algorithmParams=this.algorithmParams.toJSON()),e}isEqual(e){return e instanceof L&&this.algorithmId===e.algorithmId&&(this.algorithmParams?!!e.algorithmParams&&JSON.stringify(this.algorithmParams)===JSON.stringify(e.algorithmParams):!e.algorithmParams)}}L.CLASS_NAME="AlgorithmIdentifier";let M="altNames",_=[M];class W extends y{constructor(e={}){super(),this.altNames=h.H$(e,M,W.defaultValues(M)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===M?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.altNames||"",value:E.schema()})]})}fromSchema(e){h.ze(e,_);let t=o.compareSchema(e,e,W.schema({names:{altNames:M}}));S.assertSchema(t,this.className),M in t.result&&(this.altNames=Array.from(t.result.altNames,e=>new E({schema:e})))}toSchema(){return new o.Sequence({value:Array.from(this.altNames,e=>e.toSchema())})}toJSON(){return{altNames:Array.from(this.altNames,e=>e.toJSON())}}}W.CLASS_NAME="AltName";let z="type",F="values",G=[z,F];class Q extends y{constructor(e={}){super(),this.type=h.H$(e,z,Q.defaultValues(z)),this.values=h.H$(e,F,Q.defaultValues(F)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case z:return"";case F:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case z:return""===t;case F:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.type||""}),new o.Set({name:t.setName||"",value:[new o.Repeated({name:t.values||"",value:new o.Any})]})]})}fromSchema(e){h.ze(e,G);let t=o.compareSchema(e,e,Q.schema({names:{type:z,values:F}}));S.assertSchema(t,this.className),this.type=t.result.type.valueBlock.toString(),this.values=t.result.values}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.type}),new o.Set({value:this.values})]})}toJSON(){return{type:this.type,values:Array.from(this.values,e=>e.toJSON())}}}Q.CLASS_NAME="Attribute";let X="notBeforeTime",Y="notAfterTime",Z=[X,Y];class ee extends y{constructor(e={}){super(),this.notBeforeTime=h.H$(e,X,ee.defaultValues(X)),this.notAfterTime=h.H$(e,Y,ee.defaultValues(Y)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case X:case Y:return new Date(0,0,0);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.GeneralizedTime({name:t.notBeforeTime||""}),new o.GeneralizedTime({name:t.notAfterTime||""})]})}fromSchema(e){h.ze(e,Z);let t=o.compareSchema(e,e,ee.schema({names:{notBeforeTime:X,notAfterTime:Y}}));S.assertSchema(t,this.className),this.notBeforeTime=t.result.notBeforeTime.toDate(),this.notAfterTime=t.result.notAfterTime.toDate()}toSchema(){return new o.Sequence({value:[new o.GeneralizedTime({valueDate:this.notBeforeTime}),new o.GeneralizedTime({valueDate:this.notAfterTime})]})}toJSON(){return{notBeforeTime:this.notBeforeTime,notAfterTime:this.notAfterTime}}}ee.CLASS_NAME="AttCertValidityPeriod";let et="names",ea="generalNames";class es extends y{constructor(e={}){super(),this.names=h.H$(e,et,es.defaultValues(et)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return"names"===e?[]:super.defaultValues(e)}static schema(e={},t=!1){let a=h.H$(e,et,{});return new o.Sequence({optional:t,name:a.blockName||"",value:[new o.Repeated({name:a.generalNames||"",value:E.schema()})]})}fromSchema(e){h.ze(e,[et,ea]);let t=o.compareSchema(e,e,es.schema({names:{blockName:et,generalNames:ea}}));S.assertSchema(t,this.className),this.names=Array.from(t.result.generalNames,e=>new E({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.names,e=>e.toSchema())})}toJSON(){return{names:Array.from(this.names,e=>e.toJSON())}}}es.CLASS_NAME="GeneralNames";let er="2.5.29.9",ei="2.5.29.14",en="2.5.29.15",eu="2.5.29.16",el="2.5.29.17",eo="2.5.29.18",ec="2.5.29.19",eh="2.5.29.20",em="2.5.29.27",ef="2.5.29.21",ed="2.5.29.24",eg="2.5.29.28",ep="2.5.29.29",eS="2.5.29.30",ey="2.5.29.31",ew="2.5.29.46",ev="2.5.29.32",eb="2.5.29.32.0",eA="1.3.6.1.4.1.311.21.10",ek="2.5.29.33",eC="2.5.29.35",eN="2.5.29.36",eV="2.5.29.37",eI="2.5.29.54",eB="1.3.6.1.5.5.7.1.1",eE="1.3.6.1.5.5.7.1.11",eH="1.3.6.1.4.1.11129.2.4.2",eD="1.3.6.1.4.1.311.20.2",eO="1.3.6.1.4.1.311.21.2",ex="1.3.6.1.4.1.311.21.7",eP="1.3.6.1.4.1.311.21.1",e$="1.3.6.1.5.5.7.1.3",eq="1.2.840.113549.1.7.1",eK="1.2.840.113549.1.7.2",eR="1.2.840.113549.1.7.3",eJ="1.2.840.113549.1.7.6",eU="1.2.840.113549.1.9.16.1.4",eT="1.2.840.113549.1.9.22.1",ej="1.2.840.113549.1.9.22.2",eL="1.2.840.113549.1.9.22.3",eM="1.2.840.113549.1.9.23.1",e_="1.3.6.1.5.5.7",eW=`${e_}.48`,ez=`${eW}.1.1`,eF=`${eW}.2`,eG=`${eW}.1`,eQ="1.3.14.3.2.26",eX="2.16.840.1.101.3.4.2.1",eY="2.16.840.1.101.3.4.2.2",eZ="2.16.840.1.101.3.4.2.3",e1="keyIdentifier",e0="authorityCertIssuer",e2="authorityCertSerialNumber",e3=[e1,e0,e2];class e4 extends y{constructor(e={}){super(),e1 in e&&(this.keyIdentifier=h.H$(e,e1,e4.defaultValues(e1))),e0 in e&&(this.authorityCertIssuer=h.H$(e,e0,e4.defaultValues(e0))),e2 in e&&(this.authorityCertSerialNumber=h.H$(e,e2,e4.defaultValues(e2))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case e1:return new o.OctetString;case e0:return[];case e2:return new o.Integer;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Primitive({name:t.keyIdentifier||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.Repeated({name:t.authorityCertIssuer||"",value:E.schema()})]}),new o.Primitive({name:t.authorityCertSerialNumber||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}})]})}fromSchema(e){h.ze(e,e3);let t=o.compareSchema(e,e,e4.schema({names:{keyIdentifier:e1,authorityCertIssuer:e0,authorityCertSerialNumber:e2}}));S.assertSchema(t,this.className),e1 in t.result&&(this.keyIdentifier=new o.OctetString({valueHex:t.result.keyIdentifier.valueBlock.valueHex})),e0 in t.result&&(this.authorityCertIssuer=Array.from(t.result.authorityCertIssuer,e=>new E({schema:e}))),e2 in t.result&&(this.authorityCertSerialNumber=new o.Integer({valueHex:t.result.authorityCertSerialNumber.valueBlock.valueHex}))}toSchema(){let e=[];return this.keyIdentifier&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:this.keyIdentifier.valueBlock.valueHexView})),this.authorityCertIssuer&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.authorityCertIssuer,e=>e.toSchema())})),this.authorityCertSerialNumber&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:2},valueHex:this.authorityCertSerialNumber.valueBlock.valueHexView})),new o.Sequence({value:e})}toJSON(){let e={};return this.keyIdentifier&&(e.keyIdentifier=this.keyIdentifier.toJSON()),this.authorityCertIssuer&&(e.authorityCertIssuer=Array.from(this.authorityCertIssuer,e=>e.toJSON())),this.authorityCertSerialNumber&&(e.authorityCertSerialNumber=this.authorityCertSerialNumber.toJSON()),e}}e4.CLASS_NAME="AuthorityKeyIdentifier";let e8="pathLenConstraint";class e5 extends y{constructor(e={}){super(),this.cA=h.H$(e,"cA",!1),e8 in e&&(this.pathLenConstraint=h.H$(e,e8,0)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return"cA"!==e&&super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Boolean({optional:!0,name:t.cA||""}),new o.Integer({optional:!0,name:t.pathLenConstraint||""})]})}fromSchema(e){h.ze(e,["cA",e8]);let t=o.compareSchema(e,e,e5.schema({names:{cA:"cA",pathLenConstraint:e8}}));S.assertSchema(t,this.className),"cA"in t.result&&(this.cA=t.result.cA.valueBlock.value),e8 in t.result&&(t.result.pathLenConstraint.valueBlock.isHexOnly?this.pathLenConstraint=t.result.pathLenConstraint:this.pathLenConstraint=t.result.pathLenConstraint.valueBlock.valueDec)}toSchema(){let e=[];return this.cA!==e5.defaultValues("cA")&&e.push(new o.Boolean({value:this.cA})),e8 in this&&(this.pathLenConstraint instanceof o.Integer?e.push(this.pathLenConstraint):e.push(new o.Integer({value:this.pathLenConstraint}))),new o.Sequence({value:e})}toJSON(){let e={};return this.cA!==e5.defaultValues("cA")&&(e.cA=this.cA),e8 in this&&(this.pathLenConstraint instanceof o.Integer?e.pathLenConstraint=this.pathLenConstraint.toJSON():e.pathLenConstraint=this.pathLenConstraint),e}}e5.CLASS_NAME="BasicConstraints";let e6="certificateIndex",e9="keyIndex";class e7 extends y{constructor(e={}){super(),this.certificateIndex=h.H$(e,e6,e7.defaultValues(e6)),this.keyIndex=h.H$(e,e9,e7.defaultValues(e9)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case e6:case e9:return 0;default:return super.defaultValues(e)}}static schema(){return new o.Integer}fromSchema(e){if(e.constructor.blockName()!==o.Integer.blockName())throw Error("Object's schema was not verified against input data for CAVersion");let t=e.valueBlock.valueHex.slice(0),a=new Uint8Array(t);switch(!0){case t.byteLength<4:{let e=new ArrayBuffer(4),s=new Uint8Array(e);s.set(a,4-t.byteLength),t=e.slice(0)}break;case t.byteLength>4:{let e=new ArrayBuffer(4),s=new Uint8Array(e);s.set(a.slice(0,4)),t=e.slice(0)}}let s=t.slice(0,2),r=new Uint8Array(s),i=r[0];r[0]=r[1],r[1]=i;let n=new Uint16Array(s);this.keyIndex=n[0];let u=t.slice(2),l=new Uint8Array(u);i=l[0],l[0]=l[1],l[1]=i;let c=new Uint16Array(u);this.certificateIndex=c[0]}toSchema(){let e=new ArrayBuffer(2),t=new Uint16Array(e);t[0]=this.certificateIndex;let a=new Uint8Array(e),s=a[0];a[0]=a[1],a[1]=s;let r=new ArrayBuffer(2),i=new Uint16Array(r);i[0]=this.keyIndex;let n=new Uint8Array(r);return s=n[0],n[0]=n[1],n[1]=s,new o.Integer({valueHex:h.hk(r,e)})}toJSON(){return{certificateIndex:this.certificateIndex,keyIndex:this.keyIndex}}}e7.CLASS_NAME="CAVersion";let te="policyQualifierId",tt="qualifier",ta=[te,tt];class ts extends y{constructor(e={}){super(),this.policyQualifierId=h.H$(e,te,ts.defaultValues(te)),this.qualifier=h.H$(e,tt,ts.defaultValues(tt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case te:return"";case tt:return new o.Any;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.policyQualifierId||""}),new o.Any({name:t.qualifier||""})]})}fromSchema(e){h.ze(e,ta);let t=o.compareSchema(e,e,ts.schema({names:{policyQualifierId:te,qualifier:tt}}));S.assertSchema(t,this.className),this.policyQualifierId=t.result.policyQualifierId.valueBlock.toString(),this.qualifier=t.result.qualifier}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.policyQualifierId}),this.qualifier]})}toJSON(){return{policyQualifierId:this.policyQualifierId,qualifier:this.qualifier.toJSON()}}}ts.CLASS_NAME="PolicyQualifierInfo";let tr="policyIdentifier",ti="policyQualifiers",tn=[tr,ti];class tu extends y{constructor(e={}){super(),this.policyIdentifier=h.H$(e,tr,tu.defaultValues(tr)),ti in e&&(this.policyQualifiers=h.H$(e,ti,tu.defaultValues(ti))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tr:return"";case ti:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.policyIdentifier||""}),new o.Sequence({optional:!0,value:[new o.Repeated({name:t.policyQualifiers||"",value:ts.schema()})]})]})}fromSchema(e){h.ze(e,tn);let t=o.compareSchema(e,e,tu.schema({names:{policyIdentifier:tr,policyQualifiers:ti}}));S.assertSchema(t,this.className),this.policyIdentifier=t.result.policyIdentifier.valueBlock.toString(),ti in t.result&&(this.policyQualifiers=Array.from(t.result.policyQualifiers,e=>new ts({schema:e})))}toSchema(){let e=[];return e.push(new o.ObjectIdentifier({value:this.policyIdentifier})),this.policyQualifiers&&e.push(new o.Sequence({value:Array.from(this.policyQualifiers,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={policyIdentifier:this.policyIdentifier};return this.policyQualifiers&&(e.policyQualifiers=Array.from(this.policyQualifiers,e=>e.toJSON())),e}}tu.CLASS_NAME="PolicyInformation";let tl="certificatePolicies",to=[tl];class tc extends y{constructor(e={}){super(),this.certificatePolicies=h.H$(e,tl,tc.defaultValues(tl)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===tl?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.certificatePolicies||"",value:tu.schema()})]})}fromSchema(e){h.ze(e,to);let t=o.compareSchema(e,e,tc.schema({names:{certificatePolicies:tl}}));S.assertSchema(t,this.className),this.certificatePolicies=Array.from(t.result.certificatePolicies,e=>new tu({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.certificatePolicies,e=>e.toSchema())})}toJSON(){return{certificatePolicies:Array.from(this.certificatePolicies,e=>e.toJSON())}}}tc.CLASS_NAME="CertificatePolicies";let th="templateID",tm="templateMajorVersion",tf="templateMinorVersion",td=[th,tm,tf];class tg extends y{constructor(e={}){super(),this.templateID=h.H$(e,th,tg.defaultValues(th)),tm in e&&(this.templateMajorVersion=h.H$(e,tm,tg.defaultValues(tm))),tf in e&&(this.templateMinorVersion=h.H$(e,tf,tg.defaultValues(tf))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case th:return"";case tm:case tf:return 0;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.templateID||""}),new o.Integer({name:t.templateMajorVersion||"",optional:!0}),new o.Integer({name:t.templateMinorVersion||"",optional:!0})]})}fromSchema(e){h.ze(e,td);let t=o.compareSchema(e,e,tg.schema({names:{templateID:th,templateMajorVersion:tm,templateMinorVersion:tf}}));S.assertSchema(t,this.className),this.templateID=t.result.templateID.valueBlock.toString(),tm in t.result&&(this.templateMajorVersion=t.result.templateMajorVersion.valueBlock.valueDec),tf in t.result&&(this.templateMinorVersion=t.result.templateMinorVersion.valueBlock.valueDec)}toSchema(){let e=[];return e.push(new o.ObjectIdentifier({value:this.templateID})),tm in this&&e.push(new o.Integer({value:this.templateMajorVersion})),tf in this&&e.push(new o.Integer({value:this.templateMinorVersion})),new o.Sequence({value:e})}toJSON(){let e={templateID:this.templateID};return tm in this&&(e.templateMajorVersion=this.templateMajorVersion),tf in this&&(e.templateMinorVersion=this.templateMinorVersion),e}}let tp="distributionPoint",tS="distributionPointNames",ty="reasons",tw="cRLIssuer",tv="cRLIssuerNames",tb=[tp,tS,ty,tw,tv];class tA extends y{constructor(e={}){super(),tp in e&&(this.distributionPoint=h.H$(e,tp,tA.defaultValues(tp))),ty in e&&(this.reasons=h.H$(e,ty,tA.defaultValues(ty))),tw in e&&(this.cRLIssuer=h.H$(e,tw,tA.defaultValues(tw))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tp:return[];case ty:return new o.BitString;case tw:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Choice({value:[new o.Constructed({name:t.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Repeated({name:t.distributionPointNames||"",value:E.schema()})]}),new o.Constructed({name:t.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:1},value:V.schema().valueBlock.value})]})]}),new o.Primitive({name:t.reasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new o.Constructed({name:t.cRLIssuer||"",optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[new o.Repeated({name:t.cRLIssuerNames||"",value:E.schema()})]})]})}fromSchema(e){h.ze(e,tb);let t=o.compareSchema(e,e,tA.schema({names:{distributionPoint:tp,distributionPointNames:tS,reasons:ty,cRLIssuer:tw,cRLIssuerNames:tv}}));S.assertSchema(t,this.className),tp in t.result&&(0===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new E({schema:e}))),1===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=new V({schema:new o.Sequence({value:t.result.distributionPoint.valueBlock.value})}))),ty in t.result&&(this.reasons=new o.BitString({valueHex:t.result.reasons.valueBlock.valueHex})),tw in t.result&&(this.cRLIssuer=Array.from(t.result.cRLIssuerNames,e=>new E({schema:e})))}toSchema(){let e=[];if(this.distributionPoint){let t;t=new o.Constructed(this.distributionPoint instanceof Array?{idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}:{idBlock:{tagClass:3,tagNumber:1},value:[this.distributionPoint.toSchema()]}),e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}return this.reasons&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:this.reasons.valueBlock.valueHexView})),this.cRLIssuer&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:Array.from(this.cRLIssuer,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={};return this.distributionPoint&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),this.reasons&&(e.reasons=this.reasons.toJSON()),this.cRLIssuer&&(e.cRLIssuer=Array.from(this.cRLIssuer,e=>e.toJSON())),e}}tA.CLASS_NAME="DistributionPoint";let tk="distributionPoints",tC=[tk];class tN extends y{constructor(e={}){super(),this.distributionPoints=h.H$(e,tk,tN.defaultValues(tk)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===tk?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.distributionPoints||"",value:tA.schema()})]})}fromSchema(e){h.ze(e,tC);let t=o.compareSchema(e,e,tN.schema({names:{distributionPoints:tk}}));S.assertSchema(t,this.className),this.distributionPoints=Array.from(t.result.distributionPoints,e=>new tA({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.distributionPoints,e=>e.toSchema())})}toJSON(){return{distributionPoints:Array.from(this.distributionPoints,e=>e.toJSON())}}}tN.CLASS_NAME="CRLDistributionPoints";let tV="keyPurposes",tI=[tV];class tB extends y{constructor(e={}){super(),this.keyPurposes=h.H$(e,tV,tB.defaultValues(tV)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===tV?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.keyPurposes||"",value:new o.ObjectIdentifier})]})}fromSchema(e){h.ze(e,tI);let t=o.compareSchema(e,e,tB.schema({names:{keyPurposes:tV}}));S.assertSchema(t,this.className),this.keyPurposes=Array.from(t.result.keyPurposes,e=>e.valueBlock.toString())}toSchema(){return new o.Sequence({value:Array.from(this.keyPurposes,e=>new o.ObjectIdentifier({value:e}))})}toJSON(){return{keyPurposes:Array.from(this.keyPurposes)}}}tB.CLASS_NAME="ExtKeyUsage";let tE="accessDescriptions";class tH extends y{constructor(e={}){super(),this.accessDescriptions=h.H$(e,tE,tH.defaultValues(tE)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===tE?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.accessDescriptions||"",value:x.schema()})]})}fromSchema(e){h.ze(e,[tE]);let t=o.compareSchema(e,e,tH.schema({names:{accessDescriptions:tE}}));S.assertSchema(t,this.className),this.accessDescriptions=Array.from(t.result.accessDescriptions,e=>new x({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.accessDescriptions,e=>e.toSchema())})}toJSON(){return{accessDescriptions:Array.from(this.accessDescriptions,e=>e.toJSON())}}}tH.CLASS_NAME="InfoAccess";let tD="distributionPoint",tO="distributionPointNames",tx="onlyContainsUserCerts",tP="onlyContainsCACerts",t$="onlySomeReasons",tq="indirectCRL",tK="onlyContainsAttributeCerts",tR=[tD,tO,tx,tP,t$,tq,tK];class tJ extends y{constructor(e={}){super(),tD in e&&(this.distributionPoint=h.H$(e,tD,tJ.defaultValues(tD))),this.onlyContainsUserCerts=h.H$(e,tx,tJ.defaultValues(tx)),this.onlyContainsCACerts=h.H$(e,tP,tJ.defaultValues(tP)),t$ in e&&(this.onlySomeReasons=h.H$(e,t$,tJ.defaultValues(t$))),this.indirectCRL=h.H$(e,tq,tJ.defaultValues(tq)),this.onlyContainsAttributeCerts=h.H$(e,tK,tJ.defaultValues(tK)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tD:return[];case tx:case tP:return!1;case t$:return 0;case tq:case tK:return!1;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Choice({value:[new o.Constructed({name:t.distributionPoint||"",idBlock:{tagClass:3,tagNumber:0},value:[new o.Repeated({name:t.distributionPointNames||"",value:E.schema()})]}),new o.Constructed({name:t.distributionPoint||"",idBlock:{tagClass:3,tagNumber:1},value:V.schema().valueBlock.value})]})]}),new o.Primitive({name:t.onlyContainsUserCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new o.Primitive({name:t.onlyContainsCACerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new o.Primitive({name:t.onlySomeReasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:3}}),new o.Primitive({name:t.indirectCRL||"",optional:!0,idBlock:{tagClass:3,tagNumber:4}}),new o.Primitive({name:t.onlyContainsAttributeCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:5}})]})}fromSchema(e){h.ze(e,tR);let t=o.compareSchema(e,e,tJ.schema({names:{distributionPoint:tD,distributionPointNames:tO,onlyContainsUserCerts:tx,onlyContainsCACerts:tP,onlySomeReasons:t$,indirectCRL:tq,onlyContainsAttributeCerts:tK}}));if(S.assertSchema(t,this.className),tD in t.result)switch(!0){case 0===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new E({schema:e}));break;case 1===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=new V({schema:new o.Sequence({value:t.result.distributionPoint.valueBlock.value})});break;default:throw Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}")}if(tx in t.result){let e=new Uint8Array(t.result.onlyContainsUserCerts.valueBlock.valueHex);this.onlyContainsUserCerts=0!==e[0]}if(tP in t.result){let e=new Uint8Array(t.result.onlyContainsCACerts.valueBlock.valueHex);this.onlyContainsCACerts=0!==e[0]}if(t$ in t.result){let e=new Uint8Array(t.result.onlySomeReasons.valueBlock.valueHex);this.onlySomeReasons=e[0]}if(tq in t.result){let e=new Uint8Array(t.result.indirectCRL.valueBlock.valueHex);this.indirectCRL=0!==e[0]}if(tK in t.result){let e=new Uint8Array(t.result.onlyContainsAttributeCerts.valueBlock.valueHex);this.onlyContainsAttributeCerts=0!==e[0]}}toSchema(){let e=[];if(this.distributionPoint){let t;this.distributionPoint instanceof Array?t=new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):((t=this.distributionPoint.toSchema()).idBlock.tagClass=3,t.idBlock.tagNumber=1),e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(this.onlyContainsUserCerts!==tJ.defaultValues(tx)&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsCACerts!==tJ.defaultValues(tP)&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:2},valueHex:new Uint8Array([255]).buffer})),void 0!==this.onlySomeReasons){let t=new ArrayBuffer(1),a=new Uint8Array(t);a[0]=this.onlySomeReasons,e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:3},valueHex:t}))}return this.indirectCRL!==tJ.defaultValues(tq)&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:4},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsAttributeCerts!==tJ.defaultValues(tK)&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:5},valueHex:new Uint8Array([255]).buffer})),new o.Sequence({value:e})}toJSON(){let e={};return this.distributionPoint&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),this.onlyContainsUserCerts!==tJ.defaultValues(tx)&&(e.onlyContainsUserCerts=this.onlyContainsUserCerts),this.onlyContainsCACerts!==tJ.defaultValues(tP)&&(e.onlyContainsCACerts=this.onlyContainsCACerts),t$ in this&&(e.onlySomeReasons=this.onlySomeReasons),this.indirectCRL!==tJ.defaultValues(tq)&&(e.indirectCRL=this.indirectCRL),this.onlyContainsAttributeCerts!==tJ.defaultValues(tK)&&(e.onlyContainsAttributeCerts=this.onlyContainsAttributeCerts),e}}tJ.CLASS_NAME="IssuingDistributionPoint";let tU="base",tT="minimum",tj="maximum",tL=[tU,tT,tj];class tM extends y{constructor(e={}){super(),this.base=h.H$(e,tU,tM.defaultValues(tU)),this.minimum=h.H$(e,tT,tM.defaultValues(tT)),tj in e&&(this.maximum=h.H$(e,tj,tM.defaultValues(tj))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tU:return new E;case tT:case tj:return 0;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[E.schema(t.base||{}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Integer({name:t.minimum||""})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.Integer({name:t.maximum||""})]})]})}fromSchema(e){h.ze(e,tL);let t=o.compareSchema(e,e,tM.schema({names:{base:{names:{blockName:tU}},minimum:tT,maximum:tj}}));S.assertSchema(t,this.className),this.base=new E({schema:t.result.base}),tT in t.result&&(t.result.minimum.valueBlock.isHexOnly?this.minimum=t.result.minimum:this.minimum=t.result.minimum.valueBlock.valueDec),tj in t.result&&(t.result.maximum.valueBlock.isHexOnly?this.maximum=t.result.maximum:this.maximum=t.result.maximum.valueBlock.valueDec)}toSchema(){let e=[];if(e.push(this.base.toSchema()),0!==this.minimum){let t=0;t=this.minimum instanceof o.Integer?this.minimum:new o.Integer({value:this.minimum}),e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(tj in this){let t=0;t=this.maximum instanceof o.Integer?this.maximum:new o.Integer({value:this.maximum}),e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[t]}))}return new o.Sequence({value:e})}toJSON(){let e={base:this.base.toJSON()};return 0!==this.minimum&&("number"==typeof this.minimum?e.minimum=this.minimum:e.minimum=this.minimum.toJSON()),void 0!==this.maximum&&("number"==typeof this.maximum?e.maximum=this.maximum:e.maximum=this.maximum.toJSON()),e}}tM.CLASS_NAME="GeneralSubtree";let t_="permittedSubtrees",tW="excludedSubtrees",tz=[t_,tW];class tF extends y{constructor(e={}){super(),t_ in e&&(this.permittedSubtrees=h.H$(e,t_,tF.defaultValues(t_))),tW in e&&(this.excludedSubtrees=h.H$(e,tW,tF.defaultValues(tW))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case t_:case tW:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Repeated({name:t.permittedSubtrees||"",value:tM.schema()})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.Repeated({name:t.excludedSubtrees||"",value:tM.schema()})]})]})}fromSchema(e){h.ze(e,tz);let t=o.compareSchema(e,e,tF.schema({names:{permittedSubtrees:t_,excludedSubtrees:tW}}));S.assertSchema(t,this.className),t_ in t.result&&(this.permittedSubtrees=Array.from(t.result.permittedSubtrees,e=>new tM({schema:e}))),tW in t.result&&(this.excludedSubtrees=Array.from(t.result.excludedSubtrees,e=>new tM({schema:e})))}toSchema(){let e=[];return this.permittedSubtrees&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.permittedSubtrees,e=>e.toSchema())})),this.excludedSubtrees&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.excludedSubtrees,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={};return this.permittedSubtrees&&(e.permittedSubtrees=Array.from(this.permittedSubtrees,e=>e.toJSON())),this.excludedSubtrees&&(e.excludedSubtrees=Array.from(this.excludedSubtrees,e=>e.toJSON())),e}}tF.CLASS_NAME="NameConstraints";let tG="requireExplicitPolicy",tQ="inhibitPolicyMapping",tX=[tG,tQ];class tY extends y{constructor(e={}){super(),tG in e&&(this.requireExplicitPolicy=h.H$(e,tG,tY.defaultValues(tG))),tQ in e&&(this.inhibitPolicyMapping=h.H$(e,tQ,tY.defaultValues(tQ))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tG:case tQ:return 0;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Primitive({name:t.requireExplicitPolicy||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new o.Primitive({name:t.inhibitPolicyMapping||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){h.ze(e,tX);let t=o.compareSchema(e,e,tY.schema({names:{requireExplicitPolicy:tG,inhibitPolicyMapping:tQ}}));if(S.assertSchema(t,this.className),tG in t.result){let e=t.result.requireExplicitPolicy;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;let a=e.toBER(!1),s=o.fromBER(a);S.assert(s,"Integer"),this.requireExplicitPolicy=s.result.valueBlock.valueDec}if(tQ in t.result){let e=t.result.inhibitPolicyMapping;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;let a=e.toBER(!1),s=o.fromBER(a);S.assert(s,"Integer"),this.inhibitPolicyMapping=s.result.valueBlock.valueDec}}toSchema(){let e=[];if(tG in this){let t=new o.Integer({value:this.requireExplicitPolicy});t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if(tQ in this){let t=new o.Integer({value:this.inhibitPolicyMapping});t.idBlock.tagClass=3,t.idBlock.tagNumber=1,e.push(t)}return new o.Sequence({value:e})}toJSON(){let e={};return tG in this&&(e.requireExplicitPolicy=this.requireExplicitPolicy),tQ in this&&(e.inhibitPolicyMapping=this.inhibitPolicyMapping),e}}tY.CLASS_NAME="PolicyConstraints";let tZ="issuerDomainPolicy",t1="subjectDomainPolicy",t0=[tZ,t1];class t2 extends y{constructor(e={}){super(),this.issuerDomainPolicy=h.H$(e,tZ,t2.defaultValues(tZ)),this.subjectDomainPolicy=h.H$(e,t1,t2.defaultValues(t1)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tZ:case t1:return"";default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.issuerDomainPolicy||""}),new o.ObjectIdentifier({name:t.subjectDomainPolicy||""})]})}fromSchema(e){h.ze(e,t0);let t=o.compareSchema(e,e,t2.schema({names:{issuerDomainPolicy:tZ,subjectDomainPolicy:t1}}));S.assertSchema(t,this.className),this.issuerDomainPolicy=t.result.issuerDomainPolicy.valueBlock.toString(),this.subjectDomainPolicy=t.result.subjectDomainPolicy.valueBlock.toString()}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.issuerDomainPolicy}),new o.ObjectIdentifier({value:this.subjectDomainPolicy})]})}toJSON(){return{issuerDomainPolicy:this.issuerDomainPolicy,subjectDomainPolicy:this.subjectDomainPolicy}}}t2.CLASS_NAME="PolicyMapping";let t3="mappings",t4=[t3];class t8 extends y{constructor(e={}){super(),this.mappings=h.H$(e,t3,t8.defaultValues(t3)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===t3?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.mappings||"",value:t2.schema()})]})}fromSchema(e){h.ze(e,t4);let t=o.compareSchema(e,e,t8.schema({names:{mappings:t3}}));S.assertSchema(t,this.className),this.mappings=Array.from(t.result.mappings,e=>new t2({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.mappings,e=>e.toSchema())})}toJSON(){return{mappings:Array.from(this.mappings,e=>e.toJSON())}}}t8.CLASS_NAME="PolicyMappings";let t5="notBefore",t6="notAfter",t9=[t5,t6];class t7 extends y{constructor(e={}){super(),t5 in e&&(this.notBefore=h.H$(e,t5,t7.defaultValues(t5))),t6 in e&&(this.notAfter=h.H$(e,t6,t7.defaultValues(t6))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case t5:case t6:return new Date;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Primitive({name:t.notBefore||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new o.Primitive({name:t.notAfter||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){h.ze(e,t9);let t=o.compareSchema(e,e,t7.schema({names:{notBefore:t5,notAfter:t6}}));if(S.assertSchema(t,this.className),t5 in t.result){let e=new o.GeneralizedTime;e.fromBuffer(t.result.notBefore.valueBlock.valueHex),this.notBefore=e.toDate()}if(t6 in t.result){let e=new o.GeneralizedTime({valueHex:t.result.notAfter.valueBlock.valueHex});e.fromBuffer(t.result.notAfter.valueBlock.valueHex),this.notAfter=e.toDate()}}toSchema(){let e=[];return t5 in this&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:new o.GeneralizedTime({valueDate:this.notBefore}).valueBlock.valueHexView})),t6 in this&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:new o.GeneralizedTime({valueDate:this.notAfter}).valueBlock.valueHexView})),new o.Sequence({value:e})}toJSON(){let e={};return this.notBefore&&(e.notBefore=this.notBefore),this.notAfter&&(e.notAfter=this.notAfter),e}}t7.CLASS_NAME="PrivateKeyUsagePeriod";let ae="type",at="values",aa=["id",ae],as=[at];class ar extends y{constructor(e={}){super(),this.id=h.H$(e,"id",ar.defaultValues("id")),ae in e&&(this.type=h.H$(e,ae,ar.defaultValues(ae))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"id":return"";case ae:return new o.Null;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"id":return""===t;case ae:return t instanceof o.Null;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.id||""}),new o.Any({name:t.type||"",optional:!0})]})}fromSchema(e){h.ze(e,aa);let t=o.compareSchema(e,e,ar.schema({names:{id:"id",type:ae}}));S.assertSchema(t,this.className),this.id=t.result.id.valueBlock.toString(),ae in t.result&&(this.type=t.result.type)}toSchema(){let e=[new o.ObjectIdentifier({value:this.id})];return ae in this&&e.push(this.type),new o.Sequence({value:e})}toJSON(){let e={id:this.id};return this.type&&(e.type=this.type.toJSON()),e}}ar.CLASS_NAME="QCStatement";class ai extends y{constructor(e={}){super(),this.values=h.H$(e,at,ai.defaultValues(at)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===at?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===at?0===t.length:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.values||"",value:ar.schema(t.value||{})})]})}fromSchema(e){h.ze(e,as);let t=o.compareSchema(e,e,ai.schema({names:{values:at}}));S.assertSchema(t,this.className),this.values=Array.from(t.result.values,e=>new ar({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.values,e=>e.toSchema())})}toJSON(){return{values:Array.from(this.values,e=>e.toJSON())}}}ai.CLASS_NAME="QCStatements";class an{static register(e,t,a){this.namedCurves[e.toLowerCase()]=this.namedCurves[t]={name:e,id:t,size:a}}static find(e){return this.namedCurves[e.toLowerCase()]||null}}an.namedCurves={},an.register("P-256","1.2.840.10045.3.1.7",32),an.register("P-384","1.3.132.0.34",48),an.register("P-521","1.3.132.0.35",66),an.register("brainpoolP256r1","1.3.36.3.3.2.8.1.1.7",32),an.register("brainpoolP384r1","1.3.36.3.3.2.8.1.1.11",48),an.register("brainpoolP512r1","1.3.36.3.3.2.8.1.1.13",64);let au="namedCurve";class al extends y{constructor(e={}){super(),this.x=h.H$(e,"x",al.defaultValues("x")),this.y=h.H$(e,"y",al.defaultValues("y")),this.namedCurve=h.H$(e,au,al.defaultValues(au)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"x":case"y":return d;case au:return"";default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"x":case"y":return t instanceof ArrayBuffer&&h.dN(t,al.defaultValues(e));case au:return"string"==typeof t&&t===al.defaultValues(e);default:return super.defaultValues(e)}}static schema(){return new o.RawData}fromSchema(e){let t=c.vJ.toUint8Array(e);if(4!==t[0])throw Error("Object's schema was not verified against input data for ECPublicKey");let a=an.find(this.namedCurve);if(!a)throw Error(`Incorrect curve OID: ${this.namedCurve}`);let s=a.size;if(t.byteLength!==2*s+1)throw Error("Object's schema was not verified against input data for ECPublicKey");this.namedCurve=a.name,this.x=t.slice(1,s+1).buffer,this.y=t.slice(1+s,2*s+1).buffer}toSchema(){return new o.RawData({data:h.hk(new Uint8Array([4]).buffer,this.x,this.y)})}toJSON(){let e=an.find(this.namedCurve);return{crv:e?e.name:this.namedCurve,x:h.s3(h.lE(this.x),!0,!0,!1),y:h.s3(h.lE(this.y),!0,!0,!1)}}fromJSON(e){p.assert("json",e,"crv","x","y");let t=0,a=an.find(e.crv);a&&(this.namedCurve=a.id,t=a.size);let s=h.gG(h.Gh(e.x,!0));if(s.byteLength<t){this.x=new ArrayBuffer(t);let e=new Uint8Array(this.x),a=new Uint8Array(s);e.set(a,1)}else this.x=s.slice(0,t);let r=h.gG(h.Gh(e.y,!0));if(r.byteLength<t){this.y=new ArrayBuffer(t);let e=new Uint8Array(this.y),a=new Uint8Array(r);e.set(a,1)}else this.y=r.slice(0,t)}}al.CLASS_NAME="ECPublicKey";let ao="modulus",ac="publicExponent",ah=[ao,ac];class am extends y{constructor(e={}){super(),this.modulus=h.H$(e,ao,am.defaultValues(ao)),this.publicExponent=h.H$(e,ac,am.defaultValues(ac)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ao:case ac:return new o.Integer;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.modulus||""}),new o.Integer({name:t.publicExponent||""})]})}fromSchema(e){h.ze(e,ah);let t=o.compareSchema(e,e,am.schema({names:{modulus:ao,publicExponent:ac}}));S.assertSchema(t,this.className),this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent}toSchema(){return new o.Sequence({value:[this.modulus.convertToDER(),this.publicExponent]})}toJSON(){return{n:c.ep.ToBase64Url(this.modulus.valueBlock.valueHexView),e:c.ep.ToBase64Url(this.publicExponent.valueBlock.valueHexView)}}fromJSON(e){p.assert("json",e,"n","e");let t=h.gG(h.Gh(e.n,!0));this.modulus=new o.Integer({valueHex:t.slice(0,Math.pow(2,h.J$(t.byteLength)))}),this.publicExponent=new o.Integer({valueHex:h.gG(h.Gh(e.e,!0)).slice(0,3)})}}am.CLASS_NAME="RSAPublicKey";let af="algorithm",ad="subjectPublicKey",ag=[af,ad];class ap extends y{constructor(e={}){super(),this.algorithm=h.H$(e,af,ap.defaultValues(af)),this.subjectPublicKey=h.H$(e,ad,ap.defaultValues(ad));let t=h.H$(e,"parsedKey",null);t&&(this.parsedKey=t),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}get parsedKey(){if(void 0===this._parsedKey){switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":if("algorithmParams"in this.algorithm&&this.algorithm.algorithmParams.constructor.blockName()===o.ObjectIdentifier.blockName())try{this._parsedKey=new al({namedCurve:this.algorithm.algorithmParams.valueBlock.toString(),schema:this.subjectPublicKey.valueBlock.valueHexView})}catch(e){}break;case"1.2.840.113549.1.1.1":{let e=o.fromBER(this.subjectPublicKey.valueBlock.valueHexView);if(-1!==e.offset)try{this._parsedKey=new am({schema:e.result})}catch(e){}}}this._parsedKey||(this._parsedKey=null)}return this._parsedKey||void 0}set parsedKey(e){this._parsedKey=e}static defaultValues(e){switch(e){case af:return new L;case ad:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[L.schema(t.algorithm||{}),new o.BitString({name:t.subjectPublicKey||""})]})}fromSchema(e){h.ze(e,ag);let t=o.compareSchema(e,e,ap.schema({names:{algorithm:{names:{blockName:af}},subjectPublicKey:ad}}));S.assertSchema(t,this.className),this.algorithm=new L({schema:t.result.algorithm}),this.subjectPublicKey=t.result.subjectPublicKey}toSchema(){return new o.Sequence({value:[this.algorithm.toSchema(),this.subjectPublicKey]})}toJSON(){if(!this.parsedKey)return{algorithm:this.algorithm.toJSON(),subjectPublicKey:this.subjectPublicKey.toJSON()};let e={};switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}let t=this.parsedKey.toJSON();return Object.assign(e,t),e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new al({json:e}),this.algorithm=new L({algorithmId:"1.2.840.10045.2.1",algorithmParams:new o.ObjectIdentifier({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new am({json:e}),this.algorithm=new L({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new o.Null});break;default:throw Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.subjectPublicKey=new o.BitString({valueHex:this.parsedKey.toSchema().toBER(!1)})}}async importKey(e,t=sc(!0)){try{if(!e)throw Error("Need to provide publicKey input parameter");let a=await t.exportKey("spki",e),s=o.fromBER(a);try{this.fromSchema(s.result)}catch(e){throw Error("Error during initializing object from schema")}}catch(t){let e=t instanceof Error?t.message:`${t}`;throw Error(`Error during exporting public key: ${e}`)}}}ap.CLASS_NAME="PublicKeyInfo";let aS="version",ay="privateKey",aw="namedCurve",av="publicKey",ab=[aS,ay,aw,av];class aA extends y{constructor(e={}){super(),this.version=h.H$(e,aS,aA.defaultValues(aS)),this.privateKey=h.H$(e,ay,aA.defaultValues(ay)),aw in e&&(this.namedCurve=h.H$(e,aw,aA.defaultValues(aw))),av in e&&(this.publicKey=h.H$(e,av,aA.defaultValues(av))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case aS:return 1;case ay:return new o.OctetString;case aw:return"";case av:return new al;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case aS:return t===aA.defaultValues(e);case ay:return t.isEqual(aA.defaultValues(e));case aw:return""===t;case av:return al.compareWithDefault(aw,t.namedCurve)&&al.compareWithDefault("x",t.x)&&al.compareWithDefault("y",t.y);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),new o.OctetString({name:t.privateKey||""}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.ObjectIdentifier({name:t.namedCurve||""})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.BitString({name:t.publicKey||""})]})]})}fromSchema(e){h.ze(e,ab);let t=o.compareSchema(e,e,aA.schema({names:{version:aS,privateKey:ay,namedCurve:aw,publicKey:av}}));if(S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.privateKey=t.result.privateKey,aw in t.result&&(this.namedCurve=t.result.namedCurve.valueBlock.toString()),av in t.result){let e={schema:t.result.publicKey.valueBlock.valueHex};aw in this&&(e.namedCurve=this.namedCurve),this.publicKey=new al(e)}}toSchema(){let e=[new o.Integer({value:this.version}),this.privateKey];return this.namedCurve&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.ObjectIdentifier({value:this.namedCurve})]})),this.publicKey&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new o.BitString({valueHex:this.publicKey.toSchema().toBER(!1)})]})),new o.Sequence({value:e})}toJSON(){if(!this.namedCurve||aA.compareWithDefault(aw,this.namedCurve))throw Error('Not enough information for making JSON: absent "namedCurve" value');let e=an.find(this.namedCurve),t={crv:e?e.name:this.namedCurve,d:c.ep.ToBase64Url(this.privateKey.valueBlock.valueHexView)};if(this.publicKey){let e=this.publicKey.toJSON();t.x=e.x,t.y=e.y}return t}fromJSON(e){p.assert("json",e,"crv","d");let t=0,a=an.find(e.crv);a&&(this.namedCurve=a.id,t=a.size);let s=c.ep.FromBase64Url(e.d);if(s.byteLength<t){let e=new ArrayBuffer(t),a=new Uint8Array(e),r=new Uint8Array(s);a.set(r,1),this.privateKey=new o.OctetString({valueHex:e})}else this.privateKey=new o.OctetString({valueHex:s.slice(0,t)});e.x&&e.y&&(this.publicKey=new al({json:e}))}}aA.CLASS_NAME="ECPrivateKey";let ak="prime",aC="exponent",aN="coefficient",aV=[ak,aC,aN];class aI extends y{constructor(e={}){super(),this.prime=h.H$(e,ak,aI.defaultValues(ak)),this.exponent=h.H$(e,aC,aI.defaultValues(aC)),this.coefficient=h.H$(e,aN,aI.defaultValues(aN)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ak:case aC:case aN:return new o.Integer;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.prime||""}),new o.Integer({name:t.exponent||""}),new o.Integer({name:t.coefficient||""})]})}fromSchema(e){h.ze(e,aV);let t=o.compareSchema(e,e,aI.schema({names:{prime:ak,exponent:aC,coefficient:aN}}));S.assertSchema(t,this.className),this.prime=t.result.prime.convertFromDER(),this.exponent=t.result.exponent.convertFromDER(),this.coefficient=t.result.coefficient.convertFromDER()}toSchema(){return new o.Sequence({value:[this.prime.convertToDER(),this.exponent.convertToDER(),this.coefficient.convertToDER()]})}toJSON(){return{r:c.ep.ToBase64Url(this.prime.valueBlock.valueHexView),d:c.ep.ToBase64Url(this.exponent.valueBlock.valueHexView),t:c.ep.ToBase64Url(this.coefficient.valueBlock.valueHexView)}}fromJSON(e){p.assert("json",e,"r","d","r"),this.prime=new o.Integer({valueHex:c.ep.FromBase64Url(e.r)}),this.exponent=new o.Integer({valueHex:c.ep.FromBase64Url(e.d)}),this.coefficient=new o.Integer({valueHex:c.ep.FromBase64Url(e.t)})}}aI.CLASS_NAME="OtherPrimeInfo";let aB="version",aE="modulus",aH="publicExponent",aD="privateExponent",aO="prime1",ax="prime2",aP="exponent1",a$="exponent2",aq="coefficient",aK="otherPrimeInfos",aR=[aB,aE,aH,aD,aO,ax,aP,a$,aq,aK];class aJ extends y{constructor(e={}){super(),this.version=h.H$(e,aB,aJ.defaultValues(aB)),this.modulus=h.H$(e,aE,aJ.defaultValues(aE)),this.publicExponent=h.H$(e,aH,aJ.defaultValues(aH)),this.privateExponent=h.H$(e,aD,aJ.defaultValues(aD)),this.prime1=h.H$(e,aO,aJ.defaultValues(aO)),this.prime2=h.H$(e,ax,aJ.defaultValues(ax)),this.exponent1=h.H$(e,aP,aJ.defaultValues(aP)),this.exponent2=h.H$(e,a$,aJ.defaultValues(a$)),this.coefficient=h.H$(e,aq,aJ.defaultValues(aq)),aK in e&&(this.otherPrimeInfos=h.H$(e,aK,aJ.defaultValues(aK))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case aB:return 0;case aE:case aH:case aD:case aO:case ax:case aP:case a$:case aq:return new o.Integer;case aK:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),new o.Integer({name:t.modulus||""}),new o.Integer({name:t.publicExponent||""}),new o.Integer({name:t.privateExponent||""}),new o.Integer({name:t.prime1||""}),new o.Integer({name:t.prime2||""}),new o.Integer({name:t.exponent1||""}),new o.Integer({name:t.exponent2||""}),new o.Integer({name:t.coefficient||""}),new o.Sequence({optional:!0,value:[new o.Repeated({name:t.otherPrimeInfosName||"",value:aI.schema(t.otherPrimeInfo||{})})]})]})}fromSchema(e){h.ze(e,aR);let t=o.compareSchema(e,e,aJ.schema({names:{version:aB,modulus:aE,publicExponent:aH,privateExponent:aD,prime1:aO,prime2:ax,exponent1:aP,exponent2:a$,coefficient:aq,otherPrimeInfo:{names:{blockName:aK}}}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent,this.privateExponent=t.result.privateExponent.convertFromDER(256),this.prime1=t.result.prime1.convertFromDER(128),this.prime2=t.result.prime2.convertFromDER(128),this.exponent1=t.result.exponent1.convertFromDER(128),this.exponent2=t.result.exponent2.convertFromDER(128),this.coefficient=t.result.coefficient.convertFromDER(128),aK in t.result&&(this.otherPrimeInfos=Array.from(t.result.otherPrimeInfos,e=>new aI({schema:e})))}toSchema(){let e=[];return e.push(new o.Integer({value:this.version})),e.push(this.modulus.convertToDER()),e.push(this.publicExponent),e.push(this.privateExponent.convertToDER()),e.push(this.prime1.convertToDER()),e.push(this.prime2.convertToDER()),e.push(this.exponent1.convertToDER()),e.push(this.exponent2.convertToDER()),e.push(this.coefficient.convertToDER()),this.otherPrimeInfos&&e.push(new o.Sequence({value:Array.from(this.otherPrimeInfos,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={n:c.ep.ToBase64Url(this.modulus.valueBlock.valueHexView),e:c.ep.ToBase64Url(this.publicExponent.valueBlock.valueHexView),d:c.ep.ToBase64Url(this.privateExponent.valueBlock.valueHexView),p:c.ep.ToBase64Url(this.prime1.valueBlock.valueHexView),q:c.ep.ToBase64Url(this.prime2.valueBlock.valueHexView),dp:c.ep.ToBase64Url(this.exponent1.valueBlock.valueHexView),dq:c.ep.ToBase64Url(this.exponent2.valueBlock.valueHexView),qi:c.ep.ToBase64Url(this.coefficient.valueBlock.valueHexView)};return this.otherPrimeInfos&&(e.oth=Array.from(this.otherPrimeInfos,e=>e.toJSON())),e}fromJSON(e){p.assert("json",e,"n","e","d","p","q","dp","dq","qi"),this.modulus=new o.Integer({valueHex:c.ep.FromBase64Url(e.n)}),this.publicExponent=new o.Integer({valueHex:c.ep.FromBase64Url(e.e)}),this.privateExponent=new o.Integer({valueHex:c.ep.FromBase64Url(e.d)}),this.prime1=new o.Integer({valueHex:c.ep.FromBase64Url(e.p)}),this.prime2=new o.Integer({valueHex:c.ep.FromBase64Url(e.q)}),this.exponent1=new o.Integer({valueHex:c.ep.FromBase64Url(e.dp)}),this.exponent2=new o.Integer({valueHex:c.ep.FromBase64Url(e.dq)}),this.coefficient=new o.Integer({valueHex:c.ep.FromBase64Url(e.qi)}),e.oth&&(this.otherPrimeInfos=Array.from(e.oth,e=>new aI({json:e})))}}aJ.CLASS_NAME="RSAPrivateKey";let aU="version",aT="privateKeyAlgorithm",aj="privateKey",aL="attributes",aM="parsedKey",a_=[aU,aT,aj,aL];class aW extends y{constructor(e={}){super(),this.version=h.H$(e,aU,aW.defaultValues(aU)),this.privateKeyAlgorithm=h.H$(e,aT,aW.defaultValues(aT)),this.privateKey=h.H$(e,aj,aW.defaultValues(aj)),aL in e&&(this.attributes=h.H$(e,aL,aW.defaultValues(aL))),aM in e&&(this.parsedKey=h.H$(e,aM,aW.defaultValues(aM))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case aU:return 0;case aT:return new L;case aj:return new o.OctetString;case aL:return[];case aM:return{};default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),L.schema(t.privateKeyAlgorithm||{}),new o.OctetString({name:t.privateKey||""}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Repeated({name:t.attributes||"",value:Q.schema()})]})]})}fromSchema(e){h.ze(e,a_);let t=o.compareSchema(e,e,aW.schema({names:{version:aU,privateKeyAlgorithm:{names:{blockName:aT}},privateKey:aj,attributes:aL}}));switch(S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.privateKeyAlgorithm=new L({schema:t.result.privateKeyAlgorithm}),this.privateKey=t.result.privateKey,aL in t.result&&(this.attributes=Array.from(t.result.attributes,e=>new Q({schema:e}))),this.privateKeyAlgorithm.algorithmId){case"1.2.840.113549.1.1.1":{let e=o.fromBER(this.privateKey.valueBlock.valueHexView);-1!==e.offset&&(this.parsedKey=new aJ({schema:e.result}))}break;case"1.2.840.10045.2.1":if("algorithmParams"in this.privateKeyAlgorithm&&this.privateKeyAlgorithm.algorithmParams instanceof o.ObjectIdentifier){let e=o.fromBER(this.privateKey.valueBlock.valueHexView);-1!==e.offset&&(this.parsedKey=new aA({namedCurve:this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),schema:e.result}))}}}toSchema(){let e=[new o.Integer({value:this.version}),this.privateKeyAlgorithm.toSchema(),this.privateKey];return this.attributes&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){if(!this.parsedKey){let e={version:this.version,privateKeyAlgorithm:this.privateKeyAlgorithm.toJSON(),privateKey:this.privateKey.toJSON()};return this.attributes&&(e.attributes=Array.from(this.attributes,e=>e.toJSON())),e}let e={};switch(this.privateKeyAlgorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}let t=this.parsedKey.toJSON();return Object.assign(e,t),e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new aA({json:e}),this.privateKeyAlgorithm=new L({algorithmId:"1.2.840.10045.2.1",algorithmParams:new o.ObjectIdentifier({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new aJ({json:e}),this.privateKeyAlgorithm=new L({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new o.Null});break;default:throw Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.privateKey=new o.OctetString({valueHex:this.parsedKey.toSchema().toBER(!1)})}}}aW.CLASS_NAME="PrivateKeyInfo";let az="contentType",aF="contentEncryptionAlgorithm",aG="encryptedContent",aQ=[az,aF,aG];class aX extends y{constructor(e={}){if(super(),this.contentType=h.H$(e,az,aX.defaultValues(az)),this.contentEncryptionAlgorithm=h.H$(e,aF,aX.defaultValues(aF)),aG in e&&e.encryptedContent&&(this.encryptedContent=e.encryptedContent,1===this.encryptedContent.idBlock.tagClass&&4===this.encryptedContent.idBlock.tagNumber&&!1===this.encryptedContent.idBlock.isConstructed&&!e.disableSplit)){let e=new o.OctetString({idBlock:{isConstructed:!0},isConstructed:!0}),t=0,a=this.encryptedContent.valueBlock.valueHexView.slice().buffer,s=a.byteLength;for(;s>0;){let r=new Uint8Array(a,t,t+1024>a.byteLength?a.byteLength-t:1024),i=new ArrayBuffer(r.length),n=new Uint8Array(i);for(let e=0;e<n.length;e++)n[e]=r[e];e.valueBlock.value.push(new o.OctetString({valueHex:i})),s-=r.length,t+=r.length}this.encryptedContent=e}e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case az:return"";case aF:return new L;case aG:return new o.OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case az:return""===t;case aF:return""===t.algorithmId&&"algorithmParams"in t==!1;case aG:return t.isEqual(aX.defaultValues(aG));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.contentType||""}),L.schema(t.contentEncryptionAlgorithm||{}),new o.Choice({value:[new o.Constructed({name:t.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0},value:[new o.Repeated({value:new o.OctetString})]}),new o.Primitive({name:t.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0}})]})]})}fromSchema(e){h.ze(e,aQ);let t=o.compareSchema(e,e,aX.schema({names:{contentType:az,contentEncryptionAlgorithm:{names:{blockName:aF}},encryptedContent:aG}}));S.assertSchema(t,this.className),this.contentType=t.result.contentType.valueBlock.toString(),this.contentEncryptionAlgorithm=new L({schema:t.result.contentEncryptionAlgorithm}),aG in t.result&&(this.encryptedContent=t.result.encryptedContent,this.encryptedContent.idBlock.tagClass=1,this.encryptedContent.idBlock.tagNumber=4)}toSchema(){let e={isIndefiniteForm:!1},t=[];if(t.push(new o.ObjectIdentifier({value:this.contentType})),t.push(this.contentEncryptionAlgorithm.toSchema()),this.encryptedContent){e.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed;let a=this.encryptedContent;a.idBlock.tagClass=3,a.idBlock.tagNumber=0,a.lenBlock.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed,t.push(a)}return new o.Sequence({lenBlock:e,value:t})}toJSON(){let e={contentType:this.contentType,contentEncryptionAlgorithm:this.contentEncryptionAlgorithm.toJSON()};return this.encryptedContent&&(e.encryptedContent=this.encryptedContent.toJSON()),e}getEncryptedContent(){if(!this.encryptedContent)throw Error("Parameter 'encryptedContent' is undefined");return o.OctetString.prototype.getValue.call(this.encryptedContent)}}aX.CLASS_NAME="EncryptedContentInfo";let aY="hashAlgorithm",aZ="maskGenAlgorithm",a1="saltLength",a0="trailerField",a2=[aY,aZ,a1,a0];class a3 extends y{constructor(e={}){super(),this.hashAlgorithm=h.H$(e,aY,a3.defaultValues(aY)),this.maskGenAlgorithm=h.H$(e,aZ,a3.defaultValues(aZ)),this.saltLength=h.H$(e,a1,a3.defaultValues(a1)),this.trailerField=h.H$(e,a0,a3.defaultValues(a0)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case aY:return new L({algorithmId:"1.3.14.3.2.26",algorithmParams:new o.Null});case aZ:return new L({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new L({algorithmId:"1.3.14.3.2.26",algorithmParams:new o.Null}).toSchema()});case a1:return 20;case a0:return 1;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Constructed({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[L.schema(t.hashAlgorithm||{})]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[L.schema(t.maskGenAlgorithm||{})]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[new o.Integer({name:t.saltLength||""})]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:3},optional:!0,value:[new o.Integer({name:t.trailerField||""})]})]})}fromSchema(e){h.ze(e,a2);let t=o.compareSchema(e,e,a3.schema({names:{hashAlgorithm:{names:{blockName:aY}},maskGenAlgorithm:{names:{blockName:aZ}},saltLength:a1,trailerField:a0}}));S.assertSchema(t,this.className),aY in t.result&&(this.hashAlgorithm=new L({schema:t.result.hashAlgorithm})),aZ in t.result&&(this.maskGenAlgorithm=new L({schema:t.result.maskGenAlgorithm})),a1 in t.result&&(this.saltLength=t.result.saltLength.valueBlock.valueDec),a0 in t.result&&(this.trailerField=t.result.trailerField.valueBlock.valueDec)}toSchema(){let e=[];return this.hashAlgorithm.isEqual(a3.defaultValues(aY))||e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(a3.defaultValues(aZ))||e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.saltLength!==a3.defaultValues(a1)&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:[new o.Integer({value:this.saltLength})]})),this.trailerField!==a3.defaultValues(a0)&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:3},value:[new o.Integer({value:this.trailerField})]})),new o.Sequence({value:e})}toJSON(){let e={};return this.hashAlgorithm.isEqual(a3.defaultValues(aY))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(a3.defaultValues(aZ))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.saltLength!==a3.defaultValues(a1)&&(e.saltLength=this.saltLength),this.trailerField!==a3.defaultValues(a0)&&(e.trailerField=this.trailerField),e}}a3.CLASS_NAME="RSASSAPSSParams";let a4="salt",a8="iterationCount",a5="keyLength",a6=[a4,a8,a5,"prf"];class a9 extends y{constructor(e={}){super(),this.salt=h.H$(e,a4,a9.defaultValues(a4)),this.iterationCount=h.H$(e,a8,a9.defaultValues(a8)),a5 in e&&(this.keyLength=h.H$(e,a5,a9.defaultValues(a5))),"prf"in e&&(this.prf=h.H$(e,"prf",a9.defaultValues("prf"))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case a4:return{};case a8:return -1;case a5:return 0;case"prf":return new L({algorithmId:"1.3.14.3.2.26",algorithmParams:new o.Null});default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Choice({value:[new o.OctetString({name:t.saltPrimitive||""}),L.schema(t.saltConstructed||{})]}),new o.Integer({name:t.iterationCount||""}),new o.Integer({name:t.keyLength||"",optional:!0}),L.schema(t.prf||{names:{optional:!0}})]})}fromSchema(e){h.ze(e,a6);let t=o.compareSchema(e,e,a9.schema({names:{saltPrimitive:a4,saltConstructed:{names:{blockName:a4}},iterationCount:a8,keyLength:a5,prf:{names:{blockName:"prf",optional:!0}}}}));S.assertSchema(t,this.className),this.salt=t.result.salt,this.iterationCount=t.result.iterationCount.valueBlock.valueDec,a5 in t.result&&(this.keyLength=t.result.keyLength.valueBlock.valueDec),"prf"in t.result&&(this.prf=new L({schema:t.result.prf}))}toSchema(){let e=[];return e.push(this.salt),e.push(new o.Integer({value:this.iterationCount})),a5 in this&&a9.defaultValues(a5)!==this.keyLength&&e.push(new o.Integer({value:this.keyLength})),this.prf&&!1===a9.defaultValues("prf").isEqual(this.prf)&&e.push(this.prf.toSchema()),new o.Sequence({value:e})}toJSON(){let e={salt:this.salt.toJSON(),iterationCount:this.iterationCount};return a5 in this&&a9.defaultValues(a5)!==this.keyLength&&(e.keyLength=this.keyLength),this.prf&&!1===a9.defaultValues("prf").isEqual(this.prf)&&(e.prf=this.prf.toJSON()),e}}a9.CLASS_NAME="PBKDF2Params";let a7="keyDerivationFunc",se="encryptionScheme",st=[a7,se];class sa extends y{constructor(e={}){super(),this.keyDerivationFunc=h.H$(e,a7,sa.defaultValues(a7)),this.encryptionScheme=h.H$(e,se,sa.defaultValues(se)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case a7:case se:return new L;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[L.schema(t.keyDerivationFunc||{}),L.schema(t.encryptionScheme||{})]})}fromSchema(e){h.ze(e,st);let t=o.compareSchema(e,e,sa.schema({names:{keyDerivationFunc:{names:{blockName:a7}},encryptionScheme:{names:{blockName:se}}}}));S.assertSchema(t,this.className),this.keyDerivationFunc=new L({schema:t.result.keyDerivationFunc}),this.encryptionScheme=new L({schema:t.result.encryptionScheme})}toSchema(){return new o.Sequence({value:[this.keyDerivationFunc.toSchema(),this.encryptionScheme.toSchema()]})}toJSON(){return{keyDerivationFunc:this.keyDerivationFunc.toJSON(),encryptionScheme:this.encryptionScheme.toJSON()}}}sa.CLASS_NAME="PBES2Params";class ss{constructor(e){this.crypto=e.crypto,this.subtle="webkitSubtle"in e.crypto?e.crypto.webkitSubtle:e.crypto.subtle,this.name=h.H$(e,"name","")}async encrypt(...e){return this.subtle.encrypt(...e)}async decrypt(...e){return this.subtle.decrypt(...e)}sign(...e){return this.subtle.sign(...e)}async verify(...e){return this.subtle.verify(...e)}async digest(...e){return this.subtle.digest(...e)}async generateKey(...e){return this.subtle.generateKey(...e)}async deriveKey(...e){return this.subtle.deriveKey(...e)}async deriveBits(...e){return this.subtle.deriveBits(...e)}async wrapKey(...e){return this.subtle.wrapKey(...e)}async unwrapKey(...e){return this.subtle.unwrapKey(...e)}exportKey(...e){return this.subtle.exportKey(...e)}importKey(...e){return this.subtle.importKey(...e)}getRandomValues(e){return this.crypto.getRandomValues(e)}}async function sr(e,t,a,s,r,i){let n,u;let l=[];switch(t.toUpperCase()){case"SHA-1":n=20,u=64;break;case"SHA-256":n=32,u=64;break;case"SHA-384":n=48,u=128;break;case"SHA-512":n=64,u=128;break;default:throw Error("Unsupported hashing algorithm")}let o=new Uint8Array(s),c=new ArrayBuffer(2*s.byteLength+2),h=new Uint8Array(c);for(let e=0;e<o.length;e++)h[2*e]=0,h[2*e+1]=o[e];h[h.length-2]=0,h[h.length-1]=0,s=c.slice(0);let m=new ArrayBuffer(u),f=new Uint8Array(m);for(let e=0;e<m.byteLength;e++)f[e]=3;let d=r.byteLength,g=u*Math.ceil(d/u),p=new ArrayBuffer(g),S=new Uint8Array(p),y=new Uint8Array(r);for(let e=0;e<g;e++)S[e]=y[e%d];let w=s.byteLength,v=u*Math.ceil(w/u),b=new ArrayBuffer(v),A=new Uint8Array(b),k=new Uint8Array(s);for(let e=0;e<v;e++)A[e]=k[e%w];let C=p.byteLength+b.byteLength,N=new ArrayBuffer(C),V=new Uint8Array(N);V.set(S),V.set(A,S.length);let I=Math.ceil((a>>3)/n),B=Promise.resolve(N);for(let a=0;a<=I;a++){B=B.then(e=>{let t=new ArrayBuffer(m.byteLength+e.byteLength),a=new Uint8Array(t);return a.set(f),a.set(V,f.length),t});for(let a=0;a<i;a++)B=B.then(a=>e.digest({name:t},new Uint8Array(a)));B=B.then(e=>{let t=new ArrayBuffer(u),a=new Uint8Array(t);for(let s=0;s<t.byteLength;s++)a[s]=e[s%e.byteLength];let s=Math.ceil(d/u)+Math.ceil(w/u),r=[],i=0,n=u;for(let e=0;e<s;e++){let e=Array.from(new Uint8Array(N.slice(i,i+n)));(i+=u)+u>N.byteLength&&(n=N.byteLength-i);let s=511;for(let r=t.byteLength-1;r>=0;r--)s>>=8,s+=a[r]+e[r],e[r]=255&s;r.push(...e)}return N=new ArrayBuffer(r.length),(V=new Uint8Array(N)).set(r),l.push(...new Uint8Array(e)),N})}return B.then(()=>{let e=new ArrayBuffer(a>>3),t=new Uint8Array(e);return t.set(new Uint8Array(l).slice(0,a>>3)),e})}class si extends ss{async importKey(e,t,a,s,r){var i,n,u,l,m,f;let d={},y=function e(t){let a="string"==typeof t?{name:t}:t;return"hash"in a?{...a,hash:e(a.hash)}:a}(a);switch(e.toLowerCase()){case"raw":return this.subtle.importKey("raw",t,a,s,r);case"spki":{let e=o.fromBER(c.vJ.toArrayBuffer(t));S.assert(e,"keyData");let a=new ap;try{a.fromSchema(e.result)}catch{throw new g("Incorrect keyData")}switch(y.name.toUpperCase()){case"RSA-PSS":if(!y.hash)throw new p("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(y.hash.name.toUpperCase()){case"SHA-1":d.alg="PS1";break;case"SHA-256":d.alg="PS256";break;case"SHA-384":d.alg="PS384";break;case"SHA-512":d.alg="PS512";break;default:throw Error(`Incorrect hash algorithm: ${y.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(r=["verify"],d.kty="RSA",d.ext=s,d.key_ops=r,"1.2.840.113549.1.1.1"!==a.algorithm.algorithmId)throw Error(`Incorrect public key algorithm: ${a.algorithm.algorithmId}`);if(!d.alg){if(!y.hash)throw new p("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(y.hash.name.toUpperCase()){case"SHA-1":d.alg="RS1";break;case"SHA-256":d.alg="RS256";break;case"SHA-384":d.alg="RS384";break;case"SHA-512":d.alg="RS512";break;default:throw Error(`Incorrect hash algorithm: ${y.hash.name.toUpperCase()}`)}}let e=a.toJSON();Object.assign(d,e)}break;case"ECDSA":r=["verify"];case"ECDH":{if(d={kty:"EC",ext:s,key_ops:r},"1.2.840.10045.2.1"!==a.algorithm.algorithmId)throw Error(`Incorrect public key algorithm: ${a.algorithm.algorithmId}`);let e=a.toJSON();Object.assign(d,e)}break;case"RSA-OAEP":{if(d.kty="RSA",d.ext=s,d.key_ops=r,"safari"===this.name.toLowerCase())d.alg="RSA-OAEP";else{if(!y.hash)throw new p("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(y.hash.name.toUpperCase()){case"SHA-1":d.alg="RSA-OAEP";break;case"SHA-256":d.alg="RSA-OAEP-256";break;case"SHA-384":d.alg="RSA-OAEP-384";break;case"SHA-512":d.alg="RSA-OAEP-512";break;default:throw Error(`Incorrect hash algorithm: ${y.hash.name.toUpperCase()}`)}}let e=a.toJSON();Object.assign(d,e)}break;case"RSAES-PKCS1-V1_5":{d.kty="RSA",d.ext=s,d.key_ops=r,d.alg="PS1";let e=a.toJSON();Object.assign(d,e)}break;default:throw Error(`Incorrect algorithm name: ${y.name.toUpperCase()}`)}}break;case"pkcs8":{let e=new aW,a=o.fromBER(c.vJ.toArrayBuffer(t));S.assert(a,"keyData");try{e.fromSchema(a.result)}catch(e){throw Error("Incorrect keyData")}if(!e.parsedKey)throw Error("Incorrect keyData");switch(y.name.toUpperCase()){case"RSA-PSS":switch(null===(i=y.hash)||void 0===i?void 0:i.name.toUpperCase()){case"SHA-1":d.alg="PS1";break;case"SHA-256":d.alg="PS256";break;case"SHA-384":d.alg="PS384";break;case"SHA-512":d.alg="PS512";break;default:throw Error(`Incorrect hash algorithm: ${null===(n=y.hash)||void 0===n?void 0:n.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(r=["sign"],d.kty="RSA",d.ext=s,d.key_ops=r,"1.2.840.113549.1.1.1"!==e.privateKeyAlgorithm.algorithmId)throw Error(`Incorrect private key algorithm: ${e.privateKeyAlgorithm.algorithmId}`);if("alg"in d==!1)switch(null===(u=y.hash)||void 0===u?void 0:u.name.toUpperCase()){case"SHA-1":d.alg="RS1";break;case"SHA-256":d.alg="RS256";break;case"SHA-384":d.alg="RS384";break;case"SHA-512":d.alg="RS512";break;default:throw Error(`Incorrect hash algorithm: ${null===(l=y.hash)||void 0===l?void 0:l.name.toUpperCase()}`)}let t=e.toJSON();Object.assign(d,t)}break;case"ECDSA":r=["sign"];case"ECDH":{if(d={kty:"EC",ext:s,key_ops:r},"1.2.840.10045.2.1"!==e.privateKeyAlgorithm.algorithmId)throw Error(`Incorrect algorithm: ${e.privateKeyAlgorithm.algorithmId}`);let t=e.toJSON();Object.assign(d,t)}break;case"RSA-OAEP":{if(d.kty="RSA",d.ext=s,d.key_ops=r,"safari"===this.name.toLowerCase())d.alg="RSA-OAEP";else switch(null===(m=y.hash)||void 0===m?void 0:m.name.toUpperCase()){case"SHA-1":d.alg="RSA-OAEP";break;case"SHA-256":d.alg="RSA-OAEP-256";break;case"SHA-384":d.alg="RSA-OAEP-384";break;case"SHA-512":d.alg="RSA-OAEP-512";break;default:throw Error(`Incorrect hash algorithm: ${null===(f=y.hash)||void 0===f?void 0:f.name.toUpperCase()}`)}let t=e.toJSON();Object.assign(d,t)}break;case"RSAES-PKCS1-V1_5":{r=["decrypt"],d.kty="RSA",d.ext=s,d.key_ops=r,d.alg="PS1";let t=e.toJSON();Object.assign(d,t)}break;default:throw Error(`Incorrect algorithm name: ${y.name.toUpperCase()}`)}}break;case"jwk":d=t;break;default:throw Error(`Incorrect format: ${e}`)}if("safari"===this.name.toLowerCase())try{return this.subtle.importKey("jwk",h.gG(JSON.stringify(d)),a,s,r)}catch{}return this.subtle.importKey("jwk",d,a,s,r)}async exportKey(e,t){let a=await this.subtle.exportKey("jwk",t);switch("safari"===this.name.toLowerCase()&&a instanceof ArrayBuffer&&(a=JSON.parse(h.lE(a))),e.toLowerCase()){case"raw":return this.subtle.exportKey("raw",t);case"spki":{let e=new ap;try{e.fromJSON(a)}catch(e){throw Error("Incorrect key data")}return e.toSchema().toBER(!1)}case"pkcs8":{let e=new aW;try{e.fromJSON(a)}catch(e){throw Error("Incorrect key data")}return e.toSchema().toBER(!1)}case"jwk":return a;default:throw Error(`Incorrect format: ${e}`)}}async convert(e,t,a,s,r,i){if(e.toLowerCase()===t.toLowerCase())return a;let n=await this.importKey(e,a,s,r,i);return this.exportKey(t,n)}getAlgorithmByOID(e,t=!1,a){switch(e){case"1.2.840.113549.1.1.1":return{name:"RSAES-PKCS1-v1_5"};case"1.2.840.113549.1.1.5":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case"1.2.840.113549.1.1.11":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"1.2.840.113549.1.1.12":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case"1.2.840.113549.1.1.13":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};case"1.2.840.113549.1.1.7":return{name:"RSA-OAEP"};case"1.2.840.10045.2.1":case"1.2.840.10045.4.1":return{name:"ECDSA",hash:{name:"SHA-1"}};case"1.2.840.10045.4.3.2":return{name:"ECDSA",hash:{name:"SHA-256"}};case"1.2.840.10045.4.3.3":return{name:"ECDSA",hash:{name:"SHA-384"}};case"1.2.840.10045.4.3.4":return{name:"ECDSA",hash:{name:"SHA-512"}};case"1.3.133.16.840.63.0.2":return{name:"ECDH",kdf:"SHA-1"};case"1.3.132.1.11.1":return{name:"ECDH",kdf:"SHA-256"};case"1.3.132.1.11.2":return{name:"ECDH",kdf:"SHA-384"};case"1.3.132.1.11.3":return{name:"ECDH",kdf:"SHA-512"};case"2.16.840.1.101.3.4.1.2":return{name:"AES-CBC",length:128};case"2.16.840.1.101.3.4.1.22":return{name:"AES-CBC",length:192};case"2.16.840.1.101.3.4.1.42":return{name:"AES-CBC",length:256};case"2.16.840.1.101.3.4.1.6":return{name:"AES-GCM",length:128};case"2.16.840.1.101.3.4.1.26":return{name:"AES-GCM",length:192};case"2.16.840.1.101.3.4.1.46":return{name:"AES-GCM",length:256};case"2.16.840.1.101.3.4.1.4":return{name:"AES-CFB",length:128};case"2.16.840.1.101.3.4.1.24":return{name:"AES-CFB",length:192};case"2.16.840.1.101.3.4.1.44":return{name:"AES-CFB",length:256};case"2.16.840.1.101.3.4.1.5":return{name:"AES-KW",length:128};case"2.16.840.1.101.3.4.1.25":return{name:"AES-KW",length:192};case"2.16.840.1.101.3.4.1.45":return{name:"AES-KW",length:256};case"1.2.840.113549.2.7":return{name:"HMAC",hash:{name:"SHA-1"}};case"1.2.840.113549.2.9":return{name:"HMAC",hash:{name:"SHA-256"}};case"1.2.840.113549.2.10":return{name:"HMAC",hash:{name:"SHA-384"}};case"1.2.840.113549.2.11":return{name:"HMAC",hash:{name:"SHA-512"}};case"1.2.840.113549.1.9.16.3.5":return{name:"DH"};case"1.3.14.3.2.26":return{name:"SHA-1"};case"2.16.840.1.101.3.4.2.1":return{name:"SHA-256"};case"2.16.840.1.101.3.4.2.2":return{name:"SHA-384"};case"2.16.840.1.101.3.4.2.3":return{name:"SHA-512"};case"1.2.840.113549.1.5.12":return{name:"PBKDF2"};case"1.2.840.10045.3.1.7":return{name:"P-256"};case"1.3.132.0.34":return{name:"P-384"};case"1.3.132.0.35":return{name:"P-521"}}if(t)throw Error(`Unsupported algorithm identifier ${a?`for ${a} `:""}: ${e}`);return{}}getOIDByAlgorithm(e,t=!1,a){let s="";switch(e.name.toUpperCase()){case"RSAES-PKCS1-V1_5":s="1.2.840.113549.1.1.1";break;case"RSASSA-PKCS1-V1_5":switch(e.hash.name.toUpperCase()){case"SHA-1":s="1.2.840.113549.1.1.5";break;case"SHA-256":s="1.2.840.113549.1.1.11";break;case"SHA-384":s="1.2.840.113549.1.1.12";break;case"SHA-512":s="1.2.840.113549.1.1.13"}break;case"RSA-PSS":s="1.2.840.113549.1.1.10";break;case"RSA-OAEP":s="1.2.840.113549.1.1.7";break;case"ECDSA":switch(e.hash.name.toUpperCase()){case"SHA-1":s="1.2.840.10045.4.1";break;case"SHA-256":s="1.2.840.10045.4.3.2";break;case"SHA-384":s="1.2.840.10045.4.3.3";break;case"SHA-512":s="1.2.840.10045.4.3.4"}break;case"ECDH":switch(e.kdf.toUpperCase()){case"SHA-1":s="1.3.133.16.840.63.0.2";break;case"SHA-256":s="1.3.132.1.11.1";break;case"SHA-384":s="1.3.132.1.11.2";break;case"SHA-512":s="1.3.132.1.11.3"}break;case"AES-CTR":case"AES-CMAC":case"CONCAT":case"HKDF":break;case"AES-CBC":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.2";break;case 192:s="2.16.840.1.101.3.4.1.22";break;case 256:s="2.16.840.1.101.3.4.1.42"}break;case"AES-GCM":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.6";break;case 192:s="2.16.840.1.101.3.4.1.26";break;case 256:s="2.16.840.1.101.3.4.1.46"}break;case"AES-CFB":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.4";break;case 192:s="2.16.840.1.101.3.4.1.24";break;case 256:s="2.16.840.1.101.3.4.1.44"}break;case"AES-KW":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.5";break;case 192:s="2.16.840.1.101.3.4.1.25";break;case 256:s="2.16.840.1.101.3.4.1.45"}break;case"HMAC":switch(e.hash.name.toUpperCase()){case"SHA-1":s="1.2.840.113549.2.7";break;case"SHA-256":s="1.2.840.113549.2.9";break;case"SHA-384":s="1.2.840.113549.2.10";break;case"SHA-512":s="1.2.840.113549.2.11"}break;case"DH":s="1.2.840.113549.1.9.16.3.5";break;case"SHA-1":s="1.3.14.3.2.26";break;case"SHA-256":s="2.16.840.1.101.3.4.2.1";break;case"SHA-384":s="2.16.840.1.101.3.4.2.2";break;case"SHA-512":s="2.16.840.1.101.3.4.2.3";break;case"PBKDF2":s="1.2.840.113549.1.5.12";break;case"P-256":s="1.2.840.10045.3.1.7";break;case"P-384":s="1.3.132.0.34";break;case"P-521":s="1.3.132.0.35"}if(!s&&t)throw Error(`Unsupported algorithm ${a?`for ${a} `:""}: ${e.name}`);return s}getAlgorithmParameters(e,t){let a={algorithm:{},usages:[]};switch(e.toUpperCase()){case"RSAES-PKCS1-V1_5":case"RSASSA-PKCS1-V1_5":switch(t.toLowerCase()){case"generatekey":a={algorithm:{name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["sign","verify"]};break;case"verify":case"sign":case"importkey":a={algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usages:["verify"]};break;default:return{algorithm:{name:"RSASSA-PKCS1-v1_5"},usages:[]}}break;case"RSA-PSS":switch(t.toLowerCase()){case"sign":case"verify":a={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"},saltLength:20},usages:["sign","verify"]};break;case"generatekey":a={algorithm:{name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},usages:["sign","verify"]};break;case"importkey":a={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"}},usages:["verify"]};break;default:return{algorithm:{name:"RSA-PSS"},usages:[]}}break;case"RSA-OAEP":switch(t.toLowerCase()){case"encrypt":case"decrypt":a={algorithm:{name:"RSA-OAEP"},usages:["encrypt","decrypt"]};break;case"generatekey":a={algorithm:{name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"importkey":a={algorithm:{name:"RSA-OAEP",hash:{name:"SHA-256"}},usages:["encrypt"]};break;default:return{algorithm:{name:"RSA-OAEP"},usages:[]}}break;case"ECDSA":switch(t.toLowerCase()){case"generatekey":a={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["sign","verify"]};break;case"importkey":a={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["verify"]};break;case"verify":case"sign":a={algorithm:{name:"ECDSA",hash:{name:"SHA-256"}},usages:["sign"]};break;default:return{algorithm:{name:"ECDSA"},usages:[]}}break;case"ECDH":switch(t.toLowerCase()){case"exportkey":case"importkey":case"generatekey":a={algorithm:{name:"ECDH",namedCurve:"P-256"},usages:["deriveKey","deriveBits"]};break;case"derivekey":case"derivebits":a={algorithm:{name:"ECDH",namedCurve:"P-256",public:[]},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"ECDH"},usages:[]}}break;case"AES-CTR":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":a={algorithm:{name:"AES-CTR",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":a={algorithm:{name:"AES-CTR",counter:new Uint8Array(16),length:10},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CTR"},usages:[]}}break;case"AES-CBC":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":a={algorithm:{name:"AES-CBC",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":a={algorithm:{name:"AES-CBC",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CBC"},usages:[]}}break;case"AES-GCM":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":a={algorithm:{name:"AES-GCM",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":a={algorithm:{name:"AES-GCM",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-GCM"},usages:[]}}break;case"AES-KW":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":case"wrapkey":case"unwrapkey":a={algorithm:{name:"AES-KW",length:256},usages:["wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-KW"},usages:[]}}break;case"HMAC":switch(t.toLowerCase()){case"sign":case"verify":a={algorithm:{name:"HMAC"},usages:["sign","verify"]};break;case"importkey":case"exportkey":case"generatekey":a={algorithm:{name:"HMAC",length:32,hash:{name:"SHA-256"}},usages:["sign","verify"]};break;default:return{algorithm:{name:"HMAC"},usages:[]}}break;case"HKDF":if("derivekey"!==t.toLowerCase())return{algorithm:{name:"HKDF"},usages:[]};a={algorithm:{name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},usages:["encrypt","decrypt"]};break;case"PBKDF2":if("derivekey"!==t.toLowerCase())return{algorithm:{name:"PBKDF2"},usages:[]};a={algorithm:{name:"PBKDF2",hash:{name:"SHA-256"},salt:new Uint8Array([]),iterations:1e4},usages:["encrypt","decrypt"]}}return a}getHashAlgorithm(e){let t="";switch(e.algorithmId){case"1.2.840.10045.4.1":case"1.2.840.113549.1.1.5":t="SHA-1";break;case"1.2.840.10045.4.3.2":case"1.2.840.113549.1.1.11":t="SHA-256";break;case"1.2.840.10045.4.3.3":case"1.2.840.113549.1.1.12":t="SHA-384";break;case"1.2.840.10045.4.3.4":case"1.2.840.113549.1.1.13":t="SHA-512";break;case"1.2.840.113549.1.1.10":try{let a=new a3({schema:e.algorithmParams});if(a.hashAlgorithm){let e=this.getAlgorithmByOID(a.hashAlgorithm.algorithmId);if(!("name"in e))return"";t=e.name}else t="SHA-1"}catch{}}return t}async encryptEncryptedContentInfo(e){p.assert(e,"password","contentEncryptionAlgorithm","hmacHashAlgorithm","iterationCount","contentToEncrypt","contentToEncrypt","contentType");let t=this.getOIDByAlgorithm(e.contentEncryptionAlgorithm,!0,"contentEncryptionAlgorithm"),a=this.getOIDByAlgorithm({name:"PBKDF2"},!0,"PBKDF2"),s=this.getOIDByAlgorithm({name:"HMAC",hash:{name:e.hmacHashAlgorithm}},!0,"hmacHashAlgorithm"),r=new ArrayBuffer(16),i=new Uint8Array(r);this.getRandomValues(i);let n=new ArrayBuffer(64),u=new Uint8Array(n);this.getRandomValues(u);let l=new Uint8Array(e.contentToEncrypt),c=new a9({salt:new o.OctetString({valueHex:n}),iterationCount:e.iterationCount,prf:new L({algorithmId:s,algorithmParams:new o.Null})}),h=new Uint8Array(e.password),m=await this.importKey("raw",h,"PBKDF2",!1,["deriveKey"]),f=await this.deriveKey({name:"PBKDF2",hash:{name:e.hmacHashAlgorithm},salt:u,iterations:e.iterationCount},m,e.contentEncryptionAlgorithm,!1,["encrypt"]),d=await this.encrypt({name:e.contentEncryptionAlgorithm.name,iv:i},f,l),g=new sa({keyDerivationFunc:new L({algorithmId:a,algorithmParams:c.toSchema()}),encryptionScheme:new L({algorithmId:t,algorithmParams:new o.OctetString({valueHex:r})})});return new aX({contentType:e.contentType,contentEncryptionAlgorithm:new L({algorithmId:"1.2.840.113549.1.5.13",algorithmParams:g.toSchema()}),encryptedContent:new o.OctetString({valueHex:d})})}async decryptEncryptedContentInfo(e){let t,a;if(p.assert(e,"password","encryptedContentInfo"),"1.2.840.113549.1.5.13"!==e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)throw Error(`Unknown "contentEncryptionAlgorithm": ${e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);try{t=new sa({schema:e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams})}catch(e){throw Error('Incorrectly encoded "pbes2Parameters"')}try{a=new a9({schema:t.keyDerivationFunc.algorithmParams})}catch(e){throw Error('Incorrectly encoded "pbkdf2Params"')}let s=this.getAlgorithmByOID(t.encryptionScheme.algorithmId,!0),r=t.encryptionScheme.algorithmParams.valueBlock.valueHex,i=new Uint8Array(r),n=a.salt.valueBlock.valueHex,u=new Uint8Array(n),l=a.iterationCount,o="SHA-1";if(a.prf){let e=this.getAlgorithmByOID(a.prf.algorithmId,!0);o=e.hash.name}let c=await this.importKey("raw",e.password,"PBKDF2",!1,["deriveKey"]),h=await this.deriveKey({name:"PBKDF2",hash:{name:o},salt:u,iterations:l},c,s,!1,["decrypt"]),m=e.encryptedContentInfo.getEncryptedContent();return this.decrypt({name:s.name,iv:i},h,m)}async stampDataWithPassword(e){let t;if(e instanceof Object==!1)throw Error('Parameters must have type "Object"');switch(p.assert(e,"password","hashAlgorithm","iterationCount","salt","contentToStamp"),e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:throw Error(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}let a={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}},s=await sr(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount),r=await this.importKey("raw",new Uint8Array(s),a,!1,["sign"]);return this.sign(a,r,new Uint8Array(e.contentToStamp))}async verifyDataStampedWithPassword(e){p.assert(e,"password","hashAlgorithm","salt","iterationCount","contentToVerify","signatureToVerify");let t=0;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:throw Error(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}let a={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}},s=await sr(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount),r=await this.importKey("raw",new Uint8Array(s),a,!1,["verify"]);return this.verify(a,r,new Uint8Array(e.signatureToVerify),new Uint8Array(e.contentToVerify))}async getSignatureParameters(e,t="SHA-1"){this.getOIDByAlgorithm({name:t},!0,"hashAlgorithm");let a=new L,s=this.getAlgorithmParameters(e.algorithm.name,"sign");if(!Object.keys(s.algorithm).length)throw Error("Parameter 'algorithm' is empty");let r=s.algorithm;switch(r.hash.name=t,e.algorithm.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":case"ECDSA":a.algorithmId=this.getOIDByAlgorithm(r,!0);break;case"RSA-PSS":{switch(t.toUpperCase()){case"SHA-256":r.saltLength=32;break;case"SHA-384":r.saltLength=48;break;case"SHA-512":r.saltLength=64}let e={};if("SHA-1"!==t.toUpperCase()){let a=this.getOIDByAlgorithm({name:t},!0,"hashAlgorithm");e.hashAlgorithm=new L({algorithmId:a,algorithmParams:new o.Null}),e.maskGenAlgorithm=new L({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:e.hashAlgorithm.toSchema()})}20!==r.saltLength&&(e.saltLength=r.saltLength);let s=new a3(e);a.algorithmId="1.2.840.113549.1.1.10",a.algorithmParams=s.toSchema()}break;default:throw Error(`Unsupported signature algorithm: ${e.algorithm.name}`)}return{signatureAlgorithm:a,parameters:s}}async signWithPrivateKey(e,t,a){let s=await this.sign(a.algorithm,t,e);return"ECDSA"===a.algorithm.name?sd(s):s}fillPublicKeyParameters(e,t){let a;let s={},r=this.getHashAlgorithm(t);if(""===r)throw Error(`Unsupported signature algorithm: ${t.algorithmId}`);a="1.2.840.113549.1.1.10"===t.algorithmId?t.algorithmId:e.algorithm.algorithmId;let i=this.getAlgorithmByOID(a,!0);if(s.algorithm=this.getAlgorithmParameters(i.name,"importKey"),"hash"in s.algorithm.algorithm&&(s.algorithm.algorithm.hash.name=r),"ECDSA"===i.name){let t=e.algorithm;if(!t.algorithmParams)throw Error("Algorithm parameters for ECDSA public key are missed");let a=t.algorithmParams;if("idBlock"in t.algorithmParams&&!(1===a.idBlock.tagClass&&6===a.idBlock.tagNumber))throw Error("Incorrect type for ECDSA public key parameters");let r=this.getAlgorithmByOID(a.valueBlock.toString(),!0);s.algorithm.algorithm.namedCurve=r.name}return s}async getPublicKey(e,t,a){a||(a=this.fillPublicKeyParameters(e,t));let s=e.toSchema().toBER(!1);return this.importKey("spki",s,a.algorithm.algorithm,!0,a.algorithm.usages)}async verifyWithPublicKey(e,t,a,s,r){let i;if(r){let e;let t={};e="1.2.840.113549.1.1.10"===s.algorithmId?s.algorithmId:a.algorithm.algorithmId;let n=this.getAlgorithmByOID(e,!0);if(t.algorithm=this.getAlgorithmParameters(n.name,"importKey"),"hash"in t.algorithm.algorithm&&(t.algorithm.algorithm.hash.name=r),"ECDSA"===n.name){let e=!1;if("algorithmParams"in a.algorithm==!0&&"idBlock"in a.algorithm.algorithmParams&&1===a.algorithm.algorithmParams.idBlock.tagClass&&6===a.algorithm.algorithmParams.idBlock.tagNumber&&(e=!0),!1===e)throw Error("Incorrect type for ECDSA public key parameters");let s=this.getAlgorithmByOID(a.algorithm.algorithmParams.valueBlock.toString(),!0);t.algorithm.algorithm.namedCurve=s.name}i=await this.getPublicKey(a,null,t)}else{if(!(r=this.getHashAlgorithm(s)))throw Error(`Unsupported signature algorithm: ${s.algorithmId}`);i=await this.getPublicKey(a,s)}let n=this.getAlgorithmParameters(i.algorithm.name,"verify");"hash"in n.algorithm&&(n.algorithm.hash.name=r);let u=t.valueBlock.valueHexView;if("ECDSA"===i.algorithm.name){let e=an.find(i.algorithm.namedCurve);if(!e)throw Error("Unsupported named curve in use");let t=o.fromBER(u);S.assert(t,"Signature value"),u=sg(t.result,e.size)}if("RSA-PSS"===i.algorithm.name){let e=new a3({schema:s.algorithmParams});"saltLength"in e?n.algorithm.saltLength=e.saltLength:n.algorithm.saltLength=20;let t="SHA-1";if("hashAlgorithm"in e){let a=this.getAlgorithmByOID(e.hashAlgorithm.algorithmId,!0);t=a.name}n.algorithm.hash.name=t}return this.verify(n.algorithm,i,u,e)}}let sn={name:"none",crypto:null};function su(e){return!!e&&"object"==typeof e&&"crypto"in e}function sl(e,...t){let s=null;if(t.length<2)s=t.length?t[0]:"undefined"!=typeof self&&self.crypto?new si({name:"browser",crypto:self.crypto}):null;else{let e=t[0],a=t[1];su(a)?s=a:su(e)?s=e:"subtle"in e&&"getRandomValues"in e&&(s=new si({crypto:e}))}if(void 0!==f&&"pid"in f&&void 0!==a.g&&"undefined"==typeof window){if(void 0===a.g[f.pid])a.g[f.pid]={};else if("object"!=typeof a.g[f.pid])throw Error(`Name global.${f.pid} already exists and it is not an object`);if(void 0===a.g[f.pid].pkijs)a.g[f.pid].pkijs={};else if("object"!=typeof a.g[f.pid].pkijs)throw Error(`Name global.${f.pid}.pkijs already exists and it is not an object`);a.g[f.pid].pkijs.engine={name:e,crypto:s}}else sn={name:e,crypto:s}}function so(){if(void 0!==f&&"pid"in f&&void 0!==a.g&&"undefined"==typeof window){let e;try{e=a.g[f.pid].pkijs.engine}catch(e){throw Error("Please call 'setEngine' before call to 'getEngine'")}return e}return sn}function sc(e=!1){let t=so();if(!t.crypto&&e)throw Error("Unable to create WebCrypto object");return t.crypto}function sh(e){return sc(!0).getRandomValues(e)}function sm(e,t,a){return sc(!0).getOIDByAlgorithm(e,t,a)}function sf(e,t){return sc(!0).getAlgorithmParameters(e,t)}function sd(e){if(e.byteLength%2!=0)return d;let t=e.byteLength/2,a=new ArrayBuffer(t),s=new Uint8Array(a);s.set(new Uint8Array(e,0,t));let r=new o.Integer({valueHex:a}),i=new ArrayBuffer(t),n=new Uint8Array(i);n.set(new Uint8Array(e,t,t));let u=new o.Integer({valueHex:i});return new o.Sequence({value:[r.convertToDER(),u.convertToDER()]}).toBER(!1)}function sg(e,t){if(!(e instanceof o.Sequence&&2===e.valueBlock.value.length&&e.valueBlock.value[0]instanceof o.Integer&&e.valueBlock.value[1]instanceof o.Integer))return d;let a=e.valueBlock.value[0].convertFromDER().valueBlock.valueHexView,s=e.valueBlock.value[1].convertFromDER().valueBlock.valueHexView,r=new Uint8Array(2*t);return r.set(a,t-a.byteLength),r.set(s,2*t-s.byteLength),r.buffer}function sp(e,t=!1,a){return sc(!0).getAlgorithmByOID(e,t,a)}function sS(e){return sc(!0).getHashAlgorithm(e)}async function sy(e,t,a,s,r){switch(e.toUpperCase()){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":break;default:throw new g(`Unknown hash function: ${e}`)}if(g.assert(t,"zBuffer","ArrayBuffer"),0===t.byteLength)throw new g("'zBuffer' has zero length, error");if(g.assert(s,"SharedInfo","ArrayBuffer"),a>255)throw new g("Please set 'Counter' argument to value less or equal to 255");let i=new ArrayBuffer(4),n=new Uint8Array(i);n[0]=0,n[1]=0,n[2]=0,n[3]=a;let u=d;u=h.hk(u,t),u=h.hk(u,i),u=h.hk(u,s);let l=await r.digest({name:e},u);return{counter:a,result:l}}async function sw(e,t,a,s,r=sc(!0)){let i=0,n=1;switch(e.toUpperCase()){case"SHA-1":i=160;break;case"SHA-256":i=256;break;case"SHA-384":i=384;break;case"SHA-512":i=512;break;default:throw new g(`Unknown hash function: ${e}`)}if(g.assert(t,"Zbuffer","ArrayBuffer"),0===t.byteLength)throw new g("'Zbuffer' has zero length, error");g.assert(s,"SharedInfo","ArrayBuffer");let u=a/i;Math.floor(u)>0&&(n=Math.floor(u),u-n>0&&n++);let l=[];for(let a=1;a<=n;a++)l.push(await sy(e,t,a,s,r));let o=d,c=1,m=!0;for(;m;){for(let e of(m=!1,l))if(e.counter===c){o=h.hk(o,e.result),m=!0;break}c++}if(a>>=3,o.byteLength>a){let e=new ArrayBuffer(a),t=new Uint8Array(e),s=new Uint8Array(o);for(let e=0;e<a;e++)t[e]=s[e];return e}return o}let sv="version",sb="logID",sA="extensions",sk="timestamp",sC="hashAlgorithm",sN="signatureAlgorithm",sV="signature",sI="none",sB="sha1",sE="sha224",sH="sha256",sD="sha384",sO="sha512",sx="anonymous",sP="ecdsa";class s$ extends y{constructor(e={}){super(),this.version=h.H$(e,sv,s$.defaultValues(sv)),this.logID=h.H$(e,sb,s$.defaultValues(sb)),this.timestamp=h.H$(e,sk,s$.defaultValues(sk)),this.extensions=h.H$(e,sA,s$.defaultValues(sA)),this.hashAlgorithm=h.H$(e,sC,s$.defaultValues(sC)),this.signatureAlgorithm=h.H$(e,sN,s$.defaultValues(sN)),this.signature=h.H$(e,sV,s$.defaultValues(sV)),"stream"in e&&e.stream&&this.fromStream(e.stream),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case sv:return 0;case sb:case sA:return d;case sk:return new Date(0);case sC:case sN:return"";case sV:return new o.Any;default:return super.defaultValues(e)}}fromSchema(e){if(e instanceof o.RawData==!1)throw Error("Object's schema was not verified against input data for SignedCertificateTimestamp");let t=new m.sF({stream:new m.$W({buffer:e.data})});this.fromStream(t)}fromStream(e){let t=e.getUint16();if(this.version=e.getBlock(1)[0],0===this.version){this.logID=new Uint8Array(e.getBlock(32)).buffer.slice(0),this.timestamp=new Date(h.r9(new Uint8Array(e.getBlock(8)),8));let a=e.getUint16();switch(this.extensions=new Uint8Array(e.getBlock(a)).buffer.slice(0),e.getBlock(1)[0]){case 0:this.hashAlgorithm=sI;break;case 1:this.hashAlgorithm="md5";break;case 2:this.hashAlgorithm=sB;break;case 3:this.hashAlgorithm=sE;break;case 4:this.hashAlgorithm=sH;break;case 5:this.hashAlgorithm=sD;break;case 6:this.hashAlgorithm=sO;break;default:throw Error("Object's stream was not correct for SignedCertificateTimestamp")}switch(e.getBlock(1)[0]){case 0:this.signatureAlgorithm=sx;break;case 1:this.signatureAlgorithm="rsa";break;case 2:this.signatureAlgorithm="dsa";break;case 3:this.signatureAlgorithm=sP;break;default:throw Error("Object's stream was not correct for SignedCertificateTimestamp")}let s=e.getUint16(),r=new Uint8Array(e.getBlock(s)).buffer.slice(0),i=o.fromBER(r);if(S.assert(i,"SignedCertificateTimestamp"),this.signature=i.result,t!==47+a+s)throw Error("Object's stream was not correct for SignedCertificateTimestamp")}}toSchema(){let e=this.toStream();return new o.RawData({data:e.stream.buffer})}toStream(){let e,t;let a=new m.sF;a.appendUint16(47+this.extensions.byteLength+this.signature.valueBeforeDecodeView.byteLength),a.appendChar(this.version),a.appendView(new Uint8Array(this.logID));let s=new ArrayBuffer(8),r=new Uint8Array(s),i=h.lL(this.timestamp.valueOf(),8);switch(r.set(new Uint8Array(i),8-i.byteLength),a.appendView(r),a.appendUint16(this.extensions.byteLength),this.extensions.byteLength&&a.appendView(new Uint8Array(this.extensions)),this.hashAlgorithm.toLowerCase()){case sI:e=0;break;case"md5":e=1;break;case sB:e=2;break;case sE:e=3;break;case sH:e=4;break;case sD:e=5;break;case sO:e=6;break;default:throw Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`)}switch(a.appendChar(e),this.signatureAlgorithm.toLowerCase()){case sx:t=0;break;case"rsa":t=1;break;case"dsa":t=2;break;case sP:t=3;break;default:throw Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`)}a.appendChar(t);let n=this.signature.toBER(!1);return a.appendUint16(n.byteLength),a.appendView(new Uint8Array(n)),a}toJSON(){return{version:this.version,logID:h.RH(this.logID),timestamp:this.timestamp,extensions:h.RH(this.extensions),hashAlgorithm:this.hashAlgorithm,signatureAlgorithm:this.signatureAlgorithm,signature:this.signature.toJSON()}}async verify(e,t,a=0,s=sc(!0)){let r=h.s3(h.lE(this.logID)),i=null,n=new m.sF;for(let t of e)if(t.log_id===r){i=t.key;break}if(!i)throw Error(`Public key not found for CT with logId: ${r}`);let u=h.gG(h.Gh(i)),l=ap.fromBER(u);n.appendChar(0),n.appendChar(0);let c=new ArrayBuffer(8),f=new Uint8Array(c),d=h.lL(this.timestamp.valueOf(),8);return f.set(new Uint8Array(d),8-d.byteLength),n.appendView(f),n.appendUint16(a),0===a&&n.appendUint24(t.byteLength),n.appendView(new Uint8Array(t)),n.appendUint16(this.extensions.byteLength),0!==this.extensions.byteLength&&n.appendView(new Uint8Array(this.extensions)),s.verifyWithPublicKey(n.buffer.slice(0,n.length),new o.OctetString({valueHex:this.signature.toBER(!1)}),l,{algorithmId:""},"SHA-256")}}async function sq(e,t,a,s=-1,r=sc(!0)){let i=null,n=new m.sF;for(let t=0;e.extensions&&t<e.extensions.length;t++)if(e.extensions[t].extnID===eH){if(!(i=e.extensions[t].parsedValue)||0===i.timestamps.length)throw Error("Nothing to verify in the certificate");e.extensions.splice(t,1)}if(null===i)throw Error("No SignedCertificateTimestampList extension in the specified certificate");let u=e.encodeTBS().toBER(),l=await r.digest({name:"SHA-256"},new Uint8Array(t.subjectPublicKeyInfo.toSchema().toBER(!1)));n.appendView(new Uint8Array(l)),n.appendUint24(u.byteLength),n.appendView(new Uint8Array(u));let o=n.stream.slice(0,n.length);if(-1===s){let e=[];for(let t of i.timestamps){let s=await t.verify(a,o.buffer,1,r);e.push(s)}return e}return s>=i.timestamps.length&&(s=i.timestamps.length-1),[await i.timestamps[s].verify(a,o.buffer,1,r)]}s$.CLASS_NAME="SignedCertificateTimestamp";let sK="timestamps";class sR extends y{constructor(e={}){super(),this.timestamps=h.H$(e,sK,sR.defaultValues(sK)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===sK?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===sK?0===t.length:super.defaultValues(e)}static schema(e={}){var t;let a=h.H$(e,"names",{});return null!==(t=a.optional)&&void 0!==t||(a.optional=!1),new o.OctetString({name:a.blockName||"SignedCertificateTimestampList",optional:a.optional})}fromSchema(e){if(e instanceof o.OctetString==!1)throw Error("Object's schema was not verified against input data for SignedCertificateTimestampList");let t=new m.sF({stream:new m.$W({buffer:e.valueBlock.valueHex})}),a=t.getUint16();if(a!==t.length)throw Error("Object's schema was not verified against input data for SignedCertificateTimestampList");for(;t.length;)this.timestamps.push(new s$({stream:t}))}toSchema(){let e=new m.sF,t=0,a=[];for(let e of this.timestamps){let s=e.toStream();a.push(s),t+=s.stream.buffer.byteLength}for(let s of(e.appendUint16(t),a))e.appendView(s.stream.view);return new o.OctetString({valueHex:e.stream.buffer.slice(0)})}toJSON(){return{timestamps:Array.from(this.timestamps,e=>e.toJSON())}}}sR.CLASS_NAME="SignedCertificateTimestampList";let sJ="attributes",sU=[sJ];class sT extends y{constructor(e={}){super(),this.attributes=h.H$(e,sJ,sT.defaultValues(sJ)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===sJ?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.attributes||"",value:Q.schema()})]})}fromSchema(e){h.ze(e,sU);let t=o.compareSchema(e,e,sT.schema({names:{attributes:sJ}}));S.assertSchema(t,this.className),this.attributes=Array.from(t.result.attributes,e=>new Q({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){return{attributes:Array.from(this.attributes,e=>e.toJSON())}}}sT.CLASS_NAME="SubjectDirectoryAttributes";class sj{static getItems(){return this.types||(this.types={},sj.register(el,"SubjectAltName",W),sj.register(eo,"IssuerAltName",W),sj.register(eC,"AuthorityKeyIdentifier",e4),sj.register(ec,"BasicConstraints",e5),sj.register(eP,"MicrosoftCaVersion",e7),sj.register(ev,"CertificatePolicies",tc),sj.register(eA,"CertificatePoliciesMicrosoft",tc),sj.register(ex,"MicrosoftCertTemplateV2",tg),sj.register(ey,"CRLDistributionPoints",tN),sj.register(ew,"FreshestCRL",tN),sj.register(eV,"ExtKeyUsage",tB),sj.register(ep,"CertificateIssuer",es),sj.register(eB,"AuthorityInfoAccess",tH),sj.register(eE,"SubjectInfoAccess",tH),sj.register(eg,"IssuingDistributionPoint",tJ),sj.register(eS,"NameConstraints",tF),sj.register(eN,"PolicyConstraints",tY),sj.register(ek,"PolicyMappings",t8),sj.register(eu,"PrivateKeyUsagePeriod",t7),sj.register(e$,"QCStatements",ai),sj.register(eH,"SignedCertificateTimestampList",sR),sj.register(er,"SubjectDirectoryAttributes",sT)),this.types}static fromBER(e,t){let a=o.fromBER(t);if(-1===a.offset)return null;let s=this.find(e);if(s)try{return new s.type({schema:a.result})}catch(a){let t=new s.type;return t.parsingError=`Incorrectly formatted value of extension ${s.name} (${e})`,t}return a.result}static find(e){return this.getItems()[e]||null}static register(e,t,a){this.getItems()[e]={name:t,type:a}}}let sL="extnID",sM="critical",s_="extnValue",sW="parsedValue",sz=[sL,sM,s_];class sF extends y{constructor(e={}){super(),this.extnID=h.H$(e,sL,sF.defaultValues(sL)),this.critical=h.H$(e,sM,sF.defaultValues(sM)),s_ in e?this.extnValue=new o.OctetString({valueHex:e.extnValue}):this.extnValue=sF.defaultValues(s_),sW in e&&(this.parsedValue=h.H$(e,sW,sF.defaultValues(sW))),e.schema&&this.fromSchema(e.schema)}get parsedValue(){if(void 0===this._parsedValue){let e=sj.fromBER(this.extnID,this.extnValue.valueBlock.valueHexView);this._parsedValue=e}return this._parsedValue||void 0}set parsedValue(e){this._parsedValue=e}static defaultValues(e){switch(e){case sL:return"";case sM:return!1;case s_:return new o.OctetString;case sW:return{};default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.extnID||""}),new o.Boolean({name:t.critical||"",optional:!0}),new o.OctetString({name:t.extnValue||""})]})}fromSchema(e){h.ze(e,sz);let t=o.compareSchema(e,e,sF.schema({names:{extnID:sL,critical:sM,extnValue:s_}}));S.assertSchema(t,this.className),this.extnID=t.result.extnID.valueBlock.toString(),sM in t.result&&(this.critical=t.result.critical.valueBlock.value),this.extnValue=t.result.extnValue}toSchema(){let e=[];return e.push(new o.ObjectIdentifier({value:this.extnID})),this.critical!==sF.defaultValues(sM)&&e.push(new o.Boolean({value:this.critical})),e.push(this.extnValue),new o.Sequence({value:e})}toJSON(){let e={extnID:this.extnID,extnValue:this.extnValue.toJSON()};return this.critical!==sF.defaultValues(sM)&&(e.critical=this.critical),this.parsedValue&&this.parsedValue.toJSON&&(e.parsedValue=this.parsedValue.toJSON()),e}}sF.CLASS_NAME="Extension";let sG="extensions",sQ=[sG];class sX extends y{constructor(e={}){super(),this.extensions=h.H$(e,sG,sX.defaultValues(sG)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===sG?[]:super.defaultValues(e)}static schema(e={},t=!1){let a=h.H$(e,"names",{});return new o.Sequence({optional:t,name:a.blockName||"",value:[new o.Repeated({name:a.extensions||"",value:sF.schema(a.extension||{})})]})}fromSchema(e){h.ze(e,sQ);let t=o.compareSchema(e,e,sX.schema({names:{extensions:sG}}));S.assertSchema(t,this.className),this.extensions=Array.from(t.result.extensions,e=>new sF({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.extensions,e=>e.toSchema())})}toJSON(){return{extensions:this.extensions.map(e=>e.toJSON())}}}sX.CLASS_NAME="Extensions";let sY="issuer",sZ="serialNumber",s1="issuerUID",s0=[sY,sZ,s1];class s2 extends y{constructor(e={}){super(),this.issuer=h.H$(e,sY,s2.defaultValues(sY)),this.serialNumber=h.H$(e,sZ,s2.defaultValues(sZ)),s1 in e&&(this.issuerUID=h.H$(e,s1,s2.defaultValues(s1))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case sY:return new es;case sZ:return new o.Integer;case s1:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[es.schema(t.issuer||{}),new o.Integer({name:t.serialNumber||""}),new o.BitString({optional:!0,name:t.issuerUID||""})]})}fromSchema(e){h.ze(e,s0);let t=o.compareSchema(e,e,s2.schema({names:{issuer:{names:{blockName:sY}},serialNumber:sZ,issuerUID:s1}}));S.assertSchema(t,this.className),this.issuer=new es({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber,s1 in t.result&&(this.issuerUID=t.result.issuerUID)}toSchema(){let e=new o.Sequence({value:[this.issuer.toSchema(),this.serialNumber]});return this.issuerUID&&e.valueBlock.value.push(this.issuerUID),e}toJSON(){let e={issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()};return this.issuerUID&&(e.issuerUID=this.issuerUID.toJSON()),e}}s2.CLASS_NAME="IssuerSerial";let s3="version",s4="baseCertificateID",s8="subjectName",s5="issuer",s6="signature",s9="serialNumber",s7="attrCertValidityPeriod",re="attributes",rt="issuerUniqueID",ra="extensions",rs=[s3,s4,s8,s5,s6,s9,s7,re,rt,ra];class rr extends y{constructor(e={}){super(),this.version=h.H$(e,s3,rr.defaultValues(s3)),s4 in e&&(this.baseCertificateID=h.H$(e,s4,rr.defaultValues(s4))),s8 in e&&(this.subjectName=h.H$(e,s8,rr.defaultValues(s8))),this.issuer=h.H$(e,s5,rr.defaultValues(s5)),this.signature=h.H$(e,s6,rr.defaultValues(s6)),this.serialNumber=h.H$(e,s9,rr.defaultValues(s9)),this.attrCertValidityPeriod=h.H$(e,s7,rr.defaultValues(s7)),this.attributes=h.H$(e,re,rr.defaultValues(re)),rt in e&&(this.issuerUniqueID=h.H$(e,rt,rr.defaultValues(rt))),ra in e&&(this.extensions=h.H$(e,ra,rr.defaultValues(ra))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case s3:return 0;case s4:return new s2;case s8:case s5:return new es;case s6:return new L;case s9:return new o.Integer;case s7:return new ee;case re:return[];case rt:return new o.BitString;case ra:return new sX;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),new o.Choice({value:[new o.Constructed({name:t.baseCertificateID||"",idBlock:{tagClass:3,tagNumber:0},value:s2.schema().valueBlock.value}),new o.Constructed({name:t.subjectName||"",idBlock:{tagClass:3,tagNumber:1},value:es.schema().valueBlock.value})]}),es.schema({names:{blockName:t.issuer||""}}),L.schema(t.signature||{}),new o.Integer({name:t.serialNumber||""}),ee.schema(t.attrCertValidityPeriod||{}),new o.Sequence({name:t.attributes||"",value:[new o.Repeated({value:Q.schema()})]}),new o.BitString({optional:!0,name:t.issuerUniqueID||""}),sX.schema(t.extensions||{},!0)]})}fromSchema(e){h.ze(e,rs);let t=o.compareSchema(e,e,rr.schema({names:{version:s3,baseCertificateID:s4,subjectName:s8,issuer:s5,signature:{names:{blockName:s6}},serialNumber:s9,attrCertValidityPeriod:{names:{blockName:s7}},attributes:re,issuerUniqueID:rt,extensions:{names:{blockName:ra}}}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,s4 in t.result&&(this.baseCertificateID=new s2({schema:new o.Sequence({value:t.result.baseCertificateID.valueBlock.value})})),s8 in t.result&&(this.subjectName=new es({schema:new o.Sequence({value:t.result.subjectName.valueBlock.value})})),this.issuer=t.result.issuer,this.signature=new L({schema:t.result.signature}),this.serialNumber=t.result.serialNumber,this.attrCertValidityPeriod=new ee({schema:t.result.attrCertValidityPeriod}),this.attributes=Array.from(t.result.attributes.valueBlock.value,e=>new Q({schema:e})),rt in t.result&&(this.issuerUniqueID=t.result.issuerUniqueID),ra in t.result&&(this.extensions=new sX({schema:t.result.extensions}))}toSchema(){let e=new o.Sequence({value:[new o.Integer({value:this.version})]});return this.baseCertificateID&&e.valueBlock.value.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.subjectName&&e.valueBlock.value.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.subjectName.toSchema().valueBlock.value})),e.valueBlock.value.push(this.issuer.toSchema()),e.valueBlock.value.push(this.signature.toSchema()),e.valueBlock.value.push(this.serialNumber),e.valueBlock.value.push(this.attrCertValidityPeriod.toSchema()),e.valueBlock.value.push(new o.Sequence({value:Array.from(this.attributes,e=>e.toSchema())})),this.issuerUniqueID&&e.valueBlock.value.push(this.issuerUniqueID),this.extensions&&e.valueBlock.value.push(this.extensions.toSchema()),e}toJSON(){let e={version:this.version};return this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.subjectName&&(e.subjectName=this.subjectName.toJSON()),e.issuer=this.issuer.toJSON(),e.signature=this.signature.toJSON(),e.serialNumber=this.serialNumber.toJSON(),e.attrCertValidityPeriod=this.attrCertValidityPeriod.toJSON(),e.attributes=Array.from(this.attributes,e=>e.toJSON()),this.issuerUniqueID&&(e.issuerUniqueID=this.issuerUniqueID.toJSON()),this.extensions&&(e.extensions=this.extensions.toJSON()),e}}rr.CLASS_NAME="AttributeCertificateInfoV1";let ri="acinfo",rn="signatureAlgorithm",ru="signatureValue",rl=[ri,ru,rn];class ro extends y{constructor(e={}){super(),this.acinfo=h.H$(e,ri,ro.defaultValues(ri)),this.signatureAlgorithm=h.H$(e,rn,ro.defaultValues(rn)),this.signatureValue=h.H$(e,ru,ro.defaultValues(ru)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ri:return new rr;case rn:return new L;case ru:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[rr.schema(t.acinfo||{}),L.schema(t.signatureAlgorithm||{}),new o.BitString({name:t.signatureValue||""})]})}fromSchema(e){h.ze(e,rl);let t=o.compareSchema(e,e,ro.schema({names:{acinfo:{names:{blockName:ri}},signatureAlgorithm:{names:{blockName:rn}},signatureValue:ru}}));S.assertSchema(t,this.className),this.acinfo=new rr({schema:t.result.acinfo}),this.signatureAlgorithm=new L({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}toSchema(){return new o.Sequence({value:[this.acinfo.toSchema(),this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){return{acinfo:this.acinfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()}}}ro.CLASS_NAME="AttributeCertificateV1";let rc="digestedObjectType",rh="otherObjectTypeID",rm="digestAlgorithm",rf="objectDigest",rd=[rc,rh,rm,rf];class rg extends y{constructor(e={}){super(),this.digestedObjectType=h.H$(e,rc,rg.defaultValues(rc)),rh in e&&(this.otherObjectTypeID=h.H$(e,rh,rg.defaultValues(rh))),this.digestAlgorithm=h.H$(e,rm,rg.defaultValues(rm)),this.objectDigest=h.H$(e,rf,rg.defaultValues(rf)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case rc:return new o.Enumerated;case rh:return new o.ObjectIdentifier;case rm:return new L;case rf:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Enumerated({name:t.digestedObjectType||""}),new o.ObjectIdentifier({optional:!0,name:t.otherObjectTypeID||""}),L.schema(t.digestAlgorithm||{}),new o.BitString({name:t.objectDigest||""})]})}fromSchema(e){h.ze(e,rd);let t=o.compareSchema(e,e,rg.schema({names:{digestedObjectType:rc,otherObjectTypeID:rh,digestAlgorithm:{names:{blockName:rm}},objectDigest:rf}}));S.assertSchema(t,this.className),this.digestedObjectType=t.result.digestedObjectType,rh in t.result&&(this.otherObjectTypeID=t.result.otherObjectTypeID),this.digestAlgorithm=new L({schema:t.result.digestAlgorithm}),this.objectDigest=t.result.objectDigest}toSchema(){let e=new o.Sequence({value:[this.digestedObjectType]});return this.otherObjectTypeID&&e.valueBlock.value.push(this.otherObjectTypeID),e.valueBlock.value.push(this.digestAlgorithm.toSchema()),e.valueBlock.value.push(this.objectDigest),e}toJSON(){let e={digestedObjectType:this.digestedObjectType.toJSON(),digestAlgorithm:this.digestAlgorithm.toJSON(),objectDigest:this.objectDigest.toJSON()};return this.otherObjectTypeID&&(e.otherObjectTypeID=this.otherObjectTypeID.toJSON()),e}}rg.CLASS_NAME="ObjectDigestInfo";let rp="issuerName",rS="baseCertificateID",ry="objectDigestInfo",rw=[rp,rS,ry];class rv extends y{constructor(e={}){super(),rp in e&&(this.issuerName=h.H$(e,rp,rv.defaultValues(rp))),rS in e&&(this.baseCertificateID=h.H$(e,rS,rv.defaultValues(rS))),ry in e&&(this.objectDigestInfo=h.H$(e,ry,rv.defaultValues(ry))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case rp:return new es;case rS:return new s2;case ry:return new rg;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[es.schema({names:{blockName:t.issuerName}},!0),new o.Constructed({optional:!0,name:t.baseCertificateID||"",idBlock:{tagClass:3,tagNumber:0},value:s2.schema().valueBlock.value}),new o.Constructed({optional:!0,name:t.objectDigestInfo||"",idBlock:{tagClass:3,tagNumber:1},value:rg.schema().valueBlock.value})]})}fromSchema(e){h.ze(e,rw);let t=o.compareSchema(e,e,rv.schema({names:{issuerName:rp,baseCertificateID:rS,objectDigestInfo:ry}}));S.assertSchema(t,this.className),rp in t.result&&(this.issuerName=new es({schema:t.result.issuerName})),rS in t.result&&(this.baseCertificateID=new s2({schema:new o.Sequence({value:t.result.baseCertificateID.valueBlock.value})})),ry in t.result&&(this.objectDigestInfo=new rg({schema:new o.Sequence({value:t.result.objectDigestInfo.valueBlock.value})}))}toSchema(){let e=new o.Sequence;return this.issuerName&&e.valueBlock.value.push(this.issuerName.toSchema()),this.baseCertificateID&&e.valueBlock.value.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.objectDigestInfo&&e.valueBlock.value.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){let e={};return this.issuerName&&(e.issuerName=this.issuerName.toJSON()),this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.objectDigestInfo&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}}rv.CLASS_NAME="V2Form";let rb="baseCertificateID",rA="entityName",rk="objectDigestInfo",rC=[rb,rA,rk];class rN extends y{constructor(e={}){super(),rb in e&&(this.baseCertificateID=h.H$(e,rb,rN.defaultValues(rb))),rA in e&&(this.entityName=h.H$(e,rA,rN.defaultValues(rA))),rk in e&&(this.objectDigestInfo=h.H$(e,rk,rN.defaultValues(rk))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case rb:return new s2;case rA:return new es;case rk:return new rg;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Constructed({optional:!0,name:t.baseCertificateID||"",idBlock:{tagClass:3,tagNumber:0},value:s2.schema().valueBlock.value}),new o.Constructed({optional:!0,name:t.entityName||"",idBlock:{tagClass:3,tagNumber:1},value:es.schema().valueBlock.value}),new o.Constructed({optional:!0,name:t.objectDigestInfo||"",idBlock:{tagClass:3,tagNumber:2},value:rg.schema().valueBlock.value})]})}fromSchema(e){h.ze(e,rC);let t=o.compareSchema(e,e,rN.schema({names:{baseCertificateID:rb,entityName:rA,objectDigestInfo:rk}}));S.assertSchema(t,this.className),rb in t.result&&(this.baseCertificateID=new s2({schema:new o.Sequence({value:t.result.baseCertificateID.valueBlock.value})})),rA in t.result&&(this.entityName=new es({schema:new o.Sequence({value:t.result.entityName.valueBlock.value})})),rk in t.result&&(this.objectDigestInfo=new rg({schema:new o.Sequence({value:t.result.objectDigestInfo.valueBlock.value})}))}toSchema(){let e=new o.Sequence;return this.baseCertificateID&&e.valueBlock.value.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.entityName&&e.valueBlock.value.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.entityName.toSchema().valueBlock.value})),this.objectDigestInfo&&e.valueBlock.value.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){let e={};return this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.entityName&&(e.entityName=this.entityName.toJSON()),this.objectDigestInfo&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}}rN.CLASS_NAME="Holder";let rV="version",rI="holder",rB="issuer",rE="signature",rH="serialNumber",rD="attrCertValidityPeriod",rO="attributes",rx="issuerUniqueID",rP="extensions",r$=[rV,rI,rB,rE,rH,rD,rO,rx,rP];class rq extends y{constructor(e={}){super(),this.version=h.H$(e,rV,rq.defaultValues(rV)),this.holder=h.H$(e,rI,rq.defaultValues(rI)),this.issuer=h.H$(e,rB,rq.defaultValues(rB)),this.signature=h.H$(e,rE,rq.defaultValues(rE)),this.serialNumber=h.H$(e,rH,rq.defaultValues(rH)),this.attrCertValidityPeriod=h.H$(e,rD,rq.defaultValues(rD)),this.attributes=h.H$(e,rO,rq.defaultValues(rO)),rx in e&&(this.issuerUniqueID=h.H$(e,rx,rq.defaultValues(rx))),rP in e&&(this.extensions=h.H$(e,rP,rq.defaultValues(rP))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case rV:return 1;case rI:return new rN;case rB:return{};case rE:return new L;case rH:return new o.Integer;case rD:return new ee;case rO:return[];case rx:return new o.BitString;case rP:return new sX;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),rN.schema(t.holder||{}),new o.Choice({value:[es.schema({names:{blockName:t.issuer||""}}),new o.Constructed({name:t.issuer||"",idBlock:{tagClass:3,tagNumber:0},value:rv.schema().valueBlock.value})]}),L.schema(t.signature||{}),new o.Integer({name:t.serialNumber||""}),ee.schema(t.attrCertValidityPeriod||{}),new o.Sequence({name:t.attributes||"",value:[new o.Repeated({value:Q.schema()})]}),new o.BitString({optional:!0,name:t.issuerUniqueID||""}),sX.schema(t.extensions||{},!0)]})}fromSchema(e){h.ze(e,r$);let t=o.compareSchema(e,e,rq.schema({names:{version:rV,holder:{names:{blockName:rI}},issuer:rB,signature:{names:{blockName:rE}},serialNumber:rH,attrCertValidityPeriod:{names:{blockName:rD}},attributes:rO,issuerUniqueID:rx,extensions:{names:{blockName:rP}}}}));if(S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.holder=new rN({schema:t.result.holder}),3===t.result.issuer.idBlock.tagClass)this.issuer=new rv({schema:new o.Sequence({value:t.result.issuer.valueBlock.value})});else throw Error("Incorrect value for 'issuer' in AttributeCertificateInfoV2");this.signature=new L({schema:t.result.signature}),this.serialNumber=t.result.serialNumber,this.attrCertValidityPeriod=new ee({schema:t.result.attrCertValidityPeriod}),this.attributes=Array.from(t.result.attributes.valueBlock.value,e=>new Q({schema:e})),rx in t.result&&(this.issuerUniqueID=t.result.issuerUniqueID),rP in t.result&&(this.extensions=new sX({schema:t.result.extensions}))}toSchema(){let e=new o.Sequence({value:[new o.Integer({value:this.version}),this.holder.toSchema(),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.issuer.toSchema().valueBlock.value}),this.signature.toSchema(),this.serialNumber,this.attrCertValidityPeriod.toSchema(),new o.Sequence({value:Array.from(this.attributes,e=>e.toSchema())})]});return this.issuerUniqueID&&e.valueBlock.value.push(this.issuerUniqueID),this.extensions&&e.valueBlock.value.push(this.extensions.toSchema()),e}toJSON(){let e={version:this.version,holder:this.holder.toJSON(),issuer:this.issuer.toJSON(),signature:this.signature.toJSON(),serialNumber:this.serialNumber.toJSON(),attrCertValidityPeriod:this.attrCertValidityPeriod.toJSON(),attributes:Array.from(this.attributes,e=>e.toJSON())};return this.issuerUniqueID&&(e.issuerUniqueID=this.issuerUniqueID.toJSON()),this.extensions&&(e.extensions=this.extensions.toJSON()),e}}rq.CLASS_NAME="AttributeCertificateInfoV2";let rK="acinfo",rR="signatureAlgorithm",rJ="signatureValue",rU=[rK,rR,rJ];class rT extends y{constructor(e={}){super(),this.acinfo=h.H$(e,rK,rT.defaultValues(rK)),this.signatureAlgorithm=h.H$(e,rR,rT.defaultValues(rR)),this.signatureValue=h.H$(e,rJ,rT.defaultValues(rJ)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case rK:return new rq;case rR:return new L;case rJ:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[rq.schema(t.acinfo||{}),L.schema(t.signatureAlgorithm||{}),new o.BitString({name:t.signatureValue||""})]})}fromSchema(e){h.ze(e,rU);let t=o.compareSchema(e,e,rT.schema({names:{acinfo:{names:{blockName:rK}},signatureAlgorithm:{names:{blockName:rR}},signatureValue:rJ}}));S.assertSchema(t,this.className),this.acinfo=new rq({schema:t.result.acinfo}),this.signatureAlgorithm=new L({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}toSchema(){return new o.Sequence({value:[this.acinfo.toSchema(),this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){return{acinfo:this.acinfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()}}}rT.CLASS_NAME="AttributeCertificateV2";let rj="contentType",rL="content",rM=[rj,rL];class r_ extends y{constructor(e={}){super(),this.contentType=h.H$(e,rj,r_.defaultValues(rj)),this.content=h.H$(e,rL,r_.defaultValues(rL)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case rj:return"";case rL:return new o.Any;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case rj:return"string"==typeof t&&t===this.defaultValues(rj);case rL:return t instanceof o.Any;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return"optional"in t==!1&&(t.optional=!1),new o.Sequence({name:t.blockName||"ContentInfo",optional:t.optional,value:[new o.ObjectIdentifier({name:t.contentType||rj}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Any({name:t.content||rL})]})]})}fromSchema(e){h.ze(e,rM);let t=o.compareSchema(e,e,r_.schema());S.assertSchema(t,this.className),this.contentType=t.result.contentType.valueBlock.toString(),this.content=t.result.content}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.contentType}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.content]})]})}toJSON(){let e={contentType:this.contentType};return this.content instanceof o.Any||(e.content=this.content.toJSON()),e}}r_.CLASS_NAME="ContentInfo",r_.DATA=eq,r_.SIGNED_DATA=eK,r_.ENVELOPED_DATA=eR,r_.ENCRYPTED_DATA=eJ;let rW="type",rz="value",rF="utcTimeName",rG="generalTimeName",rQ=[rF,rG];(s=n||(n={}))[s.UTCTime=0]="UTCTime",s[s.GeneralizedTime=1]="GeneralizedTime",s[s.empty=2]="empty";class rX extends y{constructor(e={}){super(),this.type=h.H$(e,rW,rX.defaultValues(rW)),this.value=h.H$(e,rz,rX.defaultValues(rz)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case rW:return 0;case rz:return new Date(0,0,0);default:return super.defaultValues(e)}}static schema(e={},t=!1){let a=h.H$(e,"names",{});return new o.Choice({optional:t,value:[new o.UTCTime({name:a.utcTimeName||""}),new o.GeneralizedTime({name:a.generalTimeName||""})]})}fromSchema(e){h.ze(e,rQ);let t=o.compareSchema(e,e,rX.schema({names:{utcTimeName:rF,generalTimeName:rG}}));S.assertSchema(t,this.className),rF in t.result&&(this.type=0,this.value=t.result.utcTimeName.toDate()),rG in t.result&&(this.type=1,this.value=t.result.generalTimeName.toDate())}toSchema(){return 0===this.type?new o.UTCTime({valueDate:this.value}):1===this.type?new o.GeneralizedTime({valueDate:this.value}):{}}toJSON(){return{type:this.type,value:this.value}}}rX.CLASS_NAME="Time";let rY="version",rZ="serialNumber",r1="signature",r0="issuer",r2="notBefore",r3="notAfter",r4="subject",r8="subjectPublicKeyInfo",r5="issuerUniqueID",r6="subjectUniqueID",r9="extensions",r7="signatureAlgorithm",ie="signatureValue",it="tbsCertificate",ia=`${it}.${rY}`,is=`${it}.${rZ}`,ir=`${it}.${r1}`,ii=`${it}.${r0}`,iu=`${it}.${r2}`,il=`${it}.${r3}`,io=`${it}.${r4}`,ic=`${it}.${r8}`,ih=`${it}.${r5}`,im=`${it}.${r6}`,id=`${it}.${r9}`,ig=[it,ia,is,ir,ii,iu,il,io,ic,ih,im,id,r7,ie];class ip extends y{constructor(e={}){super(),this.tbsView=new Uint8Array(h.H$(e,"tbs",ip.defaultValues("tbs"))),this.version=h.H$(e,rY,ip.defaultValues(rY)),this.serialNumber=h.H$(e,rZ,ip.defaultValues(rZ)),this.signature=h.H$(e,r1,ip.defaultValues(r1)),this.issuer=h.H$(e,r0,ip.defaultValues(r0)),this.notBefore=h.H$(e,r2,ip.defaultValues(r2)),this.notAfter=h.H$(e,r3,ip.defaultValues(r3)),this.subject=h.H$(e,r4,ip.defaultValues(r4)),this.subjectPublicKeyInfo=h.H$(e,r8,ip.defaultValues(r8)),r5 in e&&(this.issuerUniqueID=h.H$(e,r5,ip.defaultValues(r5))),r6 in e&&(this.subjectUniqueID=h.H$(e,r6,ip.defaultValues(r6))),r9 in e&&(this.extensions=h.H$(e,r9,ip.defaultValues(r9))),this.signatureAlgorithm=h.H$(e,r7,ip.defaultValues(r7)),this.signatureValue=h.H$(e,ie,ip.defaultValues(ie)),e.schema&&this.fromSchema(e.schema)}get tbs(){return c.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case"tbs":return d;case rY:return 0;case rZ:return new o.Integer;case r1:return new L;case r0:return new V;case r2:case r3:return new rX;case r4:return new V;case r8:return new ap;case r5:case r6:return d;case r9:return[];case r7:return new L;case ie:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[function(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||it,value:[new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Integer({name:t.tbsCertificateVersion||ia})]}),new o.Integer({name:t.tbsCertificateSerialNumber||is}),L.schema(t.signature||{names:{blockName:ir}}),V.schema(t.issuer||{names:{blockName:ii}}),new o.Sequence({name:t.tbsCertificateValidity||"tbsCertificate.validity",value:[rX.schema(t.notBefore||{names:{utcTimeName:iu,generalTimeName:iu}}),rX.schema(t.notAfter||{names:{utcTimeName:il,generalTimeName:il}})]}),V.schema(t.subject||{names:{blockName:io}}),ap.schema(t.subjectPublicKeyInfo||{names:{blockName:ic}}),new o.Primitive({name:t.tbsCertificateIssuerUniqueID||ih,optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new o.Primitive({name:t.tbsCertificateSubjectUniqueID||im,optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[sX.schema(t.extensions||{names:{blockName:id}})]})]})}(t.tbsCertificate),L.schema(t.signatureAlgorithm||{names:{blockName:r7}}),new o.BitString({name:t.signatureValue||ie})]})}fromSchema(e){h.ze(e,ig);let t=o.compareSchema(e,e,ip.schema({names:{tbsCertificate:{names:{extensions:{names:{extensions:id}}}}}}));S.assertSchema(t,this.className),this.tbsView=t.result.tbsCertificate.valueBeforeDecodeView,ia in t.result&&(this.version=t.result[ia].valueBlock.valueDec),this.serialNumber=t.result[is],this.signature=new L({schema:t.result[ir]}),this.issuer=new V({schema:t.result[ii]}),this.notBefore=new rX({schema:t.result[iu]}),this.notAfter=new rX({schema:t.result[il]}),this.subject=new V({schema:t.result[io]}),this.subjectPublicKeyInfo=new ap({schema:t.result[ic]}),ih in t.result&&(this.issuerUniqueID=t.result[ih].valueBlock.valueHex),im in t.result&&(this.subjectUniqueID=t.result[im].valueBlock.valueHex),id in t.result&&(this.extensions=Array.from(t.result[id],e=>new sF({schema:e}))),this.signatureAlgorithm=new L({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){let e=[];return rY in this&&this.version!==ip.defaultValues(rY)&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Integer({value:this.version})]})),e.push(this.serialNumber),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(new o.Sequence({value:[this.notBefore.toSchema(),this.notAfter.toSchema()]})),e.push(this.subject.toSchema()),e.push(this.subjectPublicKeyInfo.toSchema()),this.issuerUniqueID&&e.push(new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:1},valueHex:this.issuerUniqueID})),this.subjectUniqueID&&e.push(new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:2},valueHex:this.subjectUniqueID})),this.extensions&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[new o.Sequence({value:Array.from(this.extensions,e=>e.toSchema())})]})),new o.Sequence({value:e})}toSchema(e=!1){let t;if(!1===e){if(!this.tbsView.byteLength)return ip.schema().value[0];let e=o.fromBER(this.tbsView);S.assert(e,"TBS Certificate"),t=e.result}else t=this.encodeTBS();return new o.Sequence({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){let e={tbs:c.ep.ToHex(this.tbsView),version:this.version,serialNumber:this.serialNumber.toJSON(),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),notBefore:this.notBefore.toJSON(),notAfter:this.notAfter.toJSON(),subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return rY in this&&this.version!==ip.defaultValues(rY)&&(e.version=this.version),this.issuerUniqueID&&(e.issuerUniqueID=c.ep.ToHex(this.issuerUniqueID)),this.subjectUniqueID&&(e.subjectUniqueID=c.ep.ToHex(this.subjectUniqueID)),this.extensions&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}async getPublicKey(e,t=sc(!0)){return t.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}async getKeyHash(e="SHA-1",t=sc(!0)){return t.digest({name:e},this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView)}async sign(e,t="SHA-1",a=sc(!0)){if(!e)throw Error("Need to provide a private key for signing");let s=await a.getSignatureParameters(e,t),r=s.parameters;this.signature=s.signatureAlgorithm,this.signatureAlgorithm=s.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());let i=await a.signWithPrivateKey(this.tbsView,e,r);this.signatureValue=new o.BitString({valueHex:i})}async verify(e,t=sc(!0)){let a;if(e?a=e.subjectPublicKeyInfo:this.issuer.isEqual(this.subject)&&(a=this.subjectPublicKeyInfo),!(a instanceof ap))throw Error("Please provide issuer certificate as a parameter");return t.verifyWithPublicKey(this.tbsView,this.signatureValue,a,this.signatureAlgorithm)}}function iS(e,t=null){if(t&&e.issuer.isEqual(t.issuer)&&e.serialNumber.isEqual(t.serialNumber))return null;let a=!1;if(e.extensions){for(let t of e.extensions)if(t.extnID===ec&&t.parsedValue instanceof e5&&t.parsedValue.cA){a=!0;break}}return a?e:null}ip.CLASS_NAME="Certificate";let iy="certId",iw="certValue",iv="parsedValue",ib=[iy,iw];class iA extends y{constructor(e={}){super(),this.certId=h.H$(e,iy,iA.defaultValues(iy)),this.certValue=h.H$(e,iw,iA.defaultValues(iw)),iv in e&&(this.parsedValue=h.H$(e,iv,iA.defaultValues(iv))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case iy:return"";case iw:return new o.Any;case iv:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case iy:return""===t;case iw:return t instanceof o.Any;case iv:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.id||"id"}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Any({name:t.value||"value"})]})]})}fromSchema(e){h.ze(e,ib);let t=o.compareSchema(e,e,iA.schema({names:{id:iy,value:iw}}));S.assertSchema(t,this.className),this.certId=t.result.certId.valueBlock.toString(),this.certValue=t.result.certValue;let a=this.certValue.valueBlock.valueHexView;switch(this.certId){case eT:try{this.parsedValue=ip.fromBER(a)}catch(e){rT.fromBER(a)}break;case eL:this.parsedValue=rT.fromBER(a);break;default:throw Error(`Incorrect CERT_ID value in CertBag: ${this.certId}`)}}toSchema(){return iv in this&&("acinfo"in this.parsedValue?this.certId=eL:this.certId=eT,this.certValue=new o.OctetString({valueHex:this.parsedValue.toSchema().toBER(!1)})),new o.Sequence({value:[new o.ObjectIdentifier({value:this.certId}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:["toSchema"in this.certValue?this.certValue.toSchema():this.certValue]})]})}toJSON(){return{certId:this.certId,certValue:this.certValue.toJSON()}}}iA.CLASS_NAME="CertBag";let ik="userCertificate",iC="revocationDate",iN="crlEntryExtensions",iV=[ik,iC,iN];class iI extends y{constructor(e={}){super(),this.userCertificate=h.H$(e,ik,iI.defaultValues(ik)),this.revocationDate=h.H$(e,iC,iI.defaultValues(iC)),iN in e&&(this.crlEntryExtensions=h.H$(e,iN,iI.defaultValues(iN))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ik:return new o.Integer;case iC:return new rX;case iN:return new sX;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.userCertificate||ik}),rX.schema({names:{utcTimeName:t.revocationDate||iC,generalTimeName:t.revocationDate||iC}}),sX.schema({names:{blockName:t.crlEntryExtensions||iN}},!0)]})}fromSchema(e){h.ze(e,iV);let t=o.compareSchema(e,e,iI.schema());S.assertSchema(t,this.className),this.userCertificate=t.result.userCertificate,this.revocationDate=new rX({schema:t.result.revocationDate}),iN in t.result&&(this.crlEntryExtensions=new sX({schema:t.result.crlEntryExtensions}))}toSchema(){let e=[this.userCertificate,this.revocationDate.toSchema()];return this.crlEntryExtensions&&e.push(this.crlEntryExtensions.toSchema()),new o.Sequence({value:e})}toJSON(){let e={userCertificate:this.userCertificate.toJSON(),revocationDate:this.revocationDate.toJSON()};return this.crlEntryExtensions&&(e.crlEntryExtensions=this.crlEntryExtensions.toJSON()),e}}iI.CLASS_NAME="RevokedCertificate";let iB="version",iE="signature",iH="issuer",iD="thisUpdate",iO="nextUpdate",ix="revokedCertificates",iP="crlExtensions",i$="signatureAlgorithm",iq="signatureValue",iK="tbsCertList",iR=`${iK}.version`,iJ=`${iK}.signature`,iU=`${iK}.issuer`,iT=`${iK}.thisUpdate`,ij=`${iK}.nextUpdate`,iL=`${iK}.revokedCertificates`,iM=`${iK}.extensions`,i_=[iK,iR,iJ,iU,iT,ij,iL,iM,i$,iq],iW=[eC,eo,eh,em,eg,ew,eB,ef,ed,ep];class iz extends y{constructor(e={}){super(),this.tbsView=new Uint8Array(h.H$(e,"tbs",iz.defaultValues("tbs"))),this.version=h.H$(e,iB,iz.defaultValues(iB)),this.signature=h.H$(e,iE,iz.defaultValues(iE)),this.issuer=h.H$(e,iH,iz.defaultValues(iH)),this.thisUpdate=h.H$(e,iD,iz.defaultValues(iD)),iO in e&&(this.nextUpdate=h.H$(e,iO,iz.defaultValues(iO))),ix in e&&(this.revokedCertificates=h.H$(e,ix,iz.defaultValues(ix))),iP in e&&(this.crlExtensions=h.H$(e,iP,iz.defaultValues(iP))),this.signatureAlgorithm=h.H$(e,i$,iz.defaultValues(i$)),this.signatureValue=h.H$(e,iq,iz.defaultValues(iq)),e.schema&&this.fromSchema(e.schema)}get tbs(){return c.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case"tbs":return d;case iB:return 0;case iE:return new L;case iH:return new V;case iD:case iO:return new rX;case ix:return[];case iP:return new sX;case i$:return new L;case iq:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"CertificateList",value:[function(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||iK,value:[new o.Integer({optional:!0,name:t.tbsCertListVersion||iR,value:2}),L.schema(t.signature||{names:{blockName:iJ}}),V.schema(t.issuer||{names:{blockName:iU}}),rX.schema(t.tbsCertListThisUpdate||{names:{utcTimeName:iT,generalTimeName:iT}}),rX.schema(t.tbsCertListNextUpdate||{names:{utcTimeName:ij,generalTimeName:ij}},!0),new o.Sequence({optional:!0,value:[new o.Repeated({name:t.tbsCertListRevokedCertificates||iL,value:new o.Sequence({value:[new o.Integer,rX.schema(),sX.schema({},!0)]})})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[sX.schema(t.crlExtensions||{names:{blockName:iM}})]})]})}(e),L.schema(t.signatureAlgorithm||{names:{blockName:i$}}),new o.BitString({name:t.signatureValue||iq})]})}fromSchema(e){h.ze(e,i_);let t=o.compareSchema(e,e,iz.schema());S.assertSchema(t,this.className),this.tbsView=t.result.tbsCertList.valueBeforeDecodeView,iR in t.result&&(this.version=t.result[iR].valueBlock.valueDec),this.signature=new L({schema:t.result[iJ]}),this.issuer=new V({schema:t.result[iU]}),this.thisUpdate=new rX({schema:t.result[iT]}),ij in t.result&&(this.nextUpdate=new rX({schema:t.result[ij]})),iL in t.result&&(this.revokedCertificates=Array.from(t.result[iL],e=>new iI({schema:e}))),iM in t.result&&(this.crlExtensions=new sX({schema:t.result[iM]})),this.signatureAlgorithm=new L({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){let e=[];return this.version!==iz.defaultValues(iB)&&e.push(new o.Integer({value:this.version})),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(this.thisUpdate.toSchema()),this.nextUpdate&&e.push(this.nextUpdate.toSchema()),this.revokedCertificates&&e.push(new o.Sequence({value:Array.from(this.revokedCertificates,e=>e.toSchema())})),this.crlExtensions&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.crlExtensions.toSchema()]})),new o.Sequence({value:e})}toSchema(e=!1){let t;if(e)t=this.encodeTBS();else{if(!this.tbsView.byteLength)return iz.schema();let e=o.fromBER(this.tbsView);S.assert(e,"TBS Certificate Revocation List"),t=e.result}return new o.Sequence({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){let e={tbs:c.ep.ToHex(this.tbsView),version:this.version,signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),thisUpdate:this.thisUpdate.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return this.version!==iz.defaultValues(iB)&&(e.version=this.version),this.nextUpdate&&(e.nextUpdate=this.nextUpdate.toJSON()),this.revokedCertificates&&(e.revokedCertificates=Array.from(this.revokedCertificates,e=>e.toJSON())),this.crlExtensions&&(e.crlExtensions=this.crlExtensions.toJSON()),e}isCertificateRevoked(e){if(!this.issuer.isEqual(e.issuer)||!this.revokedCertificates)return!1;for(let t of this.revokedCertificates)if(t.userCertificate.isEqual(e.serialNumber))return!0;return!1}async sign(e,t="SHA-1",a=sc(!0)){if(!e)throw Error("Need to provide a private key for signing");let s=await a.getSignatureParameters(e,t),{parameters:r}=s;this.signature=s.signatureAlgorithm,this.signatureAlgorithm=s.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());let i=await a.signWithPrivateKey(this.tbsView,e,r);this.signatureValue=new o.BitString({valueHex:i})}async verify(e={},t=sc(!0)){let a;if(e.issuerCertificate&&(a=e.issuerCertificate.subjectPublicKeyInfo,!this.issuer.isEqual(e.issuerCertificate.subject)))return!1;if(e.publicKeyInfo&&(a=e.publicKeyInfo),!a)throw Error("Issuer's certificate must be provided as an input parameter");if(this.crlExtensions){for(let e of this.crlExtensions.extensions)if(e.critical&&!iW.includes(e.extnID))return!1}return t.verifyWithPublicKey(this.tbsView,this.signatureValue,a,this.signatureAlgorithm)}}iz.CLASS_NAME="CertificateRevocationList";let iF="crlId",iG="crlValue",iQ="parsedValue",iX=[iF,iG];class iY extends y{constructor(e={}){super(),this.crlId=h.H$(e,iF,iY.defaultValues(iF)),this.crlValue=h.H$(e,iG,iY.defaultValues(iG)),iQ in e&&(this.parsedValue=h.H$(e,iQ,iY.defaultValues(iQ))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case iF:return"";case iG:return new o.Any;case iQ:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case iF:return""===t;case iG:return t instanceof o.Any;case iQ:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.id||"id"}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Any({name:t.value||"value"})]})]})}fromSchema(e){h.ze(e,iX);let t=o.compareSchema(e,e,iY.schema({names:{id:iF,value:iG}}));if(S.assertSchema(t,this.className),this.crlId=t.result.crlId.valueBlock.toString(),this.crlValue=t.result.crlValue,this.crlId===eM)this.parsedValue=iz.fromBER(this.certValue.valueBlock.valueHex);else throw Error(`Incorrect CRL_ID value in CRLBag: ${this.crlId}`)}toSchema(){return this.parsedValue&&(this.crlId=eM,this.crlValue=new o.OctetString({valueHex:this.parsedValue.toSchema().toBER(!1)})),new o.Sequence({value:[new o.ObjectIdentifier({value:this.crlId}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.crlValue.toSchema()]})]})}toJSON(){return{crlId:this.crlId,crlValue:this.crlValue.toJSON()}}}iY.CLASS_NAME="CRLBag";let iZ="version",i1="encryptedContentInfo",i0="unprotectedAttrs",i2=[iZ,i1,i0];class i3 extends y{constructor(e={}){super(),this.version=h.H$(e,iZ,i3.defaultValues(iZ)),this.encryptedContentInfo=h.H$(e,i1,i3.defaultValues(i1)),i0 in e&&(this.unprotectedAttrs=h.H$(e,i0,i3.defaultValues(i0))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case iZ:return 0;case i1:return new aX;case i0:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case iZ:return 0===t;case i1:return aX.compareWithDefault("contentType",t.contentType)&&aX.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&aX.compareWithDefault("encryptedContent",t.encryptedContent);case i0:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),aX.schema(t.encryptedContentInfo||{}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.Repeated({name:t.unprotectedAttrs||"",value:Q.schema()})]})]})}fromSchema(e){h.ze(e,i2);let t=o.compareSchema(e,e,i3.schema({names:{version:iZ,encryptedContentInfo:{names:{blockName:i1}},unprotectedAttrs:i0}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.encryptedContentInfo=new aX({schema:t.result.encryptedContentInfo}),i0 in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,e=>new Q({schema:e})))}toSchema(){let e=[];return e.push(new o.Integer({value:this.version})),e.push(this.encryptedContentInfo.toSchema()),this.unprotectedAttrs&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={version:this.version,encryptedContentInfo:this.encryptedContentInfo.toJSON()};return this.unprotectedAttrs&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,e=>e.toJSON())),e}async encrypt(e,t=sc(!0)){g.assert(e,"parameters","object");let a={...e,contentType:"1.2.840.113549.1.7.1"};this.encryptedContentInfo=await t.encryptEncryptedContentInfo(a)}async decrypt(e,t=sc(!0)){g.assert(e,"parameters","object");let a={...e,encryptedContentInfo:this.encryptedContentInfo};return t.decryptEncryptedContentInfo(a)}}i3.CLASS_NAME="EncryptedData";let i4="encryptionAlgorithm",i8="encryptedData",i5="parsedValue",i6=[i4,i8];class i9 extends y{constructor(e={}){super(),this.encryptionAlgorithm=h.H$(e,i4,i9.defaultValues(i4)),this.encryptedData=h.H$(e,i8,i9.defaultValues(i8)),i5 in e&&(this.parsedValue=h.H$(e,i5,i9.defaultValues(i5))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case i4:return new L;case i8:return new o.OctetString;case i5:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case i4:return L.compareWithDefault("algorithmId",t.algorithmId)&&"algorithmParams"in t==!1;case i8:return t.isEqual(i9.defaultValues(e));case i5:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[L.schema(t.encryptionAlgorithm||{names:{blockName:i4}}),new o.Choice({value:[new o.OctetString({name:t.encryptedData||i8}),new o.OctetString({idBlock:{isConstructed:!0},name:t.encryptedData||i8})]})]})}fromSchema(e){h.ze(e,i6);let t=o.compareSchema(e,e,i9.schema({names:{encryptionAlgorithm:{names:{blockName:i4}},encryptedData:i8}}));S.assertSchema(t,this.className),this.encryptionAlgorithm=new L({schema:t.result.encryptionAlgorithm}),this.encryptedData=t.result.encryptedData}toSchema(){return new o.Sequence({value:[this.encryptionAlgorithm.toSchema(),this.encryptedData]})}toJSON(){return{encryptionAlgorithm:this.encryptionAlgorithm.toJSON(),encryptedData:this.encryptedData.toJSON()}}async parseInternalValues(e,t=sc(!0)){let a=new i3({encryptedContentInfo:new aX({contentEncryptionAlgorithm:this.encryptionAlgorithm,encryptedContent:this.encryptedData})}),s=await a.decrypt(e,t);this.parsedValue=aW.fromBER(s)}async makeInternalValues(e,t=sc(!0)){if(!this.parsedValue)throw Error('Please initialize "parsedValue" first');let a=new i3,s={...e,contentToEncrypt:this.parsedValue.toSchema().toBER(!1)};if(await a.encrypt(s,t),!a.encryptedContentInfo.encryptedContent)throw Error("The filed `encryptedContent` in EncryptedContentInfo is empty");this.encryptionAlgorithm=a.encryptedContentInfo.contentEncryptionAlgorithm,this.encryptedData=a.encryptedContentInfo.encryptedContent}}i9.CLASS_NAME="PKCS8ShroudedKeyBag";let i7="secretTypeId",ne="secretValue",nt=[i7,ne];class na extends y{constructor(e={}){super(),this.secretTypeId=h.H$(e,i7,na.defaultValues(i7)),this.secretValue=h.H$(e,ne,na.defaultValues(ne)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case i7:return"";case ne:return new o.Any;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case i7:return""===t;case ne:return t instanceof o.Any;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.id||"id"}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Any({name:t.value||"value"})]})]})}fromSchema(e){h.ze(e,nt);let t=o.compareSchema(e,e,na.schema({names:{id:i7,value:ne}}));S.assertSchema(t,this.className),this.secretTypeId=t.result.secretTypeId.valueBlock.toString(),this.secretValue=t.result.secretValue}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.secretTypeId}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.secretValue.toSchema()]})]})}toJSON(){return{secretTypeId:this.secretTypeId,secretValue:this.secretValue.toJSON()}}}na.CLASS_NAME="SecretBag";class ns{static getItems(){return this.items||(this.items={},ns.register("1.2.840.113549.1.12.10.1.1",aW),ns.register("1.2.840.113549.1.12.10.1.2",i9),ns.register("1.2.840.113549.1.12.10.1.3",iA),ns.register("1.2.840.113549.1.12.10.1.4",iY),ns.register("1.2.840.113549.1.12.10.1.5",na),ns.register("1.2.840.113549.1.12.10.1.6",nc)),this.items}static register(e,t){this.getItems()[e]=t}static find(e){return this.getItems()[e]||null}}let nr="bagId",ni="bagValue",nn="bagAttributes",nu=[nr,ni,nn];class nl extends y{constructor(e={}){super(),this.bagId=h.H$(e,nr,nl.defaultValues(nr)),this.bagValue=h.H$(e,ni,nl.defaultValues(ni)),nn in e&&(this.bagAttributes=h.H$(e,nn,nl.defaultValues(nn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nr:return"";case ni:return new o.Any;case nn:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nr:return""===t;case ni:return t instanceof o.Any;case nn:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.bagId||nr}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Any({name:t.bagValue||ni})]}),new o.Set({optional:!0,value:[new o.Repeated({name:t.bagAttributes||nn,value:Q.schema()})]})]})}fromSchema(e){h.ze(e,nu);let t=o.compareSchema(e,e,nl.schema({names:{bagId:nr,bagValue:ni,bagAttributes:nn}}));S.assertSchema(t,this.className),this.bagId=t.result.bagId.valueBlock.toString();let a=ns.find(this.bagId);if(!a)throw Error(`Invalid BAG_ID for SafeBag: ${this.bagId}`);this.bagValue=new a({schema:t.result.bagValue}),nn in t.result&&(this.bagAttributes=Array.from(t.result.bagAttributes,e=>new Q({schema:e})))}toSchema(){let e=[new o.ObjectIdentifier({value:this.bagId}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.bagValue.toSchema()]})];return this.bagAttributes&&e.push(new o.Set({value:Array.from(this.bagAttributes,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={bagId:this.bagId,bagValue:this.bagValue.toJSON()};return this.bagAttributes&&(e.bagAttributes=Array.from(this.bagAttributes,e=>e.toJSON())),e}}nl.CLASS_NAME="SafeBag";let no="safeBags";class nc extends y{constructor(e={}){super(),this.safeBags=h.H$(e,no,nc.defaultValues(no)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===no?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===no?0===t.length:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.safeBags||"",value:nl.schema()})]})}fromSchema(e){h.ze(e,[no]);let t=o.compareSchema(e,e,nc.schema({names:{safeBags:no}}));S.assertSchema(t,this.className),this.safeBags=Array.from(t.result.safeBags,e=>new nl({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.safeBags,e=>e.toSchema())})}toJSON(){return{safeBags:Array.from(this.safeBags,e=>e.toJSON())}}}nc.CLASS_NAME="SafeContents";let nh="otherCertFormat",nm="otherCert",nf=[nh,nm];class nd extends y{constructor(e={}){super(),this.otherCertFormat=h.H$(e,nh,nd.defaultValues(nh)),this.otherCert=h.H$(e,nm,nd.defaultValues(nm)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nh:return"";case nm:return new o.Any;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.otherCertFormat||nh}),new o.Any({name:t.otherCert||nm})]})}fromSchema(e){h.ze(e,nf);let t=o.compareSchema(e,e,nd.schema());S.assertSchema(t,this.className),this.otherCertFormat=t.result.otherCertFormat.valueBlock.toString(),this.otherCert=t.result.otherCert}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.otherCertFormat}),this.otherCert]})}toJSON(){let e={otherCertFormat:this.otherCertFormat};return this.otherCert instanceof o.Any||(e.otherCert=this.otherCert.toJSON()),e}}let ng="certificates",np=[ng];class nS extends y{constructor(e={}){super(),this.certificates=h.H$(e,ng,nS.defaultValues(ng)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===ng?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Set({name:t.blockName||"",value:[new o.Repeated({name:t.certificates||ng,value:new o.Choice({value:[ip.schema(),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Any]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new o.Sequence]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:rT.schema().valueBlock.value}),new o.Constructed({idBlock:{tagClass:3,tagNumber:3},value:nd.schema().valueBlock.value})]})})]})}fromSchema(e){h.ze(e,np);let t=o.compareSchema(e,e,nS.schema());S.assertSchema(t,this.className),this.certificates=Array.from(t.result.certificates||[],e=>{let t=e.idBlock.tagNumber;if(1===e.idBlock.tagClass)return new ip({schema:e});let a=new o.Sequence({value:e.valueBlock.value});switch(t){case 1:if(1===a.valueBlock.value[0].valueBlock.value[0].valueBlock.valueDec)return new rT({schema:a});return new ro({schema:a});case 2:return new rT({schema:a});case 3:return new nd({schema:a})}return e})}toSchema(){return new o.Set({value:Array.from(this.certificates,e=>{switch(!0){case e instanceof ip:break;case e instanceof ro:return new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:e.toSchema().valueBlock.value});case e instanceof rT:return new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:e.toSchema().valueBlock.value});case e instanceof nd:return new o.Constructed({idBlock:{tagClass:3,tagNumber:3},value:e.toSchema().valueBlock.value})}return e.toSchema()})})}toJSON(){return{certificates:Array.from(this.certificates,e=>e.toJSON())}}}nS.CLASS_NAME="CertificateSet";let ny="otherRevInfoFormat",nw="otherRevInfo",nv=[ny,nw];class nb extends y{constructor(e={}){super(),this.otherRevInfoFormat=h.H$(e,ny,nb.defaultValues(ny)),this.otherRevInfo=h.H$(e,nw,nb.defaultValues(nw)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ny:return"";case nw:return new o.Any;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.otherRevInfoFormat||ny}),new o.Any({name:t.otherRevInfo||nw})]})}fromSchema(e){h.ze(e,nv);let t=o.compareSchema(e,e,nb.schema());S.assertSchema(t,this.className),this.otherRevInfoFormat=t.result.otherRevInfoFormat.valueBlock.toString(),this.otherRevInfo=t.result.otherRevInfo}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.otherRevInfoFormat}),this.otherRevInfo]})}toJSON(){let e={otherRevInfoFormat:this.otherRevInfoFormat};return this.otherRevInfo instanceof o.Any||(e.otherRevInfo=this.otherRevInfo.toJSON()),e}}nb.CLASS_NAME="OtherRevocationInfoFormat";let nA="crls",nk="otherRevocationInfos",nC=[nA];class nN extends y{constructor(e={}){super(),this.crls=h.H$(e,nA,nN.defaultValues(nA)),this.otherRevocationInfos=h.H$(e,nk,nN.defaultValues(nk)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nA:case nk:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Set({name:t.blockName||"",value:[new o.Repeated({name:t.crls||"",value:new o.Choice({value:[iz.schema(),new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new o.ObjectIdentifier,new o.Any]})]})})]})}fromSchema(e){h.ze(e,nC);let t=o.compareSchema(e,e,nN.schema({names:{crls:nA}}));if(S.assertSchema(t,this.className),t.result.crls)for(let e of t.result.crls)1===e.idBlock.tagClass?this.crls.push(new iz({schema:e})):this.otherRevocationInfos.push(new nb({schema:e}))}toSchema(){let e=[];return e.push(...Array.from(this.crls,e=>e.toSchema())),e.push(...Array.from(this.otherRevocationInfos,e=>{let t=e.toSchema();return t.idBlock.tagClass=3,t.idBlock.tagNumber=1,t})),new o.Set({value:e})}toJSON(){return{crls:Array.from(this.crls,e=>e.toJSON()),otherRevocationInfos:Array.from(this.otherRevocationInfos,e=>e.toJSON())}}}nN.CLASS_NAME="RevocationInfoChoices";let nV="certs",nI="crls",nB=[nV,nI];class nE extends y{constructor(e={}){super(),this.crls=h.H$(e,nI,nE.defaultValues(nI)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nV:return new nS;case nI:return new nN;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nV:return 0===t.certificates.length;case nI:return 0===t.crls.length&&0===t.otherRevocationInfos.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Constructed({name:t.certs||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:nS.schema().valueBlock.value}),new o.Constructed({name:t.crls||"",optional:!0,idBlock:{tagClass:3,tagNumber:1},value:nN.schema().valueBlock.value})]})}fromSchema(e){h.ze(e,nB);let t=o.compareSchema(e,e,nE.schema({names:{certs:nV,crls:nI}}));S.assertSchema(t,this.className),nV in t.result&&(this.certs=new nS({schema:new o.Set({value:t.result.certs.valueBlock.value})})),nI in t.result&&(this.crls=new nN({schema:new o.Set({value:t.result.crls.valueBlock.value})}))}toSchema(){let e=[];return this.certs&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.certs.toSchema().valueBlock.value})),this.crls&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.crls.toSchema().valueBlock.value})),new o.Sequence({value:e})}toJSON(){let e={};return this.certs&&(e.certs=this.certs.toJSON()),this.crls&&(e.crls=this.crls.toJSON()),e}}nE.CLASS_NAME="OriginatorInfo";let nH="issuer",nD="serialNumber",nO=[nH,nD];class nx extends y{constructor(e={}){super(),this.issuer=h.H$(e,nH,nx.defaultValues(nH)),this.serialNumber=h.H$(e,nD,nx.defaultValues(nD)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nH:return new V;case nD:return new o.Integer;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[V.schema(t.issuer||{}),new o.Integer({name:t.serialNumber||""})]})}fromSchema(e){h.ze(e,nO);let t=o.compareSchema(e,e,nx.schema({names:{issuer:{names:{blockName:nH}},serialNumber:nD}}));S.assertSchema(t,this.className),this.issuer=new V({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber}toSchema(){return new o.Sequence({value:[this.issuer.toSchema(),this.serialNumber]})}toJSON(){return{issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()}}}nx.CLASS_NAME="IssuerAndSerialNumber";let nP="variant",n$="value",nq=["blockName"];class nK extends y{constructor(e={}){super(),this.variant=h.H$(e,nP,nK.defaultValues(nP)),n$ in e&&(this.value=h.H$(e,n$,nK.defaultValues(n$))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nP:return -1;case n$:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nP:return -1===t;case n$:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Choice({value:[nx.schema({names:{blockName:t.blockName||""}}),new o.Primitive({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:0}})]})}fromSchema(e){h.ze(e,nq);let t=o.compareSchema(e,e,nK.schema({names:{blockName:"blockName"}}));S.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new nx({schema:t.result.blockName})):(this.variant=2,this.value=new o.OctetString({valueHex:t.result.blockName.valueBlock.valueHex}))}toSchema(){switch(this.variant){case 1:if(!(this.value instanceof nx))throw Error("Incorrect type of RecipientIdentifier.value. It should be IssuerAndSerialNumber.");return this.value.toSchema();case 2:if(!(this.value instanceof o.OctetString))throw Error("Incorrect type of RecipientIdentifier.value. It should be ASN.1 OctetString.");return new o.Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:this.value.valueBlock.valueHexView});default:return new o.Any}}toJSON(){let e={variant:this.variant};return(1===this.variant||2===this.variant)&&this.value&&(e.value=this.value.toJSON()),e}}nK.CLASS_NAME="RecipientIdentifier";let nR="version",nJ="keyEncryptionAlgorithm",nU="encryptedKey",nT="recipientCertificate",nj=[nR,"rid",nJ,nU];class nL extends y{constructor(e={}){super(),this.version=h.H$(e,nR,nL.defaultValues(nR)),this.rid=h.H$(e,"rid",nL.defaultValues("rid")),this.keyEncryptionAlgorithm=h.H$(e,nJ,nL.defaultValues(nJ)),this.encryptedKey=h.H$(e,nU,nL.defaultValues(nU)),this.recipientCertificate=h.H$(e,nT,nL.defaultValues(nT)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nR:return -1;case"rid":return{};case nJ:return new L;case nU:return new o.OctetString;case nT:return new ip;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nR:return t===nL.defaultValues(nR);case"rid":return 0===Object.keys(t).length;case nJ:case nU:return t.isEqual(nL.defaultValues(e));case nT:return!1;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),nK.schema(t.rid||{}),L.schema(t.keyEncryptionAlgorithm||{}),new o.OctetString({name:t.encryptedKey||""})]})}fromSchema(e){h.ze(e,nj);let t=o.compareSchema(e,e,nL.schema({names:{version:nR,rid:{names:{blockName:"rid"}},keyEncryptionAlgorithm:{names:{blockName:nJ}},encryptedKey:nU}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,3===t.result.rid.idBlock.tagClass?this.rid=new o.OctetString({valueHex:t.result.rid.valueBlock.valueHex}):this.rid=new nx({schema:t.result.rid}),this.keyEncryptionAlgorithm=new L({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){let e=[];return this.rid instanceof nx?(this.version=0,e.push(new o.Integer({value:this.version})),e.push(this.rid.toSchema())):(this.version=2,e.push(new o.Integer({value:this.version})),e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:this.rid.valueBlock.valueHexView}))),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new o.Sequence({value:e})}toJSON(){return{version:this.version,rid:this.rid.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}nL.CLASS_NAME="KeyTransRecipientInfo";let nM="algorithm",n_="publicKey",nW=[nM,n_];class nz extends y{constructor(e={}){super(),this.algorithm=h.H$(e,nM,nz.defaultValues(nM)),this.publicKey=h.H$(e,n_,nz.defaultValues(n_)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nM:return new L;case n_:return new o.BitString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nM:case n_:return t.isEqual(nz.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[L.schema(t.algorithm||{}),new o.BitString({name:t.publicKey||""})]})}fromSchema(e){h.ze(e,nW);let t=o.compareSchema(e,e,nz.schema({names:{algorithm:{names:{blockName:nM}},publicKey:n_}}));S.assertSchema(t,this.className),this.algorithm=new L({schema:t.result.algorithm}),this.publicKey=t.result.publicKey}toSchema(){return new o.Sequence({value:[this.algorithm.toSchema(),this.publicKey]})}toJSON(){return{algorithm:this.algorithm.toJSON(),publicKey:this.publicKey.toJSON()}}}nz.CLASS_NAME="OriginatorPublicKey";let nF="variant",nG="value",nQ=["blockName"];class nX extends y{constructor(e={}){super(),this.variant=h.H$(e,nF,nX.defaultValues(nF)),nG in e&&(this.value=h.H$(e,nG,nX.defaultValues(nG))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nF:return -1;case nG:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nF:return -1===t;case nG:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Choice({value:[nx.schema({names:{blockName:t.blockName||""}}),new o.Primitive({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||""}),new o.Constructed({idBlock:{tagClass:3,tagNumber:1},name:t.blockName||"",value:nz.schema().valueBlock.value})]})}fromSchema(e){h.ze(e,nQ);let t=o.compareSchema(e,e,nX.schema({names:{blockName:"blockName"}}));S.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new nx({schema:t.result.blockName})):0===t.result.blockName.idBlock.tagNumber?(t.result.blockName.idBlock.tagClass=1,t.result.blockName.idBlock.tagNumber=4,this.variant=2,this.value=t.result.blockName):(this.variant=3,this.value=new nz({schema:new o.Sequence({value:t.result.blockName.valueBlock.value})}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return this.value.idBlock.tagClass=3,this.value.idBlock.tagNumber=0,this.value;case 3:{let e=this.value.toSchema();return e.idBlock.tagClass=3,e.idBlock.tagNumber=1,e}default:return new o.Any}}toJSON(){let e={variant:this.variant};return(1===this.variant||2===this.variant||3===this.variant)&&(e.value=this.value.toJSON()),e}}nX.CLASS_NAME="OriginatorIdentifierOrKey";let nY="keyAttrId",nZ="keyAttr",n1=[nY,nZ];class n0 extends y{constructor(e={}){super(),this.keyAttrId=h.H$(e,nY,n0.defaultValues(nY)),nZ in e&&(this.keyAttr=h.H$(e,nZ,n0.defaultValues(nZ))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nY:return"";case nZ:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nY:return"string"==typeof t&&""===t;case nZ:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({optional:t.optional||!0,name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.keyAttrId||""}),new o.Any({optional:!0,name:t.keyAttr||""})]})}fromSchema(e){h.ze(e,n1);let t=o.compareSchema(e,e,n0.schema({names:{keyAttrId:nY,keyAttr:nZ}}));S.assertSchema(t,this.className),this.keyAttrId=t.result.keyAttrId.valueBlock.toString(),nZ in t.result&&(this.keyAttr=t.result.keyAttr)}toSchema(){let e=[];return e.push(new o.ObjectIdentifier({value:this.keyAttrId})),nZ in this&&e.push(this.keyAttr),new o.Sequence({value:e})}toJSON(){let e={keyAttrId:this.keyAttrId};return nZ in this&&(e.keyAttr=this.keyAttr.toJSON()),e}}n0.CLASS_NAME="OtherKeyAttribute";let n2="subjectKeyIdentifier",n3="date",n4="other",n8=[n2,n3,n4];class n5 extends y{constructor(e={}){super(),this.subjectKeyIdentifier=h.H$(e,n2,n5.defaultValues(n2)),n3 in e&&(this.date=h.H$(e,n3,n5.defaultValues(n3))),n4 in e&&(this.other=h.H$(e,n4,n5.defaultValues(n4))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case n2:return new o.OctetString;case n3:return new o.GeneralizedTime;case n4:return new n0;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case n2:return t.isEqual(n5.defaultValues(n2));case n3:return 0===t.year&&0===t.month&&0===t.day&&0===t.hour&&0===t.minute&&0===t.second&&0===t.millisecond;case n4:return""===t.keyAttrId&&"keyAttr"in t==!1;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.OctetString({name:t.subjectKeyIdentifier||""}),new o.GeneralizedTime({optional:!0,name:t.date||""}),n0.schema(t.other||{})]})}fromSchema(e){h.ze(e,n8);let t=o.compareSchema(e,e,n5.schema({names:{subjectKeyIdentifier:n2,date:n3,other:{names:{blockName:n4}}}}));S.assertSchema(t,this.className),this.subjectKeyIdentifier=t.result.subjectKeyIdentifier,n3 in t.result&&(this.date=t.result.date),n4 in t.result&&(this.other=new n0({schema:t.result.other}))}toSchema(){let e=[];return e.push(this.subjectKeyIdentifier),this.date&&e.push(this.date),this.other&&e.push(this.other.toSchema()),new o.Sequence({value:e})}toJSON(){let e={subjectKeyIdentifier:this.subjectKeyIdentifier.toJSON()};return this.date&&(e.date=this.date.toJSON()),this.other&&(e.other=this.other.toJSON()),e}}n5.CLASS_NAME="RecipientKeyIdentifier";let n6="variant",n9="value",n7=["blockName"];class ue extends y{constructor(e={}){super(),this.variant=h.H$(e,n6,ue.defaultValues(n6)),this.value=h.H$(e,n9,ue.defaultValues(n9)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case n6:return -1;case n9:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case n6:return -1===t;case n9:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Choice({value:[nx.schema(t.issuerAndSerialNumber||{names:{blockName:t.blockName||""}}),new o.Constructed({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:0},value:n5.schema(t.rKeyId||{names:{blockName:t.blockName||""}}).valueBlock.value})]})}fromSchema(e){h.ze(e,n7);let t=o.compareSchema(e,e,ue.schema({names:{blockName:"blockName"}}));S.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new nx({schema:t.result.blockName})):(this.variant=2,this.value=new n5({schema:new o.Sequence({value:t.result.blockName.valueBlock.value})}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.value.toSchema().valueBlock.value});default:return new o.Any}}toJSON(){let e={variant:this.variant};return(1===this.variant||2===this.variant)&&(e.value=this.value.toJSON()),e}}ue.CLASS_NAME="KeyAgreeRecipientIdentifier";let ut="encryptedKey",ua=["rid",ut];class us extends y{constructor(e={}){super(),this.rid=h.H$(e,"rid",us.defaultValues("rid")),this.encryptedKey=h.H$(e,ut,us.defaultValues(ut)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"rid":return new ue;case ut:return new o.OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"rid":return -1===t.variant&&"value"in t==!1;case ut:return t.isEqual(us.defaultValues(ut));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[ue.schema(t.rid||{}),new o.OctetString({name:t.encryptedKey||""})]})}fromSchema(e){h.ze(e,ua);let t=o.compareSchema(e,e,us.schema({names:{rid:{names:{blockName:"rid"}},encryptedKey:ut}}));S.assertSchema(t,this.className),this.rid=new ue({schema:t.result.rid}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new o.Sequence({value:[this.rid.toSchema(),this.encryptedKey]})}toJSON(){return{rid:this.rid.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}us.CLASS_NAME="RecipientEncryptedKey";let ur="encryptedKeys",ui="RecipientEncryptedKeys",un=[ui];class uu extends y{constructor(e={}){super(),this.encryptedKeys=h.H$(e,ur,uu.defaultValues(ur)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===ur?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===ur?0===t.length:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.RecipientEncryptedKeys||"",value:us.schema()})]})}fromSchema(e){h.ze(e,un);let t=o.compareSchema(e,e,uu.schema({names:{RecipientEncryptedKeys:ui}}));S.assertSchema(t,this.className),this.encryptedKeys=Array.from(t.result.RecipientEncryptedKeys,e=>new us({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.encryptedKeys,e=>e.toSchema())})}toJSON(){return{encryptedKeys:Array.from(this.encryptedKeys,e=>e.toJSON())}}}uu.CLASS_NAME="RecipientEncryptedKeys";let ul="version",uo="originator",uc="keyEncryptionAlgorithm",uh="recipientEncryptedKeys",um="recipientCertificate",uf="recipientPublicKey",ud=[ul,uo,"ukm",uc,uh];class ug extends y{constructor(e={}){super(),this.version=h.H$(e,ul,ug.defaultValues(ul)),this.originator=h.H$(e,uo,ug.defaultValues(uo)),"ukm"in e&&(this.ukm=h.H$(e,"ukm",ug.defaultValues("ukm"))),this.keyEncryptionAlgorithm=h.H$(e,uc,ug.defaultValues(uc)),this.recipientEncryptedKeys=h.H$(e,uh,ug.defaultValues(uh)),this.recipientCertificate=h.H$(e,um,ug.defaultValues(um)),this.recipientPublicKey=h.H$(e,uf,ug.defaultValues(uf)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ul:return 0;case uo:return new nX;case"ukm":return new o.OctetString;case uc:return new L;case uh:return new uu;case um:return new ip;case uf:return null;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ul:return 0===t;case uo:return -1===t.variant&&"value"in t==!1;case"ukm":return t.isEqual(ug.defaultValues("ukm"));case uc:return""===t.algorithmId&&"algorithmParams"in t==!1;case uh:return 0===t.encryptedKeys.length;case um:case uf:return!1;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[nX.schema(t.originator||{})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.OctetString({name:t.ukm||""})]}),L.schema(t.keyEncryptionAlgorithm||{}),uu.schema(t.recipientEncryptedKeys||{})]})}fromSchema(e){h.ze(e,ud);let t=o.compareSchema(e,e,ug.schema({names:{version:ul,originator:{names:{blockName:uo}},ukm:"ukm",keyEncryptionAlgorithm:{names:{blockName:uc}},recipientEncryptedKeys:{names:{blockName:uh}}}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.originator=new nX({schema:t.result.originator}),"ukm"in t.result&&(this.ukm=t.result.ukm),this.keyEncryptionAlgorithm=new L({schema:t.result.keyEncryptionAlgorithm}),this.recipientEncryptedKeys=new uu({schema:t.result.recipientEncryptedKeys})}toSchema(){let e=[];return e.push(new o.Integer({value:this.version})),e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.originator.toSchema()]})),this.ukm&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[this.ukm]})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.recipientEncryptedKeys.toSchema()),new o.Sequence({value:e})}toJSON(){let e={version:this.version,originator:this.originator.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),recipientEncryptedKeys:this.recipientEncryptedKeys.toJSON()};return this.ukm&&(e.ukm=this.ukm.toJSON()),e}}ug.CLASS_NAME="KeyAgreeRecipientInfo";let up="keyIdentifier",uS="date",uy="other",uw=[up,uS,uy];class uv extends y{constructor(e={}){super(),this.keyIdentifier=h.H$(e,up,uv.defaultValues(up)),uS in e&&(this.date=h.H$(e,uS,uv.defaultValues(uS))),uy in e&&(this.other=h.H$(e,uy,uv.defaultValues(uy))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case up:return new o.OctetString;case uS:return new o.GeneralizedTime;case uy:return new n0;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case up:return t.isEqual(uv.defaultValues(up));case uS:return 0===t.year&&0===t.month&&0===t.day&&0===t.hour&&0===t.minute&&0===t.second&&0===t.millisecond;case uy:return t.compareWithDefault("keyAttrId",t.keyAttrId)&&"keyAttr"in t==!1;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.OctetString({name:t.keyIdentifier||""}),new o.GeneralizedTime({optional:!0,name:t.date||""}),n0.schema(t.other||{})]})}fromSchema(e){h.ze(e,uw);let t=o.compareSchema(e,e,uv.schema({names:{keyIdentifier:up,date:uS,other:{names:{blockName:uy}}}}));S.assertSchema(t,this.className),this.keyIdentifier=t.result.keyIdentifier,uS in t.result&&(this.date=t.result.date),uy in t.result&&(this.other=new n0({schema:t.result.other}))}toSchema(){let e=[];return e.push(this.keyIdentifier),this.date&&e.push(this.date),this.other&&e.push(this.other.toSchema()),new o.Sequence({value:e})}toJSON(){let e={keyIdentifier:this.keyIdentifier.toJSON()};return this.date&&(e.date=this.date),this.other&&(e.other=this.other.toJSON()),e}}uv.CLASS_NAME="KEKIdentifier";let ub="version",uA="kekid",uk="keyEncryptionAlgorithm",uC="encryptedKey",uN="preDefinedKEK",uV=[ub,uA,uk,uC];class uI extends y{constructor(e={}){super(),this.version=h.H$(e,ub,uI.defaultValues(ub)),this.kekid=h.H$(e,uA,uI.defaultValues(uA)),this.keyEncryptionAlgorithm=h.H$(e,uk,uI.defaultValues(uk)),this.encryptedKey=h.H$(e,uC,uI.defaultValues(uC)),this.preDefinedKEK=h.H$(e,uN,uI.defaultValues(uN)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ub:return 0;case uA:return new uv;case uk:return new L;case uC:return new o.OctetString;case uN:return d;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"KEKRecipientInfo":return t===uI.defaultValues(ub);case uA:return t.compareWithDefault("keyIdentifier",t.keyIdentifier)&&"date"in t==!1&&"other"in t==!1;case uk:return""===t.algorithmId&&"algorithmParams"in t==!1;case uC:return t.isEqual(uI.defaultValues(uC));case uN:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),uv.schema(t.kekid||{}),L.schema(t.keyEncryptionAlgorithm||{}),new o.OctetString({name:t.encryptedKey||""})]})}fromSchema(e){h.ze(e,uV);let t=o.compareSchema(e,e,uI.schema({names:{version:ub,kekid:{names:{blockName:uA}},keyEncryptionAlgorithm:{names:{blockName:uk}},encryptedKey:uC}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.kekid=new uv({schema:t.result.kekid}),this.keyEncryptionAlgorithm=new L({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new o.Sequence({value:[new o.Integer({value:this.version}),this.kekid.toSchema(),this.keyEncryptionAlgorithm.toSchema(),this.encryptedKey]})}toJSON(){return{version:this.version,kekid:this.kekid.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}uI.CLASS_NAME="KEKRecipientInfo";let uB="version",uE="keyDerivationAlgorithm",uH="keyEncryptionAlgorithm",uD="encryptedKey",uO="password",ux=[uB,uE,uH,uD];class uP extends y{constructor(e={}){super(),this.version=h.H$(e,uB,uP.defaultValues(uB)),uE in e&&(this.keyDerivationAlgorithm=h.H$(e,uE,uP.defaultValues(uE))),this.keyEncryptionAlgorithm=h.H$(e,uH,uP.defaultValues(uH)),this.encryptedKey=h.H$(e,uD,uP.defaultValues(uD)),this.password=h.H$(e,uO,uP.defaultValues(uO)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case uB:return -1;case uE:case uH:return new L;case uD:return new o.OctetString;case uO:return d;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case uB:return -1===t;case uE:case uH:return""===t.algorithmId&&"algorithmParams"in t==!1;case uD:return t.isEqual(uP.defaultValues(uD));case uO:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),new o.Constructed({name:t.keyDerivationAlgorithm||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:L.schema().valueBlock.value}),L.schema(t.keyEncryptionAlgorithm||{}),new o.OctetString({name:t.encryptedKey||""})]})}fromSchema(e){h.ze(e,ux);let t=o.compareSchema(e,e,uP.schema({names:{version:uB,keyDerivationAlgorithm:uE,keyEncryptionAlgorithm:{names:{blockName:uH}},encryptedKey:uD}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,uE in t.result&&(this.keyDerivationAlgorithm=new L({schema:new o.Sequence({value:t.result.keyDerivationAlgorithm.valueBlock.value})})),this.keyEncryptionAlgorithm=new L({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){let e=[];return e.push(new o.Integer({value:this.version})),this.keyDerivationAlgorithm&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.keyDerivationAlgorithm.toSchema().valueBlock.value})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new o.Sequence({value:e})}toJSON(){let e={version:this.version,keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()};return this.keyDerivationAlgorithm&&(e.keyDerivationAlgorithm=this.keyDerivationAlgorithm.toJSON()),e}}uP.CLASS_NAME="PasswordRecipientInfo";let u$="oriType",uq="oriValue",uK=[u$,uq];class uR extends y{constructor(e={}){super(),this.oriType=h.H$(e,u$,uR.defaultValues(u$)),this.oriValue=h.H$(e,uq,uR.defaultValues(uq)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case u$:return"";case uq:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case u$:return""===t;case uq:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.oriType||""}),new o.Any({name:t.oriValue||""})]})}fromSchema(e){h.ze(e,uK);let t=o.compareSchema(e,e,uR.schema({names:{oriType:u$,oriValue:uq}}));S.assertSchema(t,this.className),this.oriType=t.result.oriType.valueBlock.toString(),this.oriValue=t.result.oriValue}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.oriType}),this.oriValue]})}toJSON(){let e={oriType:this.oriType};return uR.compareWithDefault(uq,this.oriValue)||(e.oriValue=this.oriValue.toJSON()),e}}uR.CLASS_NAME="OtherRecipientInfo";let uJ="variant",uU="value",uT=["blockName"];class uj extends y{constructor(e={}){super(),this.variant=h.H$(e,uJ,uj.defaultValues(uJ)),uU in e&&(this.value=h.H$(e,uU,uj.defaultValues(uU))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case uJ:return -1;case uU:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case uJ:return t===uj.defaultValues(e);case uU:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Choice({value:[nL.schema({names:{blockName:t.blockName||""}}),new o.Constructed({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:1},value:ug.schema().valueBlock.value}),new o.Constructed({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:2},value:uI.schema().valueBlock.value}),new o.Constructed({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:3},value:uP.schema().valueBlock.value}),new o.Constructed({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:4},value:uR.schema().valueBlock.value})]})}fromSchema(e){h.ze(e,uT);let t=o.compareSchema(e,e,uj.schema({names:{blockName:"blockName"}}));if(S.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass)this.variant=1,this.value=new nL({schema:t.result.blockName});else{let e=new o.Sequence({value:t.result.blockName.valueBlock.value});switch(t.result.blockName.idBlock.tagNumber){case 1:this.variant=2,this.value=new ug({schema:e});break;case 2:this.variant=3,this.value=new uI({schema:e});break;case 3:this.variant=4,this.value=new uP({schema:e});break;case 4:this.variant=5,this.value=new uR({schema:e});break;default:throw Error("Incorrect structure of RecipientInfo block")}}}toSchema(){p.assertEmpty(this.value,"value","RecipientInfo");let e=this.value.toSchema();switch(this.variant){case 1:return e;case 2:case 3:case 4:return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.variant-1,e;default:return new o.Any}}toJSON(){let e={variant:this.variant};return this.value&&this.variant>=1&&this.variant<=4&&(e.value=this.value.toJSON()),e}}uj.CLASS_NAME="RecipientInfo";let uL="hashAlgorithm",uM="maskGenAlgorithm",u_="pSourceAlgorithm",uW=[uL,uM,u_];class uz extends y{constructor(e={}){super(),this.hashAlgorithm=h.H$(e,uL,uz.defaultValues(uL)),this.maskGenAlgorithm=h.H$(e,uM,uz.defaultValues(uM)),this.pSourceAlgorithm=h.H$(e,u_,uz.defaultValues(u_)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case uL:return new L({algorithmId:"1.3.14.3.2.26",algorithmParams:new o.Null});case uM:return new L({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new L({algorithmId:"1.3.14.3.2.26",algorithmParams:new o.Null}).toSchema()});case u_:return new L({algorithmId:"1.2.840.113549.1.1.9",algorithmParams:new o.OctetString({valueHex:new Uint8Array([218,57,163,238,94,107,75,13,50,85,191,239,149,96,24,144,175,216,7,9]).buffer})});default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Constructed({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[L.schema(t.hashAlgorithm||{})]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[L.schema(t.maskGenAlgorithm||{})]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[L.schema(t.pSourceAlgorithm||{})]})]})}fromSchema(e){h.ze(e,uW);let t=o.compareSchema(e,e,uz.schema({names:{hashAlgorithm:{names:{blockName:uL}},maskGenAlgorithm:{names:{blockName:uM}},pSourceAlgorithm:{names:{blockName:u_}}}}));S.assertSchema(t,this.className),uL in t.result&&(this.hashAlgorithm=new L({schema:t.result.hashAlgorithm})),uM in t.result&&(this.maskGenAlgorithm=new L({schema:t.result.maskGenAlgorithm})),u_ in t.result&&(this.pSourceAlgorithm=new L({schema:t.result.pSourceAlgorithm}))}toSchema(){let e=[];return this.hashAlgorithm.isEqual(uz.defaultValues(uL))||e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(uz.defaultValues(uM))||e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.pSourceAlgorithm.isEqual(uz.defaultValues(u_))||e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:[this.pSourceAlgorithm.toSchema()]})),new o.Sequence({value:e})}toJSON(){let e={};return this.hashAlgorithm.isEqual(uz.defaultValues(uL))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(uz.defaultValues(uM))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.pSourceAlgorithm.isEqual(uz.defaultValues(u_))||(e.pSourceAlgorithm=this.pSourceAlgorithm.toJSON()),e}}uz.CLASS_NAME="RSAESOAEPParams";let uF="keyInfo",uG="entityUInfo",uQ="suppPubInfo",uX=[uF,uG,uQ];class uY extends y{constructor(e={}){super(),this.keyInfo=h.H$(e,uF,uY.defaultValues(uF)),uG in e&&(this.entityUInfo=h.H$(e,uG,uY.defaultValues(uG))),this.suppPubInfo=h.H$(e,uQ,uY.defaultValues(uQ)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case uF:return new L;case uG:case uQ:return new o.OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case uF:case uG:case uQ:return t.isEqual(uY.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[L.schema(t.keyInfo||{}),new o.Constructed({name:t.entityUInfo||"",idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[new o.OctetString]}),new o.Constructed({name:t.suppPubInfo||"",idBlock:{tagClass:3,tagNumber:2},value:[new o.OctetString]})]})}fromSchema(e){h.ze(e,uX);let t=o.compareSchema(e,e,uY.schema({names:{keyInfo:{names:{blockName:uF}},entityUInfo:uG,suppPubInfo:uQ}}));S.assertSchema(t,this.className),this.keyInfo=new L({schema:t.result.keyInfo}),uG in t.result&&(this.entityUInfo=t.result.entityUInfo.valueBlock.value[0]),this.suppPubInfo=t.result.suppPubInfo.valueBlock.value[0]}toSchema(){let e=[];return e.push(this.keyInfo.toSchema()),this.entityUInfo&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.entityUInfo]})),e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:[this.suppPubInfo]})),new o.Sequence({value:e})}toJSON(){let e={keyInfo:this.keyInfo.toJSON(),suppPubInfo:this.suppPubInfo.toJSON()};return this.entityUInfo&&(e.entityUInfo=this.entityUInfo.toJSON()),e}}uY.CLASS_NAME="ECCCMSSharedInfo";let uZ="version",u1="originatorInfo",u0="recipientInfos",u2="encryptedContentInfo",u3="unprotectedAttrs",u4=[uZ,u1,u0,u2,u3],u8={kdfAlgorithm:"SHA-512",kekEncryptionLength:256},u5={"P-256":256,"P-384":384,"P-521":528};class u6 extends y{constructor(e={}){super(),this.version=h.H$(e,uZ,u6.defaultValues(uZ)),u1 in e&&(this.originatorInfo=h.H$(e,u1,u6.defaultValues(u1))),this.recipientInfos=h.H$(e,u0,u6.defaultValues(u0)),this.encryptedContentInfo=h.H$(e,u2,u6.defaultValues(u2)),u3 in e&&(this.unprotectedAttrs=h.H$(e,u3,u6.defaultValues(u3))),this.policy={disableSplit:!!e.disableSplit},e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case uZ:return 0;case u1:return new nE;case u0:return[];case u2:return new aX;case u3:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case uZ:return t===u6.defaultValues(e);case u1:return 0===t.certs.certificates.length&&0===t.crls.crls.length;case u0:case u3:return 0===t.length;case u2:return aX.compareWithDefault("contentType",t.contentType)&&aX.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&aX.compareWithDefault("encryptedContent",t.encryptedContent);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),new o.Constructed({name:t.originatorInfo||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:nE.schema().valueBlock.value}),new o.Set({value:[new o.Repeated({name:t.recipientInfos||"",value:uj.schema()})]}),aX.schema(t.encryptedContentInfo||{}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.Repeated({name:t.unprotectedAttrs||"",value:Q.schema()})]})]})}fromSchema(e){h.ze(e,u4);let t=o.compareSchema(e,e,u6.schema({names:{version:uZ,originatorInfo:u1,recipientInfos:u0,encryptedContentInfo:{names:{blockName:u2}},unprotectedAttrs:u3}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,u1 in t.result&&(this.originatorInfo=new nE({schema:new o.Sequence({value:t.result.originatorInfo.valueBlock.value})})),this.recipientInfos=Array.from(t.result.recipientInfos,e=>new uj({schema:e})),this.encryptedContentInfo=new aX({schema:t.result.encryptedContentInfo}),u3 in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,e=>new Q({schema:e})))}toSchema(){let e=[];return e.push(new o.Integer({value:this.version})),this.originatorInfo&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:this.originatorInfo.toSchema().valueBlock.value})),e.push(new o.Set({value:Array.from(this.recipientInfos,e=>e.toSchema())})),e.push(this.encryptedContentInfo.toSchema()),this.unprotectedAttrs&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={version:this.version,recipientInfos:Array.from(this.recipientInfos,e=>e.toJSON()),encryptedContentInfo:this.encryptedContentInfo.toJSON()};return this.originatorInfo&&(e.originatorInfo=this.originatorInfo.toJSON()),this.unprotectedAttrs&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,e=>e.toJSON())),e}addRecipientByCertificate(e,t,a,s=sc(!0)){let r=Object.assign({useOAEP:!0,oaepHashAlgorithm:"SHA-512"},u8,t||{});if(-1!==e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549"))a=1;else if(-1!==e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.10045"))a=2;else throw Error(`Unknown type of certificate's public key: ${e.subjectPublicKeyInfo.algorithm.algorithmId}`);switch(a){case 1:{let t,a;if(!0===r.useOAEP){t=s.getOIDByAlgorithm({name:"RSA-OAEP"},!0,"keyEncryptionAlgorithm");let e=s.getOIDByAlgorithm({name:r.oaepHashAlgorithm},!0,"RSAES-OAEP-params"),i=new L({algorithmId:e,algorithmParams:new o.Null}),n=new uz({hashAlgorithm:i,maskGenAlgorithm:new L({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:i.toSchema()})});a=n.toSchema()}else{if(""===(t=s.getOIDByAlgorithm({name:"RSAES-PKCS1-v1_5"})))throw Error("Can not find OID for RSAES-PKCS1-v1_5");a=new o.Null}let i=new nL({version:0,rid:new nx({issuer:e.issuer,serialNumber:e.serialNumber}),keyEncryptionAlgorithm:new L({algorithmId:t,algorithmParams:a}),recipientCertificate:e});this.recipientInfos.push(new uj({variant:1,value:i}))}break;case 2:{let t=new ue({variant:1,value:new nx({issuer:e.issuer,serialNumber:e.serialNumber})});this._addKeyAgreeRecipientInfo(t,r,{recipientCertificate:e},s)}break;default:throw Error(`Unknown "variant" value: ${a}`)}return!0}addRecipientByPreDefinedData(e,t={},a,s=sc(!0)){if(g.assert(e,"preDefinedData","ArrayBuffer"),!e.byteLength)throw Error("Pre-defined data could have zero length");if(!t.keyIdentifier){let e=new ArrayBuffer(16),a=new Uint8Array(e);s.getRandomValues(a),t.keyIdentifier=e}switch(t.hmacHashAlgorithm||(t.hmacHashAlgorithm="SHA-512"),void 0===t.iterationCount&&(t.iterationCount=2048),t.keyEncryptionAlgorithm||(t.keyEncryptionAlgorithm={name:"AES-KW",length:256}),t.keyEncryptionAlgorithmParams||(t.keyEncryptionAlgorithmParams=new o.Null),a){case 1:{let a=s.getOIDByAlgorithm(t.keyEncryptionAlgorithm,!0,"keyEncryptionAlgorithm"),r=new uI({version:4,kekid:new uv({keyIdentifier:new o.OctetString({valueHex:t.keyIdentifier})}),keyEncryptionAlgorithm:new L({algorithmId:a,algorithmParams:t.keyEncryptionAlgorithmParams}),preDefinedKEK:e});this.recipientInfos.push(new uj({variant:3,value:r}))}break;case 2:{let a=s.getOIDByAlgorithm({name:"PBKDF2"},!0,"keyDerivationAlgorithm"),r=new ArrayBuffer(64),i=new Uint8Array(r);s.getRandomValues(i);let n=s.getOIDByAlgorithm({name:"HMAC",hash:{name:t.hmacHashAlgorithm}},!0,"hmacHashAlgorithm"),u=new a9({salt:new o.OctetString({valueHex:r}),iterationCount:t.iterationCount,prf:new L({algorithmId:n,algorithmParams:new o.Null})}),l=s.getOIDByAlgorithm(t.keyEncryptionAlgorithm,!0,"keyEncryptionAlgorithm"),c=new uP({version:0,keyDerivationAlgorithm:new L({algorithmId:a,algorithmParams:u.toSchema()}),keyEncryptionAlgorithm:new L({algorithmId:l,algorithmParams:t.keyEncryptionAlgorithmParams}),password:e});this.recipientInfos.push(new uj({variant:4,value:c}))}break;default:throw Error(`Unknown value for "variant": ${a}`)}}addRecipientByKeyIdentifier(e,t,a,s=sc(!0)){let r=Object.assign({},u8,a||{}),i=new ue({variant:2,value:new n5({subjectKeyIdentifier:new o.OctetString({valueHex:t})})});this._addKeyAgreeRecipientInfo(i,r,{recipientPublicKey:e},s)}_addKeyAgreeRecipientInfo(e,t,a,s=sc(!0)){let r=new us({rid:e}),i=s.getOIDByAlgorithm({name:"AES-KW",length:t.kekEncryptionLength},!0,"keyEncryptionAlgorithm"),n=new L({algorithmId:i}),u=s.getOIDByAlgorithm({name:"ECDH",kdf:t.kdfAlgorithm},!0,"KeyAgreeRecipientInfo"),l=new ArrayBuffer(64),c=new Uint8Array(l);s.getRandomValues(c);let h={version:3,ukm:new o.OctetString({valueHex:l}),keyEncryptionAlgorithm:new L({algorithmId:u,algorithmParams:n.toSchema()}),recipientEncryptedKeys:new uu({encryptedKeys:[r]})},m=new ug(Object.assign(h,a));this.recipientInfos.push(new uj({variant:2,value:m}))}async encrypt(e,t,a=sc(!0)){let s=new ArrayBuffer(16),r=new Uint8Array(s);a.getRandomValues(r);let i=new Uint8Array(t),n=a.getOIDByAlgorithm(e,!0,"contentEncryptionAlgorithm"),u=await a.generateKey(e,!0,["encrypt"]),l=await a.encrypt({name:e.name,iv:r},u,i),c=await a.exportKey("raw",u);this.version=2,this.encryptedContentInfo=new aX({disableSplit:this.policy.disableSplit,contentType:"1.2.840.113549.1.7.1",contentEncryptionAlgorithm:new L({algorithmId:n,algorithmParams:new o.OctetString({valueHex:s})}),encryptedContent:new o.OctetString({valueHex:l})});let h=async e=>{let t,s;let r=this.recipientInfos[e].value;if(r.recipientPublicKey)t=r.recipientPublicKey.algorithm.namedCurve,s=r.recipientPublicKey;else if(r.recipientCertificate){let i=r.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(i.constructor.blockName()!==o.ObjectIdentifier.blockName())throw Error(`Incorrect "recipientCertificate" for index ${e}`);let n=i.valueBlock.toString();switch(n){case"1.2.840.10045.3.1.7":t="P-256";break;case"1.3.132.0.34":t="P-384";break;case"1.3.132.0.35":t="P-521";break;default:throw Error(`Incorrect curve OID for index ${e}`)}s=await r.recipientCertificate.getPublicKey({algorithm:{algorithm:{name:"ECDH",namedCurve:t},usages:[]}},a)}else throw Error("Unsupported RecipientInfo");let i=u5[t],n=await a.generateKey({name:"ECDH",namedCurve:t},!0,["deriveBits"]),l=await a.exportKey("spki",n.publicKey),c=await a.deriveBits({name:"ECDH",public:s},n.privateKey,i),h=new L({schema:r.keyEncryptionAlgorithm.algorithmParams}),m=a.getAlgorithmByOID(h.algorithmId,!0,"aesKWAlgorithm"),f=m.length,d=new ArrayBuffer(4),g=new Uint8Array(d);for(let e=3;e>=0;e--)g[e]=f,f>>=8;let p=new uY({keyInfo:new L({algorithmId:h.algorithmId}),entityUInfo:r.ukm,suppPubInfo:new o.OctetString({valueHex:d})}),S=p.toSchema().toBER(!1),y=a.getAlgorithmByOID(r.keyEncryptionAlgorithm.algorithmId,!0,"ecdhAlgorithm"),w=await sw(y.kdf,c,m.length,S,a),v=await a.importKey("raw",w,{name:"AES-KW"},!0,["wrapKey"]),b=await a.wrapKey("raw",u,v,{name:"AES-KW"}),A=new nX;return A.variant=3,A.value=nz.fromBER(l),r.originator=A,r.recipientEncryptedKeys.encryptedKeys[0].encryptedKey=new o.OctetString({valueHex:b}),{ecdhPrivateKey:n.privateKey}},m=async e=>{let t=this.recipientInfos[e].value,s=a.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm");if("RSA-OAEP"===s.name){let e=t.keyEncryptionAlgorithm.algorithmParams,r=new uz({schema:e});if(s.hash=a.getAlgorithmByOID(r.hashAlgorithm.algorithmId),"name"in s.hash==!1)throw Error(`Incorrect OID for hash algorithm: ${r.hashAlgorithm.algorithmId}`)}try{let e=await t.recipientCertificate.getPublicKey({algorithm:{algorithm:s,usages:["encrypt","wrapKey"]}},a),r=await a.encrypt(e.algorithm,e,c);t.encryptedKey=new o.OctetString({valueHex:r})}catch{}},f=async e=>{let t=this.recipientInfos[e].value,s=a.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),r=await a.importKey("raw",new Uint8Array(t.preDefinedKEK),s,!0,["wrapKey"]),i=await a.wrapKey("raw",u,r,s);t.encryptedKey=new o.OctetString({valueHex:i})},d=async e=>{let t;let s=this.recipientInfos[e].value;if(!s.keyDerivationAlgorithm)throw Error('Please append encoded "keyDerivationAlgorithm"');if(!s.keyDerivationAlgorithm.algorithmParams)throw Error('Incorrectly encoded "keyDerivationAlgorithm"');try{t=new a9({schema:s.keyDerivationAlgorithm.algorithmParams})}catch(e){throw Error('Incorrectly encoded "keyDerivationAlgorithm"')}let r=new Uint8Array(s.password),i=await a.importKey("raw",r,"PBKDF2",!1,["deriveKey"]),n=a.getAlgorithmByOID(s.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),l="SHA-1";if(t.prf){let e=a.getAlgorithmByOID(t.prf.algorithmId,!0,"prfAlgorithm");l=e.hash.name}let c=new Uint8Array(t.salt.valueBlock.valueHex),h=t.iterationCount,m=await a.deriveKey({name:"PBKDF2",hash:{name:l},salt:c,iterations:h},i,n,!0,["wrapKey"]),f=await a.wrapKey("raw",u,m,n);s.encryptedKey=new o.OctetString({valueHex:f})},g=[];for(let e=0;e<this.recipientInfos.length;e++)switch(this.recipientInfos[e].variant){case 1:g.push(await m(e));break;case 2:g.push(await h(e));break;case 3:g.push(await f(e));break;case 4:g.push(await d(e));break;default:throw Error(`Unknown recipient type in array with index ${e}`)}return g}async decrypt(e,t,a=sc(!0)){let s;let r=t||{};if(e+1>this.recipientInfos.length)throw Error(`Maximum value for "index" is: ${this.recipientInfos.length-1}`);let i=async e=>{let t,s,i,n;let u=this.recipientInfos[e].value,l=u.originator;if(r.recipientCertificate){let a=r.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(a.constructor.blockName()!==o.ObjectIdentifier.blockName())throw Error(`Incorrect "recipientCertificate" for index ${e}`);t=a.valueBlock.toString()}else if(l.value.algorithm.algorithmParams){let a=l.value.algorithm.algorithmParams;if(a.constructor.blockName()!==o.ObjectIdentifier.blockName())throw Error(`Incorrect originator for index ${e}`);t=a.valueBlock.toString()}else throw Error('Parameter "recipientCertificate" is mandatory for "KeyAgreeRecipientInfo" if algorithm params are missing from originator');if(!r.recipientPrivateKey)throw Error('Parameter "recipientPrivateKey" is mandatory for "KeyAgreeRecipientInfo"');switch(t){case"1.2.840.10045.3.1.7":s="P-256",i=256;break;case"1.3.132.0.34":s="P-384",i=384;break;case"1.3.132.0.35":s="P-521",i=528;break;default:throw Error(`Incorrect curve OID for index ${e}`)}let h=a;c.vJ.isBufferSource(r.recipientPrivateKey)?n=await a.importKey("pkcs8",r.recipientPrivateKey,{name:"ECDH",namedCurve:s},!0,["deriveBits"]):(n=r.recipientPrivateKey,"crypto"in r&&r.crypto&&(h=r.crypto.subtle)),"algorithmParams"in l.value.algorithm==!1&&(l.value.algorithm.algorithmParams=new o.ObjectIdentifier({value:t}));let m=l.value.toSchema().toBER(!1),f=await a.importKey("spki",m,{name:"ECDH",namedCurve:s},!0,[]),d=await h.deriveBits({name:"ECDH",public:f},n,i);async function g(e){e=e||!1;let t=new L({schema:u.keyEncryptionAlgorithm.algorithmParams}),s=a.getAlgorithmByOID(t.algorithmId,!0,"kwAlgorithm"),r=s.length,i=new ArrayBuffer(4),n=new Uint8Array(i);for(let e=3;e>=0;e--)n[e]=r,r>>=8;let l={algorithmId:t.algorithmId};e&&(l.algorithmParams=new o.Null);let c=new uY({keyInfo:new L(l),entityUInfo:u.ukm,suppPubInfo:new o.OctetString({valueHex:i})}),h=c.toSchema().toBER(!1),m=a.getAlgorithmByOID(u.keyEncryptionAlgorithm.algorithmId,!0,"ecdhAlgorithm");if(!m.name)throw Error(`Incorrect OID for key encryption algorithm: ${u.keyEncryptionAlgorithm.algorithmId}`);return sw(m.kdf,d,s.length,h,a)}let p=await g(),S=async e=>a.importKey("raw",e,{name:"AES-KW"},!0,["unwrapKey"]),y=await S(p),w=async e=>{let t=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,s=a.getAlgorithmByOID(t,!0,"contentEncryptionAlgorithm");return a.unwrapKey("raw",u.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHexView,e,{name:"AES-KW"},s,!0,["decrypt"])};try{return await w(y)}catch{let e=await g(!0),t=await S(e);return w(t)}},n=async e=>{let t;let s=this.recipientInfos[e].value;if(!r.recipientPrivateKey)throw Error('Parameter "recipientPrivateKey" is mandatory for "KeyTransRecipientInfo"');let i=a.getAlgorithmByOID(s.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm");if("RSA-OAEP"===i.name){let e=s.keyEncryptionAlgorithm.algorithmParams,t=new uz({schema:e});if(i.hash=a.getAlgorithmByOID(t.hashAlgorithm.algorithmId),"name"in i.hash==!1)throw Error(`Incorrect OID for hash algorithm: ${t.hashAlgorithm.algorithmId}`)}let n=a;c.vJ.isBufferSource(r.recipientPrivateKey)?t=await a.importKey("pkcs8",r.recipientPrivateKey,i,!0,["decrypt"]):(t=r.recipientPrivateKey,"crypto"in r&&r.crypto&&(n=r.crypto.subtle));let u=await n.decrypt(t.algorithm,t,s.encryptedKey.valueBlock.valueHexView),l=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,o=a.getAlgorithmByOID(l,!0,"contentEncryptionAlgorithm");if("name"in o==!1)throw Error(`Incorrect "contentEncryptionAlgorithm": ${l}`);return a.importKey("raw",u,o,!0,["decrypt"])},u=async e=>{let t=this.recipientInfos[e].value;if(!r.preDefinedData)throw Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');let s=a.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),i=await a.importKey("raw",r.preDefinedData,s,!0,["unwrapKey"]),n=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,u=a.getAlgorithmByOID(n,!0,"contentEncryptionAlgorithm");if(!u.name)throw Error(`Incorrect "contentEncryptionAlgorithm": ${n}`);return a.unwrapKey("raw",t.encryptedKey.valueBlock.valueHexView,i,s,u,!0,["decrypt"])},l=async e=>{let t;let s=this.recipientInfos[e].value;if(!r.preDefinedData)throw Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');if(!s.keyDerivationAlgorithm)throw Error('Please append encoded "keyDerivationAlgorithm"');if(!s.keyDerivationAlgorithm.algorithmParams)throw Error('Incorrectly encoded "keyDerivationAlgorithm"');try{t=new a9({schema:s.keyDerivationAlgorithm.algorithmParams})}catch(e){throw Error('Incorrectly encoded "keyDerivationAlgorithm"')}let i=await a.importKey("raw",r.preDefinedData,"PBKDF2",!1,["deriveKey"]),n=a.getAlgorithmByOID(s.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm"),u=t.prf?a.getAlgorithmByOID(t.prf.algorithmId,!0,"prfAlgorithm").hash.name:"SHA-1",l=new Uint8Array(t.salt.valueBlock.valueHex),o=t.iterationCount,c=await a.deriveKey({name:"PBKDF2",hash:{name:u},salt:l,iterations:o},i,n,!0,["unwrapKey"]),h=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,m=a.getAlgorithmByOID(h,!0,"contentEncryptionAlgorithm");return a.unwrapKey("raw",s.encryptedKey.valueBlock.valueHexView,c,n,m,!0,["decrypt"])};switch(this.recipientInfos[e].variant){case 1:s=await n(e);break;case 2:s=await i(e);break;case 3:s=await u(e);break;case 4:s=await l(e);break;default:throw Error(`Unknown recipient type in array with index ${e}`)}let h=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,m=a.getAlgorithmByOID(h,!0,"contentEncryptionAlgorithm"),f=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex,d=new Uint8Array(f);if(!this.encryptedContentInfo.encryptedContent)throw Error("Required property `encryptedContent` is empty");let g=this.encryptedContentInfo.getEncryptedContent();return a.decrypt({name:m.name,iv:d},s,g)}}u6.CLASS_NAME="EnvelopedData";let u9="safeContents",u7="parsedValue",le="contentInfos";class lt extends y{constructor(e={}){super(),this.safeContents=h.H$(e,u9,lt.defaultValues(u9)),u7 in e&&(this.parsedValue=h.H$(e,u7,lt.defaultValues(u7))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case u9:return[];case u7:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case u9:return 0===t.length;case u7:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.contentInfos||"",value:r_.schema()})]})}fromSchema(e){h.ze(e,[le]);let t=o.compareSchema(e,e,lt.schema({names:{contentInfos:le}}));S.assertSchema(t,this.className),this.safeContents=Array.from(t.result.contentInfos,e=>new r_({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.safeContents,e=>e.toSchema())})}toJSON(){return{safeContents:Array.from(this.safeContents,e=>e.toJSON())}}async parseInternalValues(e,t=sc(!0)){if(p.assert(e,u9),g.assert(e.safeContents,u9,"Array"),e.safeContents.length!==this.safeContents.length)throw new g('Length of "parameters.safeContents" must be equal to "this.safeContents.length"');for(let[a,s]of(this.parsedValue={safeContents:[]},this.safeContents.entries())){let r=e.safeContents[a],i=`parameters.safeContents[${a}]`;switch(s.contentType){case eq:{g.assert(s.content,"this.safeContents[j].content",o.OctetString);let e=s.content.getValue();this.parsedValue.safeContents.push({privacyMode:0,value:nc.fromBER(e)})}break;case eR:{let e=new u6({schema:s.content});p.assert(i,r,"recipientCertificate","recipientKey");let a=r.recipientCertificate,n=r.recipientKey,u=await e.decrypt(0,{recipientCertificate:a,recipientPrivateKey:n},t);this.parsedValue.safeContents.push({privacyMode:2,value:nc.fromBER(u)})}break;case eJ:{let e=new i3({schema:s.content});p.assert(i,r,"password");let a=r.password,n=await e.decrypt({password:a},t);this.parsedValue.safeContents.push({privacyMode:1,value:nc.fromBER(n)})}break;default:throw Error(`Unknown "contentType" for AuthenticatedSafe: " ${s.contentType}`)}}}async makeInternalValues(e,t=sc(!0)){if(!this.parsedValue)throw Error('Please run "parseValues" first or add "parsedValue" manually');if(g.assert(this.parsedValue,"this.parsedValue","object"),g.assert(this.parsedValue.safeContents,"this.parsedValue.safeContents","Array"),g.assert(e,"parameters","object"),p.assert(e,"safeContents"),g.assert(e.safeContents,"parameters.safeContents","Array"),e.safeContents.length!==this.parsedValue.safeContents.length)throw new g('Length of "parameters.safeContents" must be equal to "this.parsedValue.safeContents"');for(let[a,s]of(this.safeContents=[],this.parsedValue.safeContents.entries()))switch(p.assert("content",s,"privacyMode","value"),g.assert(s.value,"content.value",nc),s.privacyMode){case 0:{let e=s.value.toSchema().toBER(!1);this.safeContents.push(new r_({contentType:"1.2.840.113549.1.7.1",content:new o.OctetString({valueHex:e})}))}break;case 1:{let r=new i3,i=e.safeContents[a];i.contentToEncrypt=s.value.toSchema().toBER(!1),await r.encrypt(i,t),this.safeContents.push(new r_({contentType:"1.2.840.113549.1.7.6",content:r.toSchema()}))}break;case 2:{let r=new u6,i=s.value.toSchema().toBER(!1),n=e.safeContents[a];switch(p.assert(`parameters.safeContents[${a}]`,n,"encryptingCertificate","encryptionAlgorithm"),!0){case"aes-cbc"===n.encryptionAlgorithm.name.toLowerCase():case"aes-gcm"===n.encryptionAlgorithm.name.toLowerCase():break;default:throw Error(`Incorrect parameter "encryptionAlgorithm" in "parameters.safeContents[i]": ${n.encryptionAlgorithm}`)}switch(!0){case 128===n.encryptionAlgorithm.length:case 192===n.encryptionAlgorithm.length:case 256===n.encryptionAlgorithm.length:break;default:throw Error(`Incorrect parameter "encryptionAlgorithm.length" in "parameters.safeContents[i]": ${n.encryptionAlgorithm.length}`)}let u=n.encryptionAlgorithm;r.addRecipientByCertificate(n.encryptingCertificate,{},void 0,t),await r.encrypt(u,i,t),this.safeContents.push(new r_({contentType:"1.2.840.113549.1.7.3",content:r.toSchema()}))}break;default:throw Error(`Incorrect value for "content.privacyMode": ${s.privacyMode}`)}return this}}lt.CLASS_NAME="AuthenticatedSafe";let la="hashAlgorithm",ls="issuerNameHash",lr="issuerKeyHash",li="serialNumber",ln=[la,ls,lr,li];class lu extends y{constructor(e={}){super(),this.hashAlgorithm=h.H$(e,la,lu.defaultValues(la)),this.issuerNameHash=h.H$(e,ls,lu.defaultValues(ls)),this.issuerKeyHash=h.H$(e,lr,lu.defaultValues(lr)),this.serialNumber=h.H$(e,li,lu.defaultValues(li)),e.schema&&this.fromSchema(e.schema)}static async create(e,t,a=sc(!0)){let s=new lu;return await s.createForCertificate(e,t,a),s}static defaultValues(e){switch(e){case la:return new L;case ls:case lr:return new o.OctetString;case li:return new o.Integer;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case la:return""===t.algorithmId&&"algorithmParams"in t==!1;case ls:case lr:case li:return t.isEqual(lu.defaultValues(li));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[L.schema(t.hashAlgorithmObject||{names:{blockName:t.hashAlgorithm||""}}),new o.OctetString({name:t.issuerNameHash||""}),new o.OctetString({name:t.issuerKeyHash||""}),new o.Integer({name:t.serialNumber||""})]})}fromSchema(e){h.ze(e,ln);let t=o.compareSchema(e,e,lu.schema({names:{hashAlgorithm:la,issuerNameHash:ls,issuerKeyHash:lr,serialNumber:li}}));S.assertSchema(t,this.className),this.hashAlgorithm=new L({schema:t.result.hashAlgorithm}),this.issuerNameHash=t.result.issuerNameHash,this.issuerKeyHash=t.result.issuerKeyHash,this.serialNumber=t.result.serialNumber}toSchema(){return new o.Sequence({value:[this.hashAlgorithm.toSchema(),this.issuerNameHash,this.issuerKeyHash,this.serialNumber]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),issuerNameHash:this.issuerNameHash.toJSON(),issuerKeyHash:this.issuerKeyHash.toJSON(),serialNumber:this.serialNumber.toJSON()}}isEqual(e){return!!(this.hashAlgorithm.algorithmId===e.hashAlgorithm.algorithmId&&c.vJ.isEqual(this.issuerNameHash.valueBlock.valueHexView,e.issuerNameHash.valueBlock.valueHexView)&&c.vJ.isEqual(this.issuerKeyHash.valueBlock.valueHexView,e.issuerKeyHash.valueBlock.valueHexView)&&this.serialNumber.isEqual(e.serialNumber))}async createForCertificate(e,t,a=sc(!0)){p.assert(t,la,"issuerCertificate");let s=a.getOIDByAlgorithm({name:t.hashAlgorithm},!0,"hashAlgorithm");this.hashAlgorithm=new L({algorithmId:s,algorithmParams:new o.Null});let r=t.issuerCertificate;this.serialNumber=e.serialNumber;let i=await a.digest({name:t.hashAlgorithm},r.subject.toSchema().toBER(!1));this.issuerNameHash=new o.OctetString({valueHex:i});let n=r.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView,u=await a.digest({name:t.hashAlgorithm},n);this.issuerKeyHash=new o.OctetString({valueHex:u})}}lu.CLASS_NAME="CertID";let ll="certID",lo="certStatus",lc="thisUpdate",lh="nextUpdate",lm="singleExtensions",lf=[ll,lo,lc,lh,lm];class ld extends y{constructor(e={}){super(),this.certID=h.H$(e,ll,ld.defaultValues(ll)),this.certStatus=h.H$(e,lo,ld.defaultValues(lo)),this.thisUpdate=h.H$(e,lc,ld.defaultValues(lc)),lh in e&&(this.nextUpdate=h.H$(e,lh,ld.defaultValues(lh))),lm in e&&(this.singleExtensions=h.H$(e,lm,ld.defaultValues(lm))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ll:return new lu;case lo:return{};case lc:case lh:return new Date(0,0,0);case lm:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ll:return lu.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&lu.compareWithDefault("issuerNameHash",t.issuerNameHash)&&lu.compareWithDefault("issuerKeyHash",t.issuerKeyHash)&&lu.compareWithDefault("serialNumber",t.serialNumber);case lo:return 0===Object.keys(t).length;case lc:case lh:return t===ld.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[lu.schema(t.certID||{}),new o.Choice({value:[new o.Primitive({name:t.certStatus||"",idBlock:{tagClass:3,tagNumber:0}}),new o.Constructed({name:t.certStatus||"",idBlock:{tagClass:3,tagNumber:1},value:[new o.GeneralizedTime,new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Enumerated]})]}),new o.Primitive({name:t.certStatus||"",idBlock:{tagClass:3,tagNumber:2},lenBlock:{length:1}})]}),new o.GeneralizedTime({name:t.thisUpdate||""}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.GeneralizedTime({name:t.nextUpdate||""})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[sX.schema(t.singleExtensions||{})]})]})}fromSchema(e){h.ze(e,lf);let t=o.compareSchema(e,e,ld.schema({names:{certID:{names:{blockName:ll}},certStatus:lo,thisUpdate:lc,nextUpdate:lh,singleExtensions:{names:{blockName:lm}}}}));S.assertSchema(t,this.className),this.certID=new lu({schema:t.result.certID}),this.certStatus=t.result.certStatus,this.thisUpdate=t.result.thisUpdate.toDate(),lh in t.result&&(this.nextUpdate=t.result.nextUpdate.toDate()),lm in t.result&&(this.singleExtensions=Array.from(t.result.singleExtensions.valueBlock.value,e=>new sF({schema:e})))}toSchema(){let e=[];return e.push(this.certID.toSchema()),e.push(this.certStatus),e.push(new o.GeneralizedTime({valueDate:this.thisUpdate})),this.nextUpdate&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.GeneralizedTime({valueDate:this.nextUpdate})]})),this.singleExtensions&&e.push(new o.Sequence({value:Array.from(this.singleExtensions,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={certID:this.certID.toJSON(),certStatus:this.certStatus.toJSON(),thisUpdate:this.thisUpdate};return this.nextUpdate&&(e.nextUpdate=this.nextUpdate),this.singleExtensions&&(e.singleExtensions=Array.from(this.singleExtensions,e=>e.toJSON())),e}}ld.CLASS_NAME="SingleResponse";let lg="version",lp="responderID",lS="producedAt",ly="responses",lw="responseExtensions",lv="ResponseData",lb=`${lv}.${lg}`,lA=`${lv}.${lp}`,lk=`${lv}.${lS}`,lC=`${lv}.${ly}`,lN=`${lv}.${lw}`,lV=[lv,lb,lA,lk,lC,lN];class lI extends y{constructor(e={}){super(),this.tbsView=new Uint8Array(h.H$(e,"tbs",lI.defaultValues("tbs"))),lg in e&&(this.version=h.H$(e,lg,lI.defaultValues(lg))),this.responderID=h.H$(e,lp,lI.defaultValues(lp)),this.producedAt=h.H$(e,lS,lI.defaultValues(lS)),this.responses=h.H$(e,ly,lI.defaultValues(ly)),lw in e&&(this.responseExtensions=h.H$(e,lw,lI.defaultValues(lw))),e.schema&&this.fromSchema(e.schema)}get tbs(){return c.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case lg:return 0;case"tbs":return d;case lp:return{};case lS:return new Date(0,0,0);case ly:case lw:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"tbs":return 0===t.byteLength;case lp:return 0===Object.keys(t).length;case lS:return t===lI.defaultValues(e);case ly:case lw:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||lv,value:[new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Integer({name:t.version||lb})]}),new o.Choice({value:[new o.Constructed({name:t.responderID||lA,idBlock:{tagClass:3,tagNumber:1},value:[V.schema(t.ResponseDataByName||{names:{blockName:"ResponseData.byName"}})]}),new o.Constructed({name:t.responderID||lA,idBlock:{tagClass:3,tagNumber:2},value:[new o.OctetString({name:t.ResponseDataByKey||"ResponseData.byKey"})]})]}),new o.GeneralizedTime({name:t.producedAt||lk}),new o.Sequence({value:[new o.Repeated({name:lC,value:ld.schema(t.response||{})})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[sX.schema(t.extensions||{names:{blockName:lN}})]})]})}fromSchema(e){h.ze(e,lV);let t=o.compareSchema(e,e,lI.schema());S.assertSchema(t,this.className),this.tbsView=t.result.ResponseData.valueBeforeDecodeView,lb in t.result&&(this.version=t.result[lb].valueBlock.valueDec),1===t.result[lA].idBlock.tagNumber?this.responderID=new V({schema:t.result[lA].valueBlock.value[0]}):this.responderID=t.result[lA].valueBlock.value[0],this.producedAt=t.result[lk].toDate(),this.responses=Array.from(t.result[lC],e=>new ld({schema:e})),lN in t.result&&(this.responseExtensions=Array.from(t.result[lN].valueBlock.value,e=>new sF({schema:e})))}toSchema(e=!1){let t;if(!1===e){if(!this.tbsView.byteLength)return lI.schema();let e=o.fromBER(this.tbsView);S.assert(e,"TBS Response Data"),t=e.result}else{let e=[];lg in this&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Integer({value:this.version})]})),this.responderID instanceof V?e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.responderID.toSchema()]})):e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:[this.responderID]})),e.push(new o.GeneralizedTime({valueDate:this.producedAt})),e.push(new o.Sequence({value:Array.from(this.responses,e=>e.toSchema())})),this.responseExtensions&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new o.Sequence({value:Array.from(this.responseExtensions,e=>e.toSchema())})]})),t=new o.Sequence({value:e})}return t}toJSON(){let e={};return lg in this&&(e.version=this.version),this.responderID&&(e.responderID=this.responderID),this.producedAt&&(e.producedAt=this.producedAt),this.responses&&(e.responses=Array.from(this.responses,e=>e.toJSON())),this.responseExtensions&&(e.responseExtensions=Array.from(this.responseExtensions,e=>e.toJSON())),e}}lI.CLASS_NAME="ResponseData";let lB="trustedCerts",lE="certs",lH="crls",lD="ocsps",lO="checkDate",lx="findOrigin",lP="findIssuer";(r=u||(u={}))[r.unknown=-1]="unknown",r[r.success=0]="success",r[r.noRevocation=11]="noRevocation",r[r.noPath=60]="noPath",r[r.noValidPath=97]="noValidPath";class l$ extends Error{constructor(e,t){super(t),this.name=l$.NAME,this.code=e,this.message=t}}l$.NAME="ChainValidationError";class lq{constructor(e={}){this.trustedCerts=h.H$(e,lB,this.defaultValues(lB)),this.certs=h.H$(e,lE,this.defaultValues(lE)),this.crls=h.H$(e,lH,this.defaultValues(lH)),this.ocsps=h.H$(e,lD,this.defaultValues(lD)),this.checkDate=h.H$(e,lO,this.defaultValues(lO)),this.findOrigin=h.H$(e,lx,this.defaultValues(lx)),this.findIssuer=h.H$(e,lP,this.defaultValues(lP))}static defaultFindOrigin(e,t){for(let a of(0===e.tbsView.byteLength&&(e.tbsView=new Uint8Array(e.encodeTBS().toBER())),t.certs))if(0===a.tbsView.byteLength&&(a.tbsView=new Uint8Array(a.encodeTBS().toBER())),c.vJ.isEqual(e.tbsView,a.tbsView))return"Intermediate Certificates";for(let a of t.trustedCerts)if(0===a.tbsView.byteLength&&(a.tbsView=new Uint8Array(a.encodeTBS().toBER())),c.vJ.isEqual(e.tbsView,a.tbsView))return"Trusted Certificates";return"Unknown"}async defaultFindIssuer(e,t,a=sc(!0)){let s=[],r=null,i=null,n=null;if(e.subject.isEqual(e.issuer))try{let t=await e.verify(void 0,a);if(t)return[e]}catch(e){}if(e.extensions){for(let t of e.extensions)if(t.extnID===eC&&t.parsedValue instanceof e4){t.parsedValue.keyIdentifier?r=t.parsedValue.keyIdentifier:(t.parsedValue.authorityCertIssuer&&(i=t.parsedValue.authorityCertIssuer),t.parsedValue.authorityCertSerialNumber&&(n=t.parsedValue.authorityCertSerialNumber));break}}function u(t){if(null!==r&&t.extensions){let e=!1;for(let a of t.extensions)if(a.extnID===ei&&a.parsedValue){e=!0,c.vJ.isEqual(a.parsedValue.valueBlock.valueHex,r.valueBlock.valueHexView)&&s.push(t);break}if(e)return}let a=!1;null!==n&&(a=t.serialNumber.isEqual(n)),null!==i?t.subject.isEqual(i)&&a&&s.push(t):e.issuer.isEqual(t.subject)&&s.push(t)}for(let e of t.trustedCerts)u(e);for(let e of t.certs)u(e);for(let t=0;t<s.length;t++)try{let r=await e.verify(s[t],a);!1===r&&s.splice(t,1)}catch(e){s.splice(t,1)}return s}defaultValues(e){switch(e){case lB:case lE:case lH:case lD:return[];case lO:return new Date;case lx:return lq.defaultFindOrigin;case lP:return this.defaultFindIssuer;default:throw Error(`Invalid member name for CertificateChainValidationEngine class: ${e}`)}}async sort(e=!1,t=sc(!0)){let a;let s=[],r=async(e,t)=>{let a=[];if(function(e,t){for(let a=0;a<t.length;a++)if(c.vJ.isEqual(e.tbsView,t[a].tbsView))return!0;return!1}(e,this.trustedCerts))return[[e]];let s=await this.findIssuer(e,this,t);if(0===s.length)throw Error("No valid certificate paths found");for(let i=0;i<s.length;i++){if(c.vJ.isEqual(s[i].tbsView,e.tbsView)){a.push([s[i]]);continue}let n=await r(s[i],t);for(let e=0;e<n.length;e++){let t=n[e].slice();t.splice(0,0,s[i]),function(e){let t=!0;for(let a=0;a<e.length;a++){for(let s=0;s<e.length;s++)if(s!==a&&e[a]===e[s]){t=!1;break}if(!t)break}return t}(t)?a.push(t):a.push(n[e])}}return a},i=async e=>{let a=[],r=[],i=[];if(a.push(...s.filter(t=>e.issuer.isEqual(t.subject))),0===a.length)return{status:1,statusMessage:"No certificate's issuers"};if(r.push(...this.crls.filter(t=>t.issuer.isEqual(e.issuer))),0===r.length)return{status:2,statusMessage:"No CRLs for specific certificate issuer"};for(let e=0;e<r.length;e++){let s=r[e];if(!s.nextUpdate||!(s.nextUpdate.value<this.checkDate))for(let s=0;s<a.length;s++)try{let n=await r[e].verify({issuerCertificate:a[s]},t);if(n){i.push({crl:r[e],certificate:a[s]});break}}catch(e){}}return i.length?{status:0,statusMessage:"",result:i}:{status:3,statusMessage:"No valid CRLs found"}},n=async(e,a)=>{let s=t.getAlgorithmByOID(e.signatureAlgorithm.algorithmId);if(!s.name||!s.hash)return 1;for(let s=0;s<this.ocsps.length;s++){let r=this.ocsps[s],i=await r.getCertificateStatus(e,a,t);if(i.isForCertificate){if(0===i.status)return 0;return 1}}return 2};async function l(e,t=!1){let a=!1,s=!1,r=!1,i=!1;if(e.extensions){for(let t=0;t<e.extensions.length;t++){let n=e.extensions[t];if(n.critical&&!n.parsedValue)return{result:!1,resultCode:6,resultMessage:`Unable to parse critical certificate extension: ${n.extnID}`};if(n.extnID===en){r=!0;let e=new Uint8Array(n.parsedValue.valueBlock.valueHex);(4&e[0])==4&&(s=!0),(2&e[0])==2&&(i=!0)}n.extnID===ec&&"cA"in n.parsedValue&&!0===n.parsedValue.cA&&(a=!0)}if(!0===s&&!1===a)return{result:!1,resultCode:3,resultMessage:'Unable to build certificate chain - using "keyCertSign" flag set without BasicConstraints'};if(!0===r&&!0===a&&!1===s)return{result:!1,resultCode:4,resultMessage:'Unable to build certificate chain - "keyCertSign" flag was not set'};if(!0===a&&!0===r&&t&&!1===i)return{result:!1,resultCode:5,resultMessage:'Unable to build certificate chain - intermediate certificate must have "cRLSign" key usage flag'}}return!1===a?{result:!1,resultCode:7,resultMessage:"Unable to build certificate chain - more than one possible end-user certificate"}:{result:!0,resultCode:0,resultMessage:""}}let o=async(t,a)=>{for(let e=0;e<t.length;e++)if(t[e].notBefore.value>a||t[e].notAfter.value<a)return{result:!1,resultCode:8,resultMessage:"The certificate is either not yet valid or expired"};if(t.length<2)return{result:!1,resultCode:9,resultMessage:"Too short certificate path"};for(let e=t.length-2;e>=0;e--)if(!1===t[e].issuer.isEqual(t[e].subject)&&!1===t[e].issuer.isEqual(t[e+1].subject))return{result:!1,resultCode:10,resultMessage:"Incorrect name chaining"};if(0!==this.crls.length||0!==this.ocsps.length)for(let a=0;a<t.length-1;a++){let s=2,r={status:0,statusMessage:""};if(0!==this.ocsps.length)switch(s=await n(t[a],t[a+1])){case 0:continue;case 1:return{result:!1,resultCode:12,resultMessage:"One of certificates was revoked via OCSP response"}}if(0!==this.crls.length){if(0===(r=await i(t[a])).status&&r.result)for(let e=0;e<r.result.length;e++){let s=r.result[e].crl.isCertificateRevoked(t[a]);if(s)return{result:!1,resultCode:12,resultMessage:"One of certificates had been revoked"};let i=await l(r.result[e].certificate,!0);if(!1===i.result)return{result:!1,resultCode:13,resultMessage:"CRL issuer certificate is not a CA certificate or does not have crlSign flag"}}else if(!1===e)throw new l$(u.noRevocation,`No revocation values found for one of certificates: ${r.statusMessage}`)}else if(2===s)return{result:!1,resultCode:11,resultMessage:"No revocation values found for one of certificates"};if(2===s&&2===r.status&&e){let e=t[a+1],s=!1;if(e.extensions)for(let t of e.extensions)switch(t.extnID){case ey:case ew:case eB:s=!0}if(s)throw new l$(u.noRevocation,`No revocation values found for one of certificates: ${r.statusMessage}`)}}for(let[e,a]of t.entries()){if(!e)continue;let t=await l(a);if(!t.result)return{result:!1,resultCode:14,resultMessage:"One of intermediate certificates is not a CA certificate"}}return{result:!0}};s.push(...this.trustedCerts),s.push(...this.certs);for(let e=0;e<s.length;e++)for(let t=0;t<s.length;t++)if(e!==t&&c.vJ.isEqual(s[e].tbsView,s[t].tbsView)){s.splice(t,1),e=0;break}let h=s[s.length-1],m=[h];if(0===(a=await r(h,t)).length)throw new l$(u.noPath,"Unable to find certificate path");for(let e=0;e<a.length;e++){let t=!1;for(let s=0;s<a[e].length;s++){let r=a[e][s];for(let e=0;e<this.trustedCerts.length;e++)if(c.vJ.isEqual(r.tbsView,this.trustedCerts[e].tbsView)){t=!0;break}if(t)break}t||(a.splice(e,1),e=0)}if(0===a.length)throw new l$(u.noValidPath,"No valid certificate paths found");let f=a[0].length,d=0;for(let e=0;e<a.length;e++)a[e].length<f&&(f=a[e].length,d=e);for(let e=0;e<a[d].length;e++)m.push(a[d][e]);if(!1===(a=await o(m,this.checkDate)).result)throw a;return m}async verify(e={},t=sc(!0)){function a(e,t){let a=w(e),s=w(t),r=a.split("."),i=s.split("."),n=r.length,u=i.length;if(0===n||0===u||n<u)return!1;for(let e=0;e<n;e++)if(0===r[e].length)return!1;for(let e=0;e<u;e++)if(0===i[e].length){if(0===e){if(1===u)return!1;continue}return!1}for(let e=0;e<u;e++)if(0!==i[u-1-e].length&&0!==r[n-1-e].localeCompare(i[u-1-e]))return!1;return!0}function s(e,t){let s=w(e),r=w(t),i=s.split("@"),n=r.split("@");if(0===i.length||0===n.length||i.length<n.length)return!1;if(1===n.length){let e=a(i[1],n[0]);if(e){let e=i[1].split("."),t=n[0].split(".");return 0===t[0].length||e.length===t.length}return!1}return 0===s.localeCompare(r)}function r(e,t){let s=w(e),r=w(t),i=s.split("/"),n=r.split("/");if(n.length>1)return!1;if(i.length>1){for(let e=0;e<i.length;e++)if(i[e].length>0&&":"!==i[e].charAt(i[e].length-1)){let t=i[e].split(":");s=t[0];break}}let u=a(s,r);if(u){let e=s.split("."),t=r.split(".");return 0===t[0].length||e.length===t.length}return!1}function i(e,t){let a=e.valueBlock.valueHexView,s=t.valueBlock.valueHexView;if(4===a.length&&8===s.length){for(let e=0;e<4;e++)if((a[e]^s[e])&s[e+4])return!1;return!0}if(16===a.length&&32===s.length){for(let e=0;e<16;e++)if((a[e]^s[e])&s[e+16])return!1;return!0}return!1}function n(e,t){if(0===e.typesAndValues.length||0===t.typesAndValues.length)return!0;if(e.typesAndValues.length<t.typesAndValues.length)return!1;let a=!0,s=0;for(let r=0;r<t.typesAndValues.length;r++){let i=!1;for(let n=s;n<e.typesAndValues.length;n++)if(i=e.typesAndValues[n].isEqual(t.typesAndValues[r]),e.typesAndValues[n].type===t.typesAndValues[r].type&&(a=a&&i),!0===i){if(0!==s&&s!==n)return!1;s=n+1;break}if(!1===i)return!1}return 0!==s&&a}try{if(0===this.certs.length)throw Error("Empty certificate array");let u=e.passedWhenNotRevValues||!1,l=e.initialPolicySet||[eb],o=e.initialExplicitPolicy||!1,c=e.initialPolicyMappingInhibit||!1,h=e.initialInhibitPolicy||!1,m=e.initialPermittedSubtreesSet||[],f=e.initialExcludedSubtreesSet||[],d=e.initialRequiredNameForms||[],g=o,p=c,S=h,y=[!1,!1,!1],w=0,v=0,b=0,A=m,k=f,C=1;this.certs=await this.sort(u,t);let N=[];N.push(eb);let V=[],I=Array(this.certs.length-1);for(let e=0;e<this.certs.length-1;e++)I[e]=!0;V.push(I);let B=Array(this.certs.length-1),E=Array(this.certs.length-1),H=g?this.certs.length-1:-1;for(let e=this.certs.length-2;e>=0;e--,C++){let t=this.certs[e];if(t.extensions){for(let a=0;a<t.extensions.length;a++){let s=t.extensions[a];if(s.extnID===ev){E[e]=s.parsedValue;for(let t=0;t<N.length;t++)if(N[t]===eb){delete V[t][e];break}for(let t=0;t<s.parsedValue.certificatePolicies.length;t++){let a=-1,r=s.parsedValue.certificatePolicies[t].policyIdentifier;for(let e=0;e<N.length;e++)if(r===N[e]){a=e;break}if(-1===a){N.push(r);let t=Array(this.certs.length-1);t[e]=!0,V.push(t)}else V[a][e]=!0}}if(s.extnID===ek){if(p)return{result:!1,resultCode:98,resultMessage:"Policy mapping prohibited"};B[e]=s.parsedValue}s.extnID===eN&&!1===g&&(0===s.parsedValue.requireExplicitPolicy?(g=!0,H=e):!1===y[0]?(y[0]=!0,w=s.parsedValue.requireExplicitPolicy):w=w>s.parsedValue.requireExplicitPolicy?s.parsedValue.requireExplicitPolicy:w,0===s.parsedValue.inhibitPolicyMapping?p=!0:!1===y[1]?(y[1]=!0,v=s.parsedValue.inhibitPolicyMapping+1):v=v>s.parsedValue.inhibitPolicyMapping+1?s.parsedValue.inhibitPolicyMapping+1:v),s.extnID===eI&&!1===S&&(0===s.parsedValue.valueBlock.valueDec?S=!0:!1===y[2]?(y[2]=!0,b=s.parsedValue.valueBlock.valueDec):b=b>s.parsedValue.valueBlock.valueDec?s.parsedValue.valueBlock.valueDec:b)}if(!0===S){let t=-1;for(let e=0;e<N.length;e++)if(N[e]===eb){t=e;break}-1!==t&&delete V[0][e]}!1===g&&!0===y[0]&&(w--,0===w&&(g=!0,H=e,y[0]=!1)),!1===p&&!0===y[1]&&(v--,0===v&&(p=!0,y[1]=!1)),!1===S&&!0===y[2]&&(b--,0===b&&(S=!0,y[2]=!1))}}for(let e=0;e<this.certs.length-1;e++)if(e<this.certs.length-2&&void 0!==B[e+1])for(let t=0;t<B[e+1].mappings.length;t++){if(B[e+1].mappings[t].issuerDomainPolicy===eb||B[e+1].mappings[t].subjectDomainPolicy===eb)return{result:!1,resultCode:99,resultMessage:'The "anyPolicy" should not be a part of policy mapping scheme'};let a=-1,s=-1;for(let r=0;r<N.length;r++)N[r]===B[e+1].mappings[t].issuerDomainPolicy&&(a=r),N[r]===B[e+1].mappings[t].subjectDomainPolicy&&(s=r);void 0!==V[a][e]&&delete V[a][e];for(let r=0;r<E[e].certificatePolicies.length;r++)if(B[e+1].mappings[t].subjectDomainPolicy===E[e].certificatePolicies[r].policyIdentifier&&-1!==a&&-1!==s)for(let t=0;t<=e;t++)void 0!==V[s][t]&&(V[a][t]=!0,delete V[s][t])}for(let e=0;e<N.length;e++)if(N[e]===eb)for(let t=0;t<H;t++)delete V[e][t];let D=[];for(let e=0;e<V.length;e++){let t=!0;for(let a=0;a<this.certs.length-1;a++){let s=!1;if(a<H&&N[e]===eb&&N.length>1){t=!1;break}if(void 0===V[e][a]){if(a>=H){for(let e=0;e<N.length;e++)if(N[e]===eb){!0===V[e][a]&&(s=!0);break}}if(!s){t=!1;break}}}!0===t&&D.push(N[e])}let O=[];if(1===l.length&&l[0]===eb&&!1===g)O=l;else if(1===D.length&&D[0]===eb)O=l;else for(let e=0;e<D.length;e++)for(let t=0;t<l.length;t++)if(l[t]===D[e]||l[t]===eb){O.push(D[e]);break}let x={result:O.length>0,resultCode:0,resultMessage:O.length>0?"":'Zero "userConstrPolicies" array, no intersections with "authConstrPolicies"',authConstrPolicies:D,userConstrPolicies:O,explicitPolicyIndicator:g,policyMappings:B,certificatePath:this.certs};if(0===O.length||!1===x.result)return x;C=1;for(let e=this.certs.length-2;e>=0;e--,C++){let t=this.certs[e],u=[],l=[],o=[];if(t.extensions)for(let e=0;e<t.extensions.length;e++){let a=t.extensions[e];a.extnID===eS&&("permittedSubtrees"in a.parsedValue&&(l=l.concat(a.parsedValue.permittedSubtrees)),"excludedSubtrees"in a.parsedValue&&(o=o.concat(a.parsedValue.excludedSubtrees))),a.extnID===el&&(u=u.concat(a.parsedValue.altNames))}let c=d.length<=0;for(let e=0;e<d.length;e++)if(4===d[e].base.type){if(d[e].base.value.typesAndValues.length!==t.subject.typesAndValues.length)continue;c=!0;for(let a=0;a<t.subject.typesAndValues.length;a++)if(t.subject.typesAndValues[a].type!==d[e].base.value.typesAndValues[a].type){c=!1;break}}if(!1===c)throw x.result=!1,x.resultCode=21,x.resultMessage="No necessary name form found",x;let h=[[],[],[],[],[]];for(let e=0;e<A.length;e++)switch(A[e].base.type){case 1:h[0].push(A[e]);break;case 2:h[1].push(A[e]);break;case 4:h[2].push(A[e]);break;case 6:h[3].push(A[e]);break;case 7:h[4].push(A[e])}for(let e=0;e<5;e++){let l=!1,o=!1,c=h[e];for(let h=0;h<c.length;h++){switch(e){case 0:if(u.length>0)for(let e=0;e<u.length;e++)1===u[e].type&&(o=!0,l=l||s(u[e].value,c[h].base.value));else for(let e=0;e<t.subject.typesAndValues.length;e++)("1.2.840.113549.1.9.1"===t.subject.typesAndValues[e].type||"0.9.2342.19200300.100.1.3"===t.subject.typesAndValues[e].type)&&(o=!0,l=l||s(t.subject.typesAndValues[e].value.valueBlock.value,c[h].base.value));break;case 1:if(u.length>0)for(let e=0;e<u.length;e++)2===u[e].type&&(o=!0,l=l||a(u[e].value,c[h].base.value));break;case 2:o=!0,l=n(t.subject,c[h].base.value);break;case 3:if(u.length>0)for(let e=0;e<u.length;e++)6===u[e].type&&(o=!0,l=l||r(u[e].value,c[h].base.value));break;case 4:if(u.length>0)for(let e=0;e<u.length;e++)7===u[e].type&&(o=!0,l=l||i(u[e].value,c[h].base.value))}if(l)break}if(!1===l&&c.length>0&&o)throw x.result=!1,x.resultCode=41,x.resultMessage='Failed to meet "permitted sub-trees" name constraint',x}let m=!1;for(let e=0;e<k.length;e++){switch(k[e].base.type){case 1:if(u.length>=0)for(let t=0;t<u.length;t++)1===u[t].type&&(m=m||s(u[t].value,k[e].base.value));else for(let a=0;a<t.subject.typesAndValues.length;a++)("1.2.840.113549.1.9.1"===t.subject.typesAndValues[a].type||"0.9.2342.19200300.100.1.3"===t.subject.typesAndValues[a].type)&&(m=m||s(t.subject.typesAndValues[a].value.valueBlock.value,k[e].base.value));break;case 2:if(u.length>0)for(let t=0;t<u.length;t++)2===u[t].type&&(m=m||a(u[t].value,k[e].base.value));break;case 4:m=m||n(t.subject,k[e].base.value);break;case 6:if(u.length>0)for(let t=0;t<u.length;t++)6===u[t].type&&(m=m||r(u[t].value,k[e].base.value));break;case 7:if(u.length>0)for(let t=0;t<u.length;t++)7===u[t].type&&(m=m||i(u[t].value,k[e].base.value))}if(m)break}if(!0===m)throw x.result=!1,x.resultCode=42,x.resultMessage='Failed to meet "excluded sub-trees" name constraint',x;A=A.concat(l),k=k.concat(o)}return x}catch(e){if(e instanceof Error){if(e instanceof l$)return{result:!1,resultCode:e.code,resultMessage:e.message,error:e};return{result:!1,resultCode:u.unknown,resultMessage:e.message,error:e}}if(e&&"object"==typeof e&&"resultMessage"in e)return e;return{result:!1,resultCode:-1,resultMessage:`${e}`}}}}let lK="tbsResponseData",lR="signatureAlgorithm",lJ="signature",lU="certs",lT="BasicOCSPResponse",lj=`${lT}.${lK}`,lL=`${lT}.${lR}`,lM=`${lT}.${lJ}`,l_=`${lT}.${lU}`,lW=[lj,lL,lM,l_];class lz extends y{constructor(e={}){super(),this.tbsResponseData=h.H$(e,lK,lz.defaultValues(lK)),this.signatureAlgorithm=h.H$(e,lR,lz.defaultValues(lR)),this.signature=h.H$(e,lJ,lz.defaultValues(lJ)),lU in e&&(this.certs=h.H$(e,lU,lz.defaultValues(lU))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case lK:return new lI;case lR:return new L;case lJ:return new o.BitString;case lU:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"type":{let e=lI.compareWithDefault("tbs",t.tbs)&&lI.compareWithDefault("responderID",t.responderID)&&lI.compareWithDefault("producedAt",t.producedAt)&&lI.compareWithDefault("responses",t.responses);return"responseExtensions"in t&&(e=e&&lI.compareWithDefault("responseExtensions",t.responseExtensions)),e}case lR:return""===t.algorithmId&&"algorithmParams"in t==!1;case lJ:return t.isEqual(lz.defaultValues(e));case lU:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||lT,value:[lI.schema(t.tbsResponseData||{names:{blockName:lj}}),L.schema(t.signatureAlgorithm||{names:{blockName:lL}}),new o.BitString({name:t.signature||lM}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Sequence({value:[new o.Repeated({name:l_,value:ip.schema(t.certs||{})})]})]})]})}fromSchema(e){h.ze(e,lW);let t=o.compareSchema(e,e,lz.schema());S.assertSchema(t,this.className),this.tbsResponseData=new lI({schema:t.result[lj]}),this.signatureAlgorithm=new L({schema:t.result[lL]}),this.signature=t.result[lM],l_ in t.result&&(this.certs=Array.from(t.result[l_],e=>new ip({schema:e})))}toSchema(){let e=[];return e.push(this.tbsResponseData.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.certs&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Sequence({value:Array.from(this.certs,e=>e.toSchema())})]})),new o.Sequence({value:e})}toJSON(){let e={tbsResponseData:this.tbsResponseData.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.certs&&(e.certs=Array.from(this.certs,e=>e.toJSON())),e}async getCertificateStatus(e,t,a=sc(!0)){let s={isForCertificate:!1,status:2},r={},i=[];for(let s of this.tbsResponseData.responses){let n=a.getAlgorithmByOID(s.certID.hashAlgorithm.algorithmId,!0,"CertID.hashAlgorithm");if(!r[n.name]){r[n.name]=1;let s=new lu;i.push(s),await s.createForCertificate(e,{hashAlgorithm:n.name,issuerCertificate:t},a)}}for(let e of this.tbsResponseData.responses)for(let t of i)if(e.certID.isEqual(t)){s.isForCertificate=!0;try{switch(e.certStatus.idBlock.isConstructed){case!0:1===e.certStatus.idBlock.tagNumber&&(s.status=1);break;case!1:switch(e.certStatus.idBlock.tagNumber){case 0:s.status=0;break;case 2:s.status=2}}}catch(e){}return s}return s}async sign(e,t="SHA-1",a=sc(!0)){if(!e)throw Error("Need to provide a private key for signing");let s=await a.getSignatureParameters(e,t),r=s.parameters.algorithm;if(!("name"in r))throw Error("Empty algorithm");this.signatureAlgorithm=s.signatureAlgorithm,this.tbsResponseData.tbsView=new Uint8Array(this.tbsResponseData.toSchema(!0).toBER());let i=await a.signWithPrivateKey(this.tbsResponseData.tbsView,e,{algorithm:r});this.signature=new o.BitString({valueHex:i})}async verify(e={},t=sc(!0)){let a=null,s=-1,r=e.trustedCerts||[];if(!this.certs)throw Error("No certificates attached to the BasicOCSPResponse");switch(!0){case this.tbsResponseData.responderID instanceof V:for(let[e,t]of this.certs.entries())if(t.subject.isEqual(this.tbsResponseData.responderID)){s=e;break}break;case this.tbsResponseData.responderID instanceof o.OctetString:for(let[e,a]of this.certs.entries()){let r=await t.digest({name:"sha-1"},a.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);if(h.dN(r,this.tbsResponseData.responderID.valueBlock.valueHex)){s=e;break}}break;default:throw Error("Wrong value for responderID")}if(-1===s)throw Error("Correct certificate was not found in OCSP response");a=this.certs[s];let i=[a];for(let e of this.certs){let t=await iS(e,a);t&&i.push(t)}let n=new lq({certs:i,trustedCerts:r}),u=await n.verify({},t);if(!u.result)throw Error("Validation of signer's certificate failed");return t.verifyWithPublicKey(this.tbsResponseData.tbsView,this.signature,this.certs[s].subjectPublicKeyInfo,this.signatureAlgorithm)}}lz.CLASS_NAME="BasicOCSPResponse";let lF="version",lG="subject",lQ="subjectPublicKeyInfo",lX="attributes",lY="signatureAlgorithm",lZ="signatureValue",l1="CertificationRequestInfo",l0=`${l1}.version`,l2=`${l1}.subject`,l3=`${l1}.subjectPublicKeyInfo`,l4=`${l1}.attributes`,l8=[l1,l0,l2,l3,l4,lY,lZ];class l5 extends y{constructor(e={}){super(),this.tbsView=new Uint8Array(h.H$(e,"tbs",l5.defaultValues("tbs"))),this.version=h.H$(e,lF,l5.defaultValues(lF)),this.subject=h.H$(e,lG,l5.defaultValues(lG)),this.subjectPublicKeyInfo=h.H$(e,lQ,l5.defaultValues(lQ)),lX in e&&(this.attributes=h.H$(e,lX,l5.defaultValues(lX))),this.signatureAlgorithm=h.H$(e,lY,l5.defaultValues(lY)),this.signatureValue=h.H$(e,lZ,l5.defaultValues(lZ)),e.schema&&this.fromSchema(e.schema)}get tbs(){return c.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case"tbs":return d;case lF:return 0;case lG:return new V;case lQ:return new ap;case lX:return[];case lY:return new L;case lZ:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({value:[function(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.CertificationRequestInfo||l1,value:[new o.Integer({name:t.CertificationRequestInfoVersion||l0}),V.schema(t.subject||{names:{blockName:l2}}),ap.schema({names:{blockName:l3}}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Repeated({optional:!0,name:t.CertificationRequestInfoAttributes||l4,value:Q.schema(t.attributes||{})})]})]})}(t.certificationRequestInfo||{}),new o.Sequence({name:t.signatureAlgorithm||lY,value:[new o.ObjectIdentifier,new o.Any({optional:!0})]}),new o.BitString({name:t.signatureValue||lZ})]})}fromSchema(e){h.ze(e,l8);let t=o.compareSchema(e,e,l5.schema());S.assertSchema(t,this.className),this.tbsView=t.result.CertificationRequestInfo.valueBeforeDecodeView,this.version=t.result[l0].valueBlock.valueDec,this.subject=new V({schema:t.result[l2]}),this.subjectPublicKeyInfo=new ap({schema:t.result[l3]}),l4 in t.result&&(this.attributes=Array.from(t.result[l4],e=>new Q({schema:e}))),this.signatureAlgorithm=new L({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){let e=[new o.Integer({value:this.version}),this.subject.toSchema(),this.subjectPublicKeyInfo.toSchema()];return lX in this&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes||[],e=>e.toSchema())})),new o.Sequence({value:e})}toSchema(e=!1){let t;if(!1===e){if(0===this.tbsView.byteLength)return l5.schema();let e=o.fromBER(this.tbsView);S.assert(e,"PKCS#10 Certificate Request"),t=e.result}else t=this.encodeTBS();return new o.Sequence({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){let e={tbs:c.ep.ToHex(this.tbsView),version:this.version,subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return lX in this&&(e.attributes=Array.from(this.attributes||[],e=>e.toJSON())),e}async sign(e,t="SHA-1",a=sc(!0)){if(!e)throw Error("Need to provide a private key for signing");let s=await a.getSignatureParameters(e,t),r=s.parameters;this.signatureAlgorithm=s.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());let i=await a.signWithPrivateKey(this.tbsView,e,r);this.signatureValue=new o.BitString({valueHex:i})}async verify(e=sc(!0)){return e.verifyWithPublicKey(this.tbsView,this.signatureValue,this.subjectPublicKeyInfo,this.signatureAlgorithm)}async getPublicKey(e,t=sc(!0)){return t.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}}l5.CLASS_NAME="CertificationRequest";let l6="digestAlgorithm",l9="digest",l7=[l6,l9];class oe extends y{constructor(e={}){super(),this.digestAlgorithm=h.H$(e,l6,oe.defaultValues(l6)),this.digest=h.H$(e,l9,oe.defaultValues(l9)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case l6:return new L;case l9:return new o.OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case l6:return L.compareWithDefault("algorithmId",t.algorithmId)&&"algorithmParams"in t==!1;case l9:return t.isEqual(oe.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[L.schema(t.digestAlgorithm||{names:{blockName:l6}}),new o.OctetString({name:t.digest||l9})]})}fromSchema(e){h.ze(e,l7);let t=o.compareSchema(e,e,oe.schema({names:{digestAlgorithm:{names:{blockName:l6}},digest:l9}}));S.assertSchema(t,this.className),this.digestAlgorithm=new L({schema:t.result.digestAlgorithm}),this.digest=t.result.digest}toSchema(){return new o.Sequence({value:[this.digestAlgorithm.toSchema(),this.digest]})}toJSON(){return{digestAlgorithm:this.digestAlgorithm.toJSON(),digest:this.digest.toJSON()}}}oe.CLASS_NAME="DigestInfo";let ot="eContentType",oa="eContent",os=[ot,oa];class or extends y{constructor(e={}){if(super(),this.eContentType=h.H$(e,ot,or.defaultValues(ot)),oa in e&&(this.eContent=h.H$(e,oa,or.defaultValues(oa)),1===this.eContent.idBlock.tagClass&&4===this.eContent.idBlock.tagNumber&&!1===this.eContent.idBlock.isConstructed)){let e=new o.OctetString({idBlock:{isConstructed:!0},isConstructed:!0}),t=0,a=this.eContent.valueBlock.valueHexView.slice().buffer,s=a.byteLength;for(;s>0;){let r=new Uint8Array(a,t,t+65536>a.byteLength?a.byteLength-t:65536),i=new ArrayBuffer(r.length),n=new Uint8Array(i);for(let e=0;e<n.length;e++)n[e]=r[e];e.valueBlock.value.push(new o.OctetString({valueHex:i})),s-=r.length,t+=r.length}this.eContent=e}e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ot:return"";case oa:return new o.OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ot:return""===t;case oa:if(1===t.idBlock.tagClass&&4===t.idBlock.tagNumber)return t.isEqual(or.defaultValues(oa));return!1;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.eContentType||""}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Any({name:t.eContent||""})]})]})}fromSchema(e){h.ze(e,os);let t=o.compareSchema(e,e,or.schema({names:{eContentType:ot,eContent:oa}}));S.assertSchema(t,this.className),this.eContentType=t.result.eContentType.valueBlock.toString(),oa in t.result&&(this.eContent=t.result.eContent)}toSchema(){let e=[];return e.push(new o.ObjectIdentifier({value:this.eContentType})),this.eContent&&!1===or.compareWithDefault(oa,this.eContent)&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.eContent]})),new o.Sequence({value:e})}toJSON(){let e={eContentType:this.eContentType};return this.eContent&&!1===or.compareWithDefault(oa,this.eContent)&&(e.eContent=this.eContent.toJSON()),e}}or.CLASS_NAME="EncapsulatedContentInfo";class oi extends aW{constructor(e={}){super(e)}}let on="macSalt",ou="iterations",ol=["mac",on,ou];class oo extends y{constructor(e={}){super(),this.mac=h.H$(e,"mac",oo.defaultValues("mac")),this.macSalt=h.H$(e,on,oo.defaultValues(on)),ou in e&&(this.iterations=h.H$(e,ou,oo.defaultValues(ou))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"mac":return new oe;case on:return new o.OctetString;case ou:return 1;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"mac":return oe.compareWithDefault("digestAlgorithm",t.digestAlgorithm)&&oe.compareWithDefault("digest",t.digest);case on:return t.isEqual(oo.defaultValues(e));case ou:return t===oo.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",optional:t.optional||!0,value:[oe.schema(t.mac||{names:{blockName:"mac"}}),new o.OctetString({name:t.macSalt||on}),new o.Integer({optional:!0,name:t.iterations||ou})]})}fromSchema(e){h.ze(e,ol);let t=o.compareSchema(e,e,oo.schema({names:{mac:{names:{blockName:"mac"}},macSalt:on,iterations:ou}}));S.assertSchema(t,this.className),this.mac=new oe({schema:t.result.mac}),this.macSalt=t.result.macSalt,ou in t.result&&(this.iterations=t.result.iterations.valueBlock.valueDec)}toSchema(){let e=[this.mac.toSchema(),this.macSalt];return void 0!==this.iterations&&e.push(new o.Integer({value:this.iterations})),new o.Sequence({value:e})}toJSON(){let e={mac:this.mac.toJSON(),macSalt:this.macSalt.toJSON()};return void 0!==this.iterations&&(e.iterations=this.iterations),e}}oo.CLASS_NAME="MacData";let oc="hashAlgorithm",oh="hashedMessage",om=[oc,oh];class of extends y{constructor(e={}){super(),this.hashAlgorithm=h.H$(e,oc,of.defaultValues(oc)),this.hashedMessage=h.H$(e,oh,of.defaultValues(oh)),e.schema&&this.fromSchema(e.schema)}static async create(e,t,a=sc(!0)){let s=a.getOIDByAlgorithm({name:e},!0,"hashAlgorithm"),r=await a.digest(e,t),i=new of({hashAlgorithm:new L({algorithmId:s,algorithmParams:new o.Null}),hashedMessage:new o.OctetString({valueHex:r})});return i}static defaultValues(e){switch(e){case oc:return new L;case oh:return new o.OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case oc:return""===t.algorithmId&&"algorithmParams"in t==!1;case oh:return 0===t.isEqual(of.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[L.schema(t.hashAlgorithm||{}),new o.OctetString({name:t.hashedMessage||""})]})}fromSchema(e){h.ze(e,om);let t=o.compareSchema(e,e,of.schema({names:{hashAlgorithm:{names:{blockName:oc}},hashedMessage:oh}}));S.assertSchema(t,this.className),this.hashAlgorithm=new L({schema:t.result.hashAlgorithm}),this.hashedMessage=t.result.hashedMessage}toSchema(){return new o.Sequence({value:[this.hashAlgorithm.toSchema(),this.hashedMessage]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),hashedMessage:this.hashedMessage.toJSON()}}}of.CLASS_NAME="MessageImprint";let od="reqCert",og="singleRequestExtensions",op=[od,og];class oS extends y{constructor(e={}){super(),this.reqCert=h.H$(e,od,oS.defaultValues(od)),og in e&&(this.singleRequestExtensions=h.H$(e,og,oS.defaultValues(og))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case od:return new lu;case og:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case od:return t.isEqual(oS.defaultValues(e));case og:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[lu.schema(t.reqCert||{}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[sF.schema(t.extensions||{names:{blockName:t.singleRequestExtensions||""}})]})]})}fromSchema(e){h.ze(e,op);let t=o.compareSchema(e,e,oS.schema({names:{reqCert:{names:{blockName:od}},extensions:{names:{blockName:og}}}}));S.assertSchema(t,this.className),this.reqCert=new lu({schema:t.result.reqCert}),og in t.result&&(this.singleRequestExtensions=Array.from(t.result.singleRequestExtensions.valueBlock.value,e=>new sF({schema:e})))}toSchema(){let e=[];return e.push(this.reqCert.toSchema()),this.singleRequestExtensions&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Sequence({value:Array.from(this.singleRequestExtensions,e=>e.toSchema())})]})),new o.Sequence({value:e})}toJSON(){let e={reqCert:this.reqCert.toJSON()};return this.singleRequestExtensions&&(e.singleRequestExtensions=Array.from(this.singleRequestExtensions,e=>e.toJSON())),e}}oS.CLASS_NAME="Request";let oy="version",ow="requestorName",ov="requestList",ob="requestExtensions",oA="TBSRequest",ok=`${oA}.${oy}`,oC=`${oA}.${ow}`,oN=`${oA}.requests`,oV=`${oA}.${ob}`,oI=[oA,ok,oC,oN,oV];class oB extends y{constructor(e={}){super(),this.tbsView=new Uint8Array(h.H$(e,"tbs",oB.defaultValues("tbs"))),oy in e&&(this.version=h.H$(e,oy,oB.defaultValues(oy))),ow in e&&(this.requestorName=h.H$(e,ow,oB.defaultValues(ow))),this.requestList=h.H$(e,ov,oB.defaultValues(ov)),ob in e&&(this.requestExtensions=h.H$(e,ob,oB.defaultValues(ob))),e.schema&&this.fromSchema(e.schema)}get tbs(){return c.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case"tbs":return d;case oy:return 0;case ow:return new E;case ov:case ob:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"tbs":return 0===t.byteLength;case oy:return t===oB.defaultValues(e);case ow:return t.type===E.defaultValues("type")&&0===Object.keys(t.value).length;case ov:case ob:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||oA,value:[new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Integer({name:t.TBSRequestVersion||ok})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[E.schema(t.requestorName||{names:{blockName:oC}})]}),new o.Sequence({name:t.requestList||"TBSRequest.requestList",value:[new o.Repeated({name:t.requests||oN,value:oS.schema(t.requestNames||{})})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[sX.schema(t.extensions||{names:{blockName:t.requestExtensions||oV}})]})]})}fromSchema(e){h.ze(e,oI);let t=o.compareSchema(e,e,oB.schema());S.assertSchema(t,this.className),this.tbsView=t.result.TBSRequest.valueBeforeDecodeView,ok in t.result&&(this.version=t.result[ok].valueBlock.valueDec),oC in t.result&&(this.requestorName=new E({schema:t.result[oC]})),this.requestList=Array.from(t.result[oN],e=>new oS({schema:e})),oV in t.result&&(this.requestExtensions=Array.from(t.result[oV].valueBlock.value,e=>new sF({schema:e})))}toSchema(e=!1){let t;if(!1===e){if(0===this.tbsView.byteLength)return oB.schema();let e=o.fromBER(this.tbsView);if(S.assert(e,"TBS Request"),!(e.result instanceof o.Sequence))throw Error("ASN.1 result should be SEQUENCE");t=e.result}else{let e=[];void 0!==this.version&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Integer({value:this.version})]})),this.requestorName&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.requestorName.toSchema()]})),e.push(new o.Sequence({value:Array.from(this.requestList,e=>e.toSchema())})),this.requestExtensions&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:[new o.Sequence({value:Array.from(this.requestExtensions,e=>e.toSchema())})]})),t=new o.Sequence({value:e})}return t}toJSON(){let e={};return void 0!=this.version&&(e.version=this.version),this.requestorName&&(e.requestorName=this.requestorName.toJSON()),e.requestList=Array.from(this.requestList,e=>e.toJSON()),this.requestExtensions&&(e.requestExtensions=Array.from(this.requestExtensions,e=>e.toJSON())),e}}oB.CLASS_NAME="TBSRequest";let oE="signatureAlgorithm",oH="signature",oD="certs";class oO extends y{constructor(e={}){super(),this.signatureAlgorithm=h.H$(e,oE,oO.defaultValues(oE)),this.signature=h.H$(e,oH,oO.defaultValues(oH)),oD in e&&(this.certs=h.H$(e,oD,oO.defaultValues(oD))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case oE:return new L;case oH:return new o.BitString;case oD:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case oE:return""===t.algorithmId&&"algorithmParams"in t==!1;case oH:return t.isEqual(oO.defaultValues(e));case oD:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[L.schema(t.signatureAlgorithm||{}),new o.BitString({name:t.signature||""}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Sequence({value:[new o.Repeated({name:t.certs||"",value:ip.schema({})})]})]})]})}fromSchema(e){h.ze(e,[oE,oH,oD]);let t=o.compareSchema(e,e,oO.schema({names:{signatureAlgorithm:{names:{blockName:oE}},signature:oH,certs:oD}}));S.assertSchema(t,this.className),this.signatureAlgorithm=new L({schema:t.result.signatureAlgorithm}),this.signature=t.result.signature,oD in t.result&&(this.certs=Array.from(t.result.certs,e=>new ip({schema:e})))}toSchema(){let e=[];return e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.certs&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Sequence({value:Array.from(this.certs,e=>e.toSchema())})]})),new o.Sequence({value:e})}toJSON(){let e={signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.certs&&(e.certs=Array.from(this.certs,e=>e.toJSON())),e}}oO.CLASS_NAME="Signature";let ox="tbsRequest",oP="optionalSignature",o$=[ox,oP];class oq extends y{constructor(e={}){super(),this.tbsRequest=h.H$(e,ox,oq.defaultValues(ox)),oP in e&&(this.optionalSignature=h.H$(e,oP,oq.defaultValues(oP))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ox:return new oB;case oP:return new oO;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ox:return oB.compareWithDefault("tbs",t.tbs)&&oB.compareWithDefault("version",t.version)&&oB.compareWithDefault("requestorName",t.requestorName)&&oB.compareWithDefault("requestList",t.requestList)&&oB.compareWithDefault("requestExtensions",t.requestExtensions);case oP:return oO.compareWithDefault("signatureAlgorithm",t.signatureAlgorithm)&&oO.compareWithDefault("signature",t.signature)&&oO.compareWithDefault("certs",t.certs);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"OCSPRequest",value:[oB.schema(t.tbsRequest||{names:{blockName:ox}}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[oO.schema(t.optionalSignature||{names:{blockName:oP}})]})]})}fromSchema(e){h.ze(e,o$);let t=o.compareSchema(e,e,oq.schema());S.assertSchema(t,this.className),this.tbsRequest=new oB({schema:t.result.tbsRequest}),oP in t.result&&(this.optionalSignature=new oO({schema:t.result.optionalSignature}))}toSchema(e=!1){let t=[];return t.push(this.tbsRequest.toSchema(e)),this.optionalSignature&&t.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.optionalSignature.toSchema()]})),new o.Sequence({value:t})}toJSON(){let e={tbsRequest:this.tbsRequest.toJSON()};return this.optionalSignature&&(e.optionalSignature=this.optionalSignature.toJSON()),e}async createForCertificate(e,t,a=sc(!0)){let s=new lu;await s.createForCertificate(e,t,a),this.tbsRequest.requestList.push(new oS({reqCert:s}))}async sign(e,t="SHA-1",a=sc(!0)){if(p.assertEmpty(e,"privateKey","OCSPRequest.sign method"),!this.optionalSignature)throw Error('Need to create "optionalSignature" field before signing');let s=await a.getSignatureParameters(e,t),r=s.parameters;this.optionalSignature.signatureAlgorithm=s.signatureAlgorithm;let i=this.tbsRequest.toSchema(!0).toBER(!1),n=await a.signWithPrivateKey(i,e,r);this.optionalSignature.signature=new o.BitString({valueHex:n})}verify(){}}oq.CLASS_NAME="OCSPRequest";let oK="responseType",oR="response",oJ=[oK,oR];class oU extends y{constructor(e={}){super(),this.responseType=h.H$(e,oK,oU.defaultValues(oK)),this.response=h.H$(e,oR,oU.defaultValues(oR)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case oK:return"";case oR:return new o.OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case oK:return""===t;case oR:return t.isEqual(oU.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.responseType||""}),new o.OctetString({name:t.response||""})]})}fromSchema(e){h.ze(e,oJ);let t=o.compareSchema(e,e,oU.schema({names:{responseType:oK,response:oR}}));S.assertSchema(t,this.className),this.responseType=t.result.responseType.valueBlock.toString(),this.response=t.result.response}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.responseType}),this.response]})}toJSON(){return{responseType:this.responseType,response:this.response.toJSON()}}}oU.CLASS_NAME="ResponseBytes";let oT="responseStatus",oj="responseBytes";class oL extends y{constructor(e={}){super(),this.responseStatus=h.H$(e,oT,oL.defaultValues(oT)),oj in e&&(this.responseBytes=h.H$(e,oj,oL.defaultValues(oj))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case oT:return new o.Enumerated;case oj:return new oU;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case oT:return t.isEqual(oL.defaultValues(e));case oj:return oU.compareWithDefault("responseType",t.responseType)&&oU.compareWithDefault("response",t.response);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"OCSPResponse",value:[new o.Enumerated({name:t.responseStatus||oT}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[oU.schema(t.responseBytes||{names:{blockName:oj}})]})]})}fromSchema(e){h.ze(e,[oT,oj]);let t=o.compareSchema(e,e,oL.schema());S.assertSchema(t,this.className),this.responseStatus=t.result.responseStatus,oj in t.result&&(this.responseBytes=new oU({schema:t.result.responseBytes}))}toSchema(){let e=[];return e.push(this.responseStatus),this.responseBytes&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.responseBytes.toSchema()]})),new o.Sequence({value:e})}toJSON(){let e={responseStatus:this.responseStatus.toJSON()};return this.responseBytes&&(e.responseBytes=this.responseBytes.toJSON()),e}async getCertificateStatus(e,t,a=sc(!0)){let s;let r={isForCertificate:!1,status:2};if(!this.responseBytes||this.responseBytes.responseType!==ez)return r;try{let e=o.fromBER(this.responseBytes.response.valueBlock.valueHexView);S.assert(e,"Basic OCSP response"),s=new lz({schema:e.result})}catch(e){return r}return s.getCertificateStatus(e,t,a)}async sign(e,t,a=sc(!0)){var s;if(this.responseBytes&&this.responseBytes.responseType===ez){let s=lz.fromBER(this.responseBytes.response.valueBlock.valueHexView);return s.sign(e,t,a)}throw Error(`Unknown ResponseBytes type: ${(null===(s=this.responseBytes)||void 0===s?void 0:s.responseType)||"Unknown"}`)}async verify(e=null,t=sc(!0)){var a;if(oj in this==!1)throw Error("Empty ResponseBytes field");if(this.responseBytes&&this.responseBytes.responseType===ez){let a=lz.fromBER(this.responseBytes.response.valueBlock.valueHexView);return null!==e&&(a.certs||(a.certs=[]),a.certs.push(e)),a.verify({},t)}throw Error(`Unknown ResponseBytes type: ${(null===(a=this.responseBytes)||void 0===a?void 0:a.responseType)||"Unknown"}`)}}oL.CLASS_NAME="OCSPResponse";let oM="type",o_="attributes",oW="encodedValue",oz=[o_];class oF extends y{constructor(e={}){super(),this.type=h.H$(e,oM,oF.defaultValues(oM)),this.attributes=h.H$(e,o_,oF.defaultValues(o_)),this.encodedValue=h.H$(e,oW,oF.defaultValues(oW)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case oM:return -1;case o_:return[];case oW:return d;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case oM:return t===oF.defaultValues(oM);case o_:return 0===t.length;case oW:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Constructed({name:t.blockName||"",optional:!0,idBlock:{tagClass:3,tagNumber:t.tagNumber||0},value:[new o.Repeated({name:t.attributes||"",value:Q.schema()})]})}fromSchema(e){h.ze(e,oz);let t=o.compareSchema(e,e,oF.schema({names:{tagNumber:this.type,attributes:o_}}));S.assertSchema(t,this.className),this.type=t.result.idBlock.tagNumber,this.encodedValue=c.vJ.toArrayBuffer(t.result.valueBeforeDecodeView);let a=new Uint8Array(this.encodedValue);if(a[0]=49,o_ in t.result==!1){if(0!==this.type)return;throw Error("Wrong structure of SignedUnsignedAttributes")}this.attributes=Array.from(t.result.attributes,e=>new Q({schema:e}))}toSchema(){if(oF.compareWithDefault(oM,this.type)||oF.compareWithDefault(o_,this.attributes))throw Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:this.type},value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){if(oF.compareWithDefault(oM,this.type)||oF.compareWithDefault(o_,this.attributes))throw Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return{type:this.type,attributes:Array.from(this.attributes,e=>e.toJSON())}}}oF.CLASS_NAME="SignedAndUnsignedAttributes";let oG="version",oQ="digestAlgorithm",oX="signedAttrs",oY="signatureAlgorithm",oZ="signature",o1="unsignedAttrs",o0="SignerInfo",o2=`${o0}.${oG}`,o3=`${o0}.sid`,o4=`${o0}.${oQ}`,o8=`${o0}.${oX}`,o5=`${o0}.${oY}`,o6=`${o0}.${oZ}`,o9=`${o0}.${o1}`,o7=[o2,o3,o4,o8,o5,o6,o9];class ce extends y{constructor(e={}){super(),this.version=h.H$(e,oG,ce.defaultValues(oG)),this.sid=h.H$(e,"sid",ce.defaultValues("sid")),this.digestAlgorithm=h.H$(e,oQ,ce.defaultValues(oQ)),oX in e&&(this.signedAttrs=h.H$(e,oX,ce.defaultValues(oX))),this.signatureAlgorithm=h.H$(e,oY,ce.defaultValues(oY)),this.signature=h.H$(e,oZ,ce.defaultValues(oZ)),o1 in e&&(this.unsignedAttrs=h.H$(e,o1,ce.defaultValues(o1))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case oG:return 0;case"sid":return new o.Any;case oQ:return new L;case oX:return new oF({type:0});case oY:return new L;case oZ:return new o.OctetString;case o1:return new oF({type:1});default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case oG:return ce.defaultValues(oG)===t;case"sid":return t instanceof o.Any;case oQ:if(t instanceof L==!1)return!1;return t.isEqual(ce.defaultValues(oQ));case oX:return oF.compareWithDefault("type",t.type)&&oF.compareWithDefault("attributes",t.attributes)&&oF.compareWithDefault("encodedValue",t.encodedValue);case oY:if(t instanceof L==!1)return!1;return t.isEqual(ce.defaultValues(oY));case oZ:case o1:return oF.compareWithDefault("type",t.type)&&oF.compareWithDefault("attributes",t.attributes)&&oF.compareWithDefault("encodedValue",t.encodedValue);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:o0,value:[new o.Integer({name:t.version||o2}),new o.Choice({value:[nx.schema(t.sidSchema||{names:{blockName:o3}}),new o.Choice({value:[new o.Constructed({optional:!0,name:t.sid||o3,idBlock:{tagClass:3,tagNumber:0},value:[new o.OctetString]}),new o.Primitive({optional:!0,name:t.sid||o3,idBlock:{tagClass:3,tagNumber:0}})]})]}),L.schema(t.digestAlgorithm||{names:{blockName:o4}}),oF.schema(t.signedAttrs||{names:{blockName:o8,tagNumber:0}}),L.schema(t.signatureAlgorithm||{names:{blockName:o5}}),new o.OctetString({name:t.signature||o6}),oF.schema(t.unsignedAttrs||{names:{blockName:o9,tagNumber:1}})]})}fromSchema(e){h.ze(e,o7);let t=o.compareSchema(e,e,ce.schema());S.assertSchema(t,this.className),this.version=t.result[o2].valueBlock.valueDec;let a=t.result[o3];1===a.idBlock.tagClass?this.sid=new nx({schema:a}):this.sid=a,this.digestAlgorithm=new L({schema:t.result[o4]}),o8 in t.result&&(this.signedAttrs=new oF({type:0,schema:t.result[o8]})),this.signatureAlgorithm=new L({schema:t.result[o5]}),this.signature=t.result[o6],o9 in t.result&&(this.unsignedAttrs=new oF({type:1,schema:t.result[o9]}))}toSchema(){if(ce.compareWithDefault("sid",this.sid))throw Error('Incorrectly initialized "SignerInfo" class');let e=[];return e.push(new o.Integer({value:this.version})),this.sid instanceof nx?e.push(this.sid.toSchema()):e.push(this.sid),e.push(this.digestAlgorithm.toSchema()),this.signedAttrs&&!1===ce.compareWithDefault(oX,this.signedAttrs)&&e.push(this.signedAttrs.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.unsignedAttrs&&!1===ce.compareWithDefault(o1,this.unsignedAttrs)&&e.push(this.unsignedAttrs.toSchema()),new o.Sequence({value:e})}toJSON(){if(ce.compareWithDefault("sid",this.sid))throw Error('Incorrectly initialized "SignerInfo" class');let e={version:this.version,digestAlgorithm:this.digestAlgorithm.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.sid instanceof o.Any||(e.sid=this.sid.toJSON()),this.signedAttrs&&!1===ce.compareWithDefault(oX,this.signedAttrs)&&(e.signedAttrs=this.signedAttrs.toJSON()),this.unsignedAttrs&&!1===ce.compareWithDefault(o1,this.unsignedAttrs)&&(e.unsignedAttrs=this.unsignedAttrs.toJSON()),e}}ce.CLASS_NAME="SignerInfo";let ct="version",ca="policy",cs="messageImprint",cr="serialNumber",ci="genTime",cn="ordering",cu="nonce",cl="accuracy",co="extensions",cc="TSTInfo",ch=`${cc}.${ct}`,cm=`${cc}.${ca}`,cf=`${cc}.${cs}`,cd=`${cc}.${cr}`,cg=`${cc}.${ci}`,cp=`${cc}.${cl}`,cS=`${cc}.${cn}`,cy=`${cc}.${cu}`,cw=`${cc}.tsa`,cv=`${cc}.${co}`,cb=[ch,cm,cf,cd,cg,cp,cS,cy,cw,cv];class cA extends y{constructor(e={}){super(),this.version=h.H$(e,ct,cA.defaultValues(ct)),this.policy=h.H$(e,ca,cA.defaultValues(ca)),this.messageImprint=h.H$(e,cs,cA.defaultValues(cs)),this.serialNumber=h.H$(e,cr,cA.defaultValues(cr)),this.genTime=h.H$(e,ci,cA.defaultValues(ci)),cl in e&&(this.accuracy=h.H$(e,cl,cA.defaultValues(cl))),cn in e&&(this.ordering=h.H$(e,cn,cA.defaultValues(cn))),cu in e&&(this.nonce=h.H$(e,cu,cA.defaultValues(cu))),"tsa"in e&&(this.tsa=h.H$(e,"tsa",cA.defaultValues("tsa"))),co in e&&(this.extensions=h.H$(e,co,cA.defaultValues(co))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ct:return 0;case ca:return"";case cs:return new of;case cr:return new o.Integer;case ci:return new Date(0,0,0);case cl:return new K;case cn:return!1;case cu:return new o.Integer;case"tsa":return new E;case co:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ct:case ca:case ci:case cn:return t===cA.defaultValues(cn);case cs:return of.compareWithDefault(oc,t.hashAlgorithm)&&of.compareWithDefault(oh,t.hashedMessage);case cr:case cu:return t.isEqual(cA.defaultValues(cu));case cl:return K.compareWithDefault(P,t.seconds)&&K.compareWithDefault($,t.millis)&&K.compareWithDefault(q,t.micros);case"tsa":return E.compareWithDefault(I,t.type)&&E.compareWithDefault(B,t.value);case co:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||cc,value:[new o.Integer({name:t.version||ch}),new o.ObjectIdentifier({name:t.policy||cm}),of.schema(t.messageImprint||{names:{blockName:cf}}),new o.Integer({name:t.serialNumber||cd}),new o.GeneralizedTime({name:t.genTime||cg}),K.schema(t.accuracy||{names:{blockName:cp}}),new o.Boolean({name:t.ordering||cS,optional:!0}),new o.Integer({name:t.nonce||cy,optional:!0}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[E.schema(t.tsa||{names:{blockName:cw}})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.Repeated({name:t.extensions||cv,value:sF.schema(t.extension||{})})]})]})}fromSchema(e){h.ze(e,cb);let t=o.compareSchema(e,e,cA.schema());S.assertSchema(t,this.className),this.version=t.result[ch].valueBlock.valueDec,this.policy=t.result[cm].valueBlock.toString(),this.messageImprint=new of({schema:t.result[cf]}),this.serialNumber=t.result[cd],this.genTime=t.result[cg].toDate(),cp in t.result&&(this.accuracy=new K({schema:t.result[cp]})),cS in t.result&&(this.ordering=t.result[cS].valueBlock.value),cy in t.result&&(this.nonce=t.result[cy]),cw in t.result&&(this.tsa=new E({schema:t.result[cw]})),cv in t.result&&(this.extensions=Array.from(t.result[cv],e=>new sF({schema:e})))}toSchema(){let e=[];return e.push(new o.Integer({value:this.version})),e.push(new o.ObjectIdentifier({value:this.policy})),e.push(this.messageImprint.toSchema()),e.push(this.serialNumber),e.push(new o.GeneralizedTime({valueDate:this.genTime})),this.accuracy&&e.push(this.accuracy.toSchema()),void 0!==this.ordering&&e.push(new o.Boolean({value:this.ordering})),this.nonce&&e.push(this.nonce),this.tsa&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.tsa.toSchema()]})),this.extensions&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.extensions,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={version:this.version,policy:this.policy,messageImprint:this.messageImprint.toJSON(),serialNumber:this.serialNumber.toJSON(),genTime:this.genTime};return this.accuracy&&(e.accuracy=this.accuracy.toJSON()),void 0!==this.ordering&&(e.ordering=this.ordering),this.nonce&&(e.nonce=this.nonce.toJSON()),this.tsa&&(e.tsa=this.tsa.toJSON()),this.extensions&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}async verify(e,t=sc(!0)){if(!e.data)throw Error('"data" is a mandatory attribute for TST_INFO verification');let a=e.data;if(e.notBefore&&this.genTime<e.notBefore)throw Error("Generation time for TSTInfo object is less than notBefore value");if(e.notAfter&&this.genTime>e.notAfter)throw Error("Generation time for TSTInfo object is more than notAfter value");let s=t.getAlgorithmByOID(this.messageImprint.hashAlgorithm.algorithmId,!0,"MessageImprint.hashAlgorithm"),r=await t.digest(s.name,new Uint8Array(a));return c.vJ.isEqual(r,this.messageImprint.hashedMessage.valueBlock.valueHexView)}}cA.CLASS_NAME="TSTInfo";let ck="version",cC="digestAlgorithms",cN="encapContentInfo",cV="certificates",cI="crls",cB="signerInfos",cE="ocsps",cH="SignedData",cD=`${cH}.${ck}`,cO=`${cH}.${cC}`,cx=`${cH}.${cN}`,cP=`${cH}.${cV}`,c$=`${cH}.${cI}`,cq=`${cH}.${cB}`,cK=[cD,cO,cx,cP,c$,cq];class cR extends Error{constructor({message:e,code:t=0,date:a=new Date,signatureVerified:s=null,signerCertificate:r=null,signerCertificateVerified:i=null,timestampSerial:n=null,certificatePath:u=[]}){super(e),this.name="SignedDataVerifyError",this.date=a,this.code=t,this.timestampSerial=n,this.signatureVerified=s,this.signerCertificate=r,this.signerCertificateVerified=i,this.certificatePath=u}}class cJ extends y{constructor(e={}){super(),this.version=h.H$(e,ck,cJ.defaultValues(ck)),this.digestAlgorithms=h.H$(e,cC,cJ.defaultValues(cC)),this.encapContentInfo=h.H$(e,cN,cJ.defaultValues(cN)),cV in e&&(this.certificates=h.H$(e,cV,cJ.defaultValues(cV))),cI in e&&(this.crls=h.H$(e,cI,cJ.defaultValues(cI))),cE in e&&(this.ocsps=h.H$(e,cE,cJ.defaultValues(cE))),this.signerInfos=h.H$(e,cB,cJ.defaultValues(cB)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ck:return 0;case cC:return[];case cN:return new or;case cV:case cI:case cE:case cB:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ck:return t===cJ.defaultValues(ck);case cN:return or.compareWithDefault("eContentType",t.eContentType)&&or.compareWithDefault("eContent",t.eContent);case cC:case cV:case cI:case cE:case cB:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return void 0===t.optional&&(t.optional=!1),new o.Sequence({name:t.blockName||cH,optional:t.optional,value:[new o.Integer({name:t.version||cD}),new o.Set({value:[new o.Repeated({name:t.digestAlgorithms||cO,value:L.schema()})]}),or.schema(t.encapContentInfo||{names:{blockName:cx}}),new o.Constructed({name:t.certificates||cP,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:nS.schema().valueBlock.value}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:nN.schema(t.crls||{names:{crls:c$}}).valueBlock.value}),new o.Set({value:[new o.Repeated({name:t.signerInfos||cq,value:ce.schema()})]})]})}fromSchema(e){h.ze(e,cK);let t=o.compareSchema(e,e,cJ.schema());if(S.assertSchema(t,this.className),this.version=t.result[cD].valueBlock.valueDec,cO in t.result&&(this.digestAlgorithms=Array.from(t.result[cO],e=>new L({schema:e}))),this.encapContentInfo=new or({schema:t.result[cx]}),cP in t.result){let e=new nS({schema:new o.Set({value:t.result[cP].valueBlock.value})});this.certificates=e.certificates.slice(0)}c$ in t.result&&(this.crls=Array.from(t.result[c$],e=>1===e.idBlock.tagClass?new iz({schema:e}):(e.idBlock.tagClass=1,e.idBlock.tagNumber=16,new nb({schema:e})))),cq in t.result&&(this.signerInfos=Array.from(t.result[cq],e=>new ce({schema:e})))}toSchema(e=!1){let t=[];if(this.certificates&&this.certificates.length&&this.certificates.some(e=>e instanceof nd)||this.crls&&this.crls.length&&this.crls.some(e=>e instanceof nb)?this.version=5:this.certificates&&this.certificates.length&&this.certificates.some(e=>e instanceof rT)?this.version=4:this.certificates&&this.certificates.length&&this.certificates.some(e=>e instanceof ro)||this.signerInfos.some(e=>3===e.version)||this.encapContentInfo.eContentType!==cJ.ID_DATA?this.version=3:this.version=1,t.push(new o.Integer({value:this.version})),t.push(new o.Set({value:Array.from(this.digestAlgorithms,e=>e.toSchema())})),t.push(this.encapContentInfo.toSchema()),this.certificates){let e=new nS({certificates:this.certificates}),a=e.toSchema();t.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:a.valueBlock.value}))}return this.crls&&t.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.crls,t=>{if(t instanceof nb){let e=t.toSchema();return e.idBlock.tagClass=3,e.idBlock.tagNumber=1,e}return t.toSchema(e)})})),t.push(new o.Set({value:Array.from(this.signerInfos,e=>e.toSchema())})),new o.Sequence({value:t})}toJSON(){let e={version:this.version,digestAlgorithms:Array.from(this.digestAlgorithms,e=>e.toJSON()),encapContentInfo:this.encapContentInfo.toJSON(),signerInfos:Array.from(this.signerInfos,e=>e.toJSON())};return this.certificates&&(e.certificates=Array.from(this.certificates,e=>e.toJSON())),this.crls&&(e.crls=Array.from(this.crls,e=>e.toJSON())),e}async verify({signer:e=-1,data:t=d,trustedCerts:a=[],checkDate:s=new Date,checkChain:r=!1,passedWhenNotRevValues:i=!1,extendedMode:n=!1,findOrigin:u=null,findIssuer:l=null}={},o=sc(!0)){let c=null,m=null;try{let f=d,g="",p=[],S=this.signerInfos[e];if(!S)throw new cR({date:s,code:1,message:"Unable to get signer by supplied index"});if(!this.certificates)throw new cR({date:s,code:2,message:"No certificates attached to this signed data"});if(S.sid instanceof nx){for(let e of this.certificates)if(e instanceof ip&&e.issuer.isEqual(S.sid.issuer)&&e.serialNumber.isEqual(S.sid.serialNumber)){c=e;break}}else{let e=S.sid,t=e.idBlock.isConstructed?e.valueBlock.value[0].valueBlock.valueHex:e.valueBlock.valueHex;for(let e of this.certificates){if(!(e instanceof ip))continue;let a=await o.digest({name:"sha-1"},e.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);if(h.dN(a,t)){c=e;break}}}if(!c)throw new cR({date:s,code:3,message:"Unable to find signer certificate"});if(this.encapContentInfo.eContentType===eU){let e;if(!this.encapContentInfo.eContent)throw new cR({date:s,code:15,message:"Error during verification: TSTInfo eContent is empty",signatureVerified:null,signerCertificate:c,timestampSerial:m,signerCertificateVerified:!0});try{e=cA.fromBER(this.encapContentInfo.eContent.valueBlock.valueHexView)}catch(e){throw new cR({date:s,code:15,message:"Error during verification: TSTInfo wrong ASN.1 schema ",signatureVerified:null,signerCertificate:c,timestampSerial:m,signerCertificateVerified:!0})}if(s=e.genTime,m=e.serialNumber.valueBlock.valueHexView.slice(),0===t.byteLength)throw new cR({date:s,code:4,message:"Missed detached data input array"});if(!await e.verify({data:t},o))throw new cR({date:s,code:15,message:"Error during verification: TSTInfo verification is failed",signatureVerified:!1,signerCertificate:c,timestampSerial:m,signerCertificateVerified:!0})}if(r){let e=this.certificates.filter(e=>e instanceof ip&&!!iS(e,c)),t={checkDate:s,certs:e,trustedCerts:a};l&&(t.findIssuer=l),u&&(t.findOrigin=u);let r=new lq(t);if(r.certs.push(c),this.crls)for(let e of this.crls)"thisUpdate"in e?r.crls.push(e):e.otherRevInfoFormat===ez&&r.ocsps.push(new lz({schema:e.otherRevInfo}));this.ocsps&&r.ocsps.push(...this.ocsps);let n=await r.verify({passedWhenNotRevValues:i},o).catch(e=>{throw new cR({date:s,code:5,message:`Validation of signer's certificate failed with error: ${e instanceof Object?e.resultMessage:e}`,signerCertificate:c,signerCertificateVerified:!1})});if(n.certificatePath&&(p=n.certificatePath),!n.result)throw new cR({date:s,code:5,message:`Validation of signer's certificate failed: ${n.resultMessage}`,signerCertificate:c,signerCertificateVerified:!1})}let y=o.getAlgorithmByOID(S.digestAlgorithm.algorithmId);if(!("name"in y))throw new cR({date:s,code:7,message:`Unsupported signature algorithm: ${S.digestAlgorithm.algorithmId}`,signerCertificate:c,signerCertificateVerified:!0});g=y.name;let w=this.encapContentInfo.eContent;if(w)t=1===w.idBlock.tagClass&&4===w.idBlock.tagNumber?w.getValue():w.valueBlock.valueBeforeDecodeView;else if(0===t.byteLength)throw new cR({date:s,code:8,message:"Missed detached data input array",signerCertificate:c,signerCertificateVerified:!0});if(S.signedAttrs){let e=!1,t=!1;for(let a of S.signedAttrs.attributes)if("1.2.840.113549.1.9.3"===a.type&&(e=!0),"1.2.840.113549.1.9.4"===a.type&&(t=!0,f=a.values[0].valueBlock.valueHex),e&&t)break;if(!1===e)throw new cR({date:s,code:9,message:'Attribute "content-type" is a mandatory attribute for "signed attributes"',signerCertificate:c,signerCertificateVerified:!0});if(!1===t)throw new cR({date:s,code:10,message:'Attribute "message-digest" is a mandatory attribute for "signed attributes"',signatureVerified:null,signerCertificate:c,signerCertificateVerified:!0})}if(S.signedAttrs){let e=await o.digest(g,new Uint8Array(t));if(!h.dN(e,f))throw new cR({date:s,code:15,message:"Error during verification: Message digest doesn't match",signatureVerified:null,signerCertificate:c,timestampSerial:m,signerCertificateVerified:!0});t=S.signedAttrs.encodedValue}let v=await o.verifyWithPublicKey(t,S.signature,c.subjectPublicKeyInfo,c.signatureAlgorithm,g);if(n)return{date:s,code:14,message:"",signatureVerified:v,signerCertificate:c,timestampSerial:m,signerCertificateVerified:!0,certificatePath:p};return v}catch(e){if(e instanceof cR)throw e;throw new cR({date:s,code:15,message:`Error during verification: ${e instanceof Error?e.message:e}`,signatureVerified:null,signerCertificate:c,timestampSerial:m,signerCertificateVerified:!0})}}async sign(e,t,a="SHA-1",s=d,r=sc(!0)){if(!e)throw Error("Need to provide a private key for signing");let i=r.getOIDByAlgorithm({name:a},!0,"hashAlgorithm");0===this.digestAlgorithms.filter(e=>e.algorithmId===i).length&&this.digestAlgorithms.push(new L({algorithmId:i,algorithmParams:new o.Null}));let n=this.signerInfos[t];if(!n)throw RangeError("SignerInfo index is out of range");n.digestAlgorithm=new L({algorithmId:i,algorithmParams:new o.Null});let u=await r.getSignatureParameters(e,a),l=u.parameters;if(n.signatureAlgorithm=u.signatureAlgorithm,n.signedAttrs){if(0!==n.signedAttrs.encodedValue.byteLength)s=n.signedAttrs.encodedValue;else{s=n.signedAttrs.toSchema().toBER();let e=c.vJ.toUint8Array(s);e[0]=49}}else{let e=this.encapContentInfo.eContent;if(e)s=1===e.idBlock.tagClass&&4===e.idBlock.tagNumber?e.getValue():e.valueBlock.valueBeforeDecodeView;else if(0===s.byteLength)throw Error("Missed detached data input array")}let h=await r.signWithPrivateKey(s,e,l);n.signature=new o.OctetString({valueHex:h})}}cJ.CLASS_NAME="SignedData",cJ.ID_DATA=eq;let cU="version",cT="authSafe",cj="macData",cL="parsedValue",cM=[cU,cT,cj];class c_ extends y{constructor(e={}){super(),this.version=h.H$(e,cU,c_.defaultValues(cU)),this.authSafe=h.H$(e,cT,c_.defaultValues(cT)),cj in e&&(this.macData=h.H$(e,cj,c_.defaultValues(cj))),cL in e&&(this.parsedValue=h.H$(e,cL,c_.defaultValues(cL))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case cU:return 3;case cT:return new r_;case cj:return new oo;case cL:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case cU:return t===c_.defaultValues(e);case cT:return r_.compareWithDefault("contentType",t.contentType)&&r_.compareWithDefault("content",t.content);case cj:return oo.compareWithDefault("mac",t.mac)&&oo.compareWithDefault("macSalt",t.macSalt)&&oo.compareWithDefault("iterations",t.iterations);case cL:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||cU}),r_.schema(t.authSafe||{names:{blockName:cT}}),oo.schema(t.macData||{names:{blockName:cj,optional:!0}})]})}fromSchema(e){h.ze(e,cM);let t=o.compareSchema(e,e,c_.schema({names:{version:cU,authSafe:{names:{blockName:cT}},macData:{names:{blockName:cj}}}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.authSafe=new r_({schema:t.result.authSafe}),cj in t.result&&(this.macData=new oo({schema:t.result.macData}))}toSchema(){let e=[new o.Integer({value:this.version}),this.authSafe.toSchema()];return this.macData&&e.push(this.macData.toSchema()),new o.Sequence({value:e})}toJSON(){let e={version:this.version,authSafe:this.authSafe.toJSON()};return this.macData&&(e.macData=this.macData.toJSON()),e}async makeInternalValues(e={},t=sc(!0)){if(g.assert(e,"parameters","object"),!this.parsedValue)throw Error('Please call "parseValues" function first in order to make "parsedValue" data');switch(p.assertEmpty(this.parsedValue.integrityMode,"integrityMode","parsedValue"),p.assertEmpty(this.parsedValue.authenticatedSafe,"authenticatedSafe","parsedValue"),this.parsedValue.integrityMode){case 0:{if(!("iterations"in e))throw new p("iterations");p.assertEmpty(e.pbkdf2HashAlgorithm,"pbkdf2HashAlgorithm"),p.assertEmpty(e.hmacHashAlgorithm,"hmacHashAlgorithm"),p.assertEmpty(e.password,"password");let a=new ArrayBuffer(64),s=new Uint8Array(a);t.getRandomValues(s);let r=this.parsedValue.authenticatedSafe.toSchema().toBER(!1);this.authSafe=new r_({contentType:r_.DATA,content:new o.OctetString({valueHex:r})});let i=await t.stampDataWithPassword({password:e.password,hashAlgorithm:e.hmacHashAlgorithm,salt:a,iterationCount:e.iterations,contentToStamp:r});this.macData=new oo({mac:new oe({digestAlgorithm:new L({algorithmId:t.getOIDByAlgorithm({name:e.hmacHashAlgorithm},!0,"hmacHashAlgorithm")}),digest:new o.OctetString({valueHex:i})}),macSalt:new o.OctetString({valueHex:a}),iterations:e.iterations})}break;case 1:{if(!("signingCertificate"in e))throw new p("signingCertificate");p.assertEmpty(e.privateKey,"privateKey"),p.assertEmpty(e.hashAlgorithm,"hashAlgorithm");let a=this.parsedValue.authenticatedSafe.toSchema().toBER(!1),s=new cJ({version:1,encapContentInfo:new or({eContentType:"1.2.840.113549.1.7.1",eContent:new o.OctetString({valueHex:a})}),certificates:[e.signingCertificate]}),r=await t.digest({name:e.hashAlgorithm},new Uint8Array(a)),i=[];i.push(new Q({type:"1.2.840.113549.1.9.3",values:[new o.ObjectIdentifier({value:"1.2.840.113549.1.7.1"})]})),i.push(new Q({type:"1.2.840.113549.1.9.5",values:[new o.UTCTime({valueDate:new Date})]})),i.push(new Q({type:"1.2.840.113549.1.9.4",values:[new o.OctetString({valueHex:r})]})),s.signerInfos.push(new ce({version:1,sid:new nx({issuer:e.signingCertificate.issuer,serialNumber:e.signingCertificate.serialNumber}),signedAttrs:new oF({type:0,attributes:i})})),await s.sign(e.privateKey,0,e.hashAlgorithm,void 0,t),this.authSafe=new r_({contentType:"1.2.840.113549.1.7.2",content:s.toSchema(!0)})}break;default:throw Error(`Parameter "integrityMode" has unknown value: ${this.parsedValue.integrityMode}`)}}async parseInternalValues(e,t=sc(!0)){switch(g.assert(e,"parameters","object"),void 0===e.checkIntegrity&&(e.checkIntegrity=!0),this.parsedValue={},this.authSafe.contentType){case r_.DATA:{p.assertEmpty(e.password,"password"),this.parsedValue.integrityMode=0,g.assert(this.authSafe.content,"authSafe.content",o.OctetString);let a=this.authSafe.content.getValue();if(this.parsedValue.authenticatedSafe=lt.fromBER(a),e.checkIntegrity){if(!this.macData)throw Error('Absent "macData" value, can not check PKCS#12 data integrity');let s=t.getAlgorithmByOID(this.macData.mac.digestAlgorithm.algorithmId,!0,"digestAlgorithm"),r=await t.verifyDataStampedWithPassword({password:e.password,hashAlgorithm:s.name,salt:c.vJ.toArrayBuffer(this.macData.macSalt.valueBlock.valueHexView),iterationCount:this.macData.iterations||1,contentToVerify:a,signatureToVerify:c.vJ.toArrayBuffer(this.macData.mac.digest.valueBlock.valueHexView)});if(!r)throw Error("Integrity for the PKCS#12 data is broken!")}}break;case r_.SIGNED_DATA:{this.parsedValue.integrityMode=1;let e=new cJ({schema:this.authSafe.content}),a=e.encapContentInfo.eContent;p.assert(a,"eContent","cmsSigned.encapContentInfo"),g.assert(a,"eContent",o.OctetString);let s=a.getValue();this.parsedValue.authenticatedSafe=lt.fromBER(s);let r=await e.verify({signer:0,checkChain:!1},t);if(!r)throw Error("Integrity for the PKCS#12 data is broken!")}break;default:throw Error(`Incorrect value for "this.authSafe.contentType": ${this.authSafe.contentType}`)}}}c_.CLASS_NAME="PFX";let cW="status",cz="statusStrings",cF="failInfo",cG=[cW,cz,cF];(i=l||(l={}))[i.granted=0]="granted",i[i.grantedWithMods=1]="grantedWithMods",i[i.rejection=2]="rejection",i[i.waiting=3]="waiting",i[i.revocationWarning=4]="revocationWarning",i[i.revocationNotification=5]="revocationNotification";class cQ extends y{constructor(e={}){super(),this.status=h.H$(e,cW,cQ.defaultValues(cW)),cz in e&&(this.statusStrings=h.H$(e,cz,cQ.defaultValues(cz))),cF in e&&(this.failInfo=h.H$(e,cF,cQ.defaultValues(cF))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case cW:return 2;case cz:return[];case cF:return new o.BitString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case cW:return t===cQ.defaultValues(e);case cz:return 0===t.length;case cF:return t.isEqual(cQ.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.status||""}),new o.Sequence({optional:!0,value:[new o.Repeated({name:t.statusStrings||"",value:new o.Utf8String})]}),new o.BitString({name:t.failInfo||"",optional:!0})]})}fromSchema(e){h.ze(e,cG);let t=o.compareSchema(e,e,cQ.schema({names:{status:cW,statusStrings:cz,failInfo:cF}}));S.assertSchema(t,this.className);let a=t.result.status;if(!0===a.valueBlock.isHexOnly||a.valueBlock.valueDec<0||a.valueBlock.valueDec>5)throw Error('PKIStatusInfo "status" has invalid value');this.status=a.valueBlock.valueDec,cz in t.result&&(this.statusStrings=t.result.statusStrings),cF in t.result&&(this.failInfo=t.result.failInfo)}toSchema(){let e=[];return e.push(new o.Integer({value:this.status})),this.statusStrings&&e.push(new o.Sequence({optional:!0,value:this.statusStrings})),this.failInfo&&e.push(this.failInfo),new o.Sequence({value:e})}toJSON(){let e={status:this.status};return this.statusStrings&&(e.statusStrings=Array.from(this.statusStrings,e=>e.toJSON())),this.failInfo&&(e.failInfo=this.failInfo.toJSON()),e}}cQ.CLASS_NAME="PKIStatusInfo";let cX="version",cY="messageImprint",cZ="reqPolicy",c1="nonce",c0="certReq",c2="extensions",c3="TimeStampReq",c4=`${c3}.${cX}`,c8=`${c3}.${cY}`,c5=`${c3}.${cZ}`,c6=`${c3}.${c1}`,c9=`${c3}.${c0}`,c7=`${c3}.${c2}`,he=[c4,c8,c5,c6,c9,c7];class ht extends y{constructor(e={}){super(),this.version=h.H$(e,cX,ht.defaultValues(cX)),this.messageImprint=h.H$(e,cY,ht.defaultValues(cY)),cZ in e&&(this.reqPolicy=h.H$(e,cZ,ht.defaultValues(cZ))),c1 in e&&(this.nonce=h.H$(e,c1,ht.defaultValues(c1))),c0 in e&&(this.certReq=h.H$(e,c0,ht.defaultValues(c0))),c2 in e&&(this.extensions=h.H$(e,c2,ht.defaultValues(c2))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case cX:return 0;case cY:return new of;case cZ:return"";case c1:return new o.Integer;case c0:return!1;case c2:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case cX:case cZ:case c0:return t===ht.defaultValues(e);case cY:return of.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&of.compareWithDefault("hashedMessage",t.hashedMessage);case c1:return t.isEqual(ht.defaultValues(e));case c2:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||c3,value:[new o.Integer({name:t.version||c4}),of.schema(t.messageImprint||{names:{blockName:c8}}),new o.ObjectIdentifier({name:t.reqPolicy||c5,optional:!0}),new o.Integer({name:t.nonce||c6,optional:!0}),new o.Boolean({name:t.certReq||c9,optional:!0}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Repeated({name:t.extensions||c7,value:sF.schema()})]})]})}fromSchema(e){h.ze(e,he);let t=o.compareSchema(e,e,ht.schema());S.assertSchema(t,this.className),this.version=t.result[c4].valueBlock.valueDec,this.messageImprint=new of({schema:t.result[c8]}),c5 in t.result&&(this.reqPolicy=t.result[c5].valueBlock.toString()),c6 in t.result&&(this.nonce=t.result[c6]),c9 in t.result&&(this.certReq=t.result[c9].valueBlock.value),c7 in t.result&&(this.extensions=Array.from(t.result[c7],e=>new sF({schema:e})))}toSchema(){let e=[];return e.push(new o.Integer({value:this.version})),e.push(this.messageImprint.toSchema()),this.reqPolicy&&e.push(new o.ObjectIdentifier({value:this.reqPolicy})),this.nonce&&e.push(this.nonce),c0 in this&&!1===ht.compareWithDefault(c0,this.certReq)&&e.push(new o.Boolean({value:this.certReq})),this.extensions&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.extensions,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={version:this.version,messageImprint:this.messageImprint.toJSON()};return void 0!==this.reqPolicy&&(e.reqPolicy=this.reqPolicy),void 0!==this.nonce&&(e.nonce=this.nonce.toJSON()),void 0!==this.certReq&&!1===ht.compareWithDefault(c0,this.certReq)&&(e.certReq=this.certReq),this.extensions&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}}ht.CLASS_NAME="TimeStampReq";let ha="status",hs="timeStampToken",hr="TimeStampResp",hi=`${hr}.${ha}`,hn=`${hr}.${hs}`,hu=[hi,hn];class hl extends y{constructor(e={}){super(),this.status=h.H$(e,ha,hl.defaultValues(ha)),hs in e&&(this.timeStampToken=h.H$(e,hs,hl.defaultValues(hs))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ha:return new cQ;case hs:return new r_;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ha:return cQ.compareWithDefault(ha,t.status)&&"statusStrings"in t==!1&&"failInfo"in t==!1;case hs:return""===t.contentType&&t.content instanceof o.Any;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||hr,value:[cQ.schema(t.status||{names:{blockName:hi}}),r_.schema(t.timeStampToken||{names:{blockName:hn,optional:!0}})]})}fromSchema(e){h.ze(e,hu);let t=o.compareSchema(e,e,hl.schema());S.assertSchema(t,this.className),this.status=new cQ({schema:t.result[hi]}),hn in t.result&&(this.timeStampToken=new r_({schema:t.result[hn]}))}toSchema(){let e=[];return e.push(this.status.toSchema()),this.timeStampToken&&e.push(this.timeStampToken.toSchema()),new o.Sequence({value:e})}toJSON(){let e={status:this.status.toJSON()};return this.timeStampToken&&(e.timeStampToken=this.timeStampToken.toJSON()),e}async sign(e,t,a=sc(!0)){this.assertContentType();let s=new cJ({schema:this.timeStampToken.content});return s.sign(e,0,t,void 0,a)}async verify(e={signer:0,trustedCerts:[],data:d},t=sc(!0)){this.assertContentType();let a=new cJ({schema:this.timeStampToken.content});return a.verify(e,t)}assertContentType(){if(!this.timeStampToken)throw Error("timeStampToken is absent in TSP response");if(this.timeStampToken.contentType!==eK)throw Error(`Wrong format of timeStampToken: ${this.timeStampToken.contentType}`)}}hl.CLASS_NAME="TimeStampResp",function(){if("undefined"!=typeof self){if("crypto"in self){let e="webcrypto";"webkitSubtle"in self.crypto&&(e="safari"),sl(e,new si({name:e,crypto:crypto}))}}else if("undefined"!=typeof crypto&&"webcrypto"in crypto){let e="NodeJS ^15",t=crypto.webcrypto;sl(e,new si({name:e,crypto:t}))}}()}}]);