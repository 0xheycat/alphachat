(() => {
var exports = {};
exports.id = 635;
exports.ids = [635];
exports.modules = {

/***/ 7792:
/***/ ((module) => {

// Exports
module.exports = {
	"wrap": "ChatMembersCount_wrap__N6q0R",
	"count": "ChatMembersCount_count__lRrn4",
	"desktop": "ChatMembersCount_desktop__v_bCf"
};


/***/ }),

/***/ 1501:
/***/ ((module) => {

// Exports
module.exports = {
	"list": "ChatMembersList_list___EFof",
	"item": "ChatMembersList_item___3Dpz"
};


/***/ }),

/***/ 2941:
/***/ ((module) => {

// Exports
module.exports = {
	"icon": "ChatMembersListItem_icon__nr9_A",
	"name": "ChatMembersListItem_name___x8zk"
};


/***/ }),

/***/ 4288:
/***/ ((module) => {

// Exports
module.exports = {
	"wrap": "MobileChatMembers_wrap__Ri_ZU",
	"header": "MobileChatMembers_header__sAkQP",
	"content": "MobileChatMembers_content__emByh",
	"membersCount": "MobileChatMembers_membersCount__ci8A4",
	"membersList": "MobileChatMembers_membersList__GkWjI"
};


/***/ }),

/***/ 945:
/***/ ((module) => {

// Exports
module.exports = {
	"membersWrap": "ChatMembers_membersWrap__aumlR",
	"count": "ChatMembers_count__AtiPn"
};


/***/ }),

/***/ 2535:
/***/ ((module) => {

// Exports
module.exports = {
	"accordion": "Info_accordion__T_3DX"
};


/***/ }),

/***/ 4002:
/***/ ((module) => {

// Exports
module.exports = {
	"chat": "Room_chat__GEVR_",
	"members": "Room_members__QlMm2",
	"wrap": "Room_wrap__B4BkU",
	"wrapMobile": "Room_wrapMobile__NxMQX",
	"container": "Room_container__ct1tf",
	"mobileMembersCount": "Room_mobileMembersCount__vpeDE",
	"info": "Room_info__MbBHc",
	"containerMobile": "Room_containerMobile__FO1hZ",
	"chatMobile": "Room_chatMobile__TJnOd",
	"invationLinkMobile": "Room_invationLinkMobile__uQ4I_",
	"mobileTop": "Room_mobileTop__vee2j"
};


/***/ }),

/***/ 249:
/***/ ((module) => {

// Exports
module.exports = {
	"wrap": "Card_wrap__T_WP6",
	"rounded": "Card_rounded__h1Ma9"
};


/***/ }),

/***/ 1496:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   config: () => (/* binding */ config),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getServerSideProps: () => (/* binding */ getServerSideProps),
/* harmony export */   getStaticPaths: () => (/* binding */ getStaticPaths),
/* harmony export */   getStaticProps: () => (/* binding */ getStaticProps),
/* harmony export */   reportWebVitals: () => (/* binding */ reportWebVitals),
/* harmony export */   routeModule: () => (/* binding */ routeModule),
/* harmony export */   unstable_getServerProps: () => (/* binding */ unstable_getServerProps),
/* harmony export */   unstable_getServerSideProps: () => (/* binding */ unstable_getServerSideProps),
/* harmony export */   unstable_getStaticParams: () => (/* binding */ unstable_getStaticParams),
/* harmony export */   unstable_getStaticPaths: () => (/* binding */ unstable_getStaticPaths),
/* harmony export */   unstable_getStaticProps: () => (/* binding */ unstable_getStaticProps)
/* harmony export */ });
/* harmony import */ var next_dist_server_future_route_modules_pages_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3185);
/* harmony import */ var next_dist_server_future_route_modules_pages_module__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_module__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_dist_build_webpack_loaders_next_route_loader_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7182);
/* harmony import */ var private_next_pages_document_tsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3104);
/* harmony import */ var private_next_pages_app_tsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9212);
/* harmony import */ var private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4791);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([private_next_pages_app_tsx__WEBPACK_IMPORTED_MODULE_3__, private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__]);
([private_next_pages_app_tsx__WEBPACK_IMPORTED_MODULE_3__, private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);

        // Next.js Route Loader
        
        

        // Import the app and document modules.
        
        

        // Import the userland code.
        

        // Re-export the component (should be the default export).
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_webpack_loaders_next_route_loader_helpers__WEBPACK_IMPORTED_MODULE_1__/* .hoist */ .l)(private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__, "default"));

        // Re-export methods.
        const getStaticProps = (0,next_dist_build_webpack_loaders_next_route_loader_helpers__WEBPACK_IMPORTED_MODULE_1__/* .hoist */ .l)(private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__, "getStaticProps")
        const getStaticPaths = (0,next_dist_build_webpack_loaders_next_route_loader_helpers__WEBPACK_IMPORTED_MODULE_1__/* .hoist */ .l)(private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__, "getStaticPaths")
        const getServerSideProps = (0,next_dist_build_webpack_loaders_next_route_loader_helpers__WEBPACK_IMPORTED_MODULE_1__/* .hoist */ .l)(private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__, "getServerSideProps")
        const config = (0,next_dist_build_webpack_loaders_next_route_loader_helpers__WEBPACK_IMPORTED_MODULE_1__/* .hoist */ .l)(private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__, "config")
        const reportWebVitals = (0,next_dist_build_webpack_loaders_next_route_loader_helpers__WEBPACK_IMPORTED_MODULE_1__/* .hoist */ .l)(private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__, "reportWebVitals")
        

        // Re-export legacy methods.
        const unstable_getStaticProps = (0,next_dist_build_webpack_loaders_next_route_loader_helpers__WEBPACK_IMPORTED_MODULE_1__/* .hoist */ .l)(private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__, "unstable_getStaticProps")
        const unstable_getStaticPaths = (0,next_dist_build_webpack_loaders_next_route_loader_helpers__WEBPACK_IMPORTED_MODULE_1__/* .hoist */ .l)(private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__, "unstable_getStaticPaths")
        const unstable_getStaticParams = (0,next_dist_build_webpack_loaders_next_route_loader_helpers__WEBPACK_IMPORTED_MODULE_1__/* .hoist */ .l)(private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__, "unstable_getStaticParams")
        const unstable_getServerProps = (0,next_dist_build_webpack_loaders_next_route_loader_helpers__WEBPACK_IMPORTED_MODULE_1__/* .hoist */ .l)(private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__, "unstable_getServerProps")
        const unstable_getServerSideProps = (0,next_dist_build_webpack_loaders_next_route_loader_helpers__WEBPACK_IMPORTED_MODULE_1__/* .hoist */ .l)(private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__, "unstable_getServerSideProps")

        // Create and export the route module that will be consumed.
        const options = {"definition":{"kind":"PAGES","page":"/room","pathname":"/room","bundlePath":"","filename":""}}
        const routeModule = new (next_dist_server_future_route_modules_pages_module__WEBPACK_IMPORTED_MODULE_0___default())({
          ...options,
          components: {
            App: private_next_pages_app_tsx__WEBPACK_IMPORTED_MODULE_3__["default"],
            Document: private_next_pages_document_tsx__WEBPACK_IMPORTED_MODULE_2__["default"],
          },
          userland: private_next_pages_room_tsx__WEBPACK_IMPORTED_MODULE_4__,
        })
        
        
    
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 3085:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* reexport */ ChatMembersCount)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5893);
// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(6689);
// EXTERNAL MODULE: external "classnames"
var external_classnames_ = __webpack_require__(9003);
var external_classnames_default = /*#__PURE__*/__webpack_require__.n(external_classnames_);
// EXTERNAL MODULE: ./src/client/ui/Buttons/Button/index.ts + 1 modules
var Button = __webpack_require__(1802);
// EXTERNAL MODULE: ./src/client/components/ChatMembersCount/ChatMembersCount.module.scss
var ChatMembersCount_module = __webpack_require__(7792);
var ChatMembersCount_module_default = /*#__PURE__*/__webpack_require__.n(ChatMembersCount_module);
;// CONCATENATED MODULE: ./src/client/components/ChatMembersCount/ChatMembersCount.tsx





const ChatMembersCount = /*#__PURE__*/ (0,external_react_.memo)(({ count, onClick, className, isMobile })=>{
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(Button/* Button */.z, {
        variant: "base-link",
        className: external_classnames_default()((ChatMembersCount_module_default()).wrap, className, {
            [(ChatMembersCount_module_default()).desktop]: !isMobile
        }),
        onClick: onClick,
        children: [
            /*#__PURE__*/ jsx_runtime.jsx("span", {
                children: "Users:"
            }),
            "\xa0",
            /*#__PURE__*/ jsx_runtime.jsx("span", {
                className: (ChatMembersCount_module_default()).count,
                children: count || 0
            })
        ]
    });
});

;// CONCATENATED MODULE: ./src/client/components/ChatMembersCount/index.ts



/***/ }),

/***/ 4670:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  P: () => (/* reexport */ ChatMembersList)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5893);
// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(6689);
// EXTERNAL MODULE: external "classnames"
var external_classnames_ = __webpack_require__(9003);
var external_classnames_default = /*#__PURE__*/__webpack_require__.n(external_classnames_);
// EXTERNAL MODULE: ./src/client/ui/Box/index.ts + 1 modules
var Box = __webpack_require__(2138);
// EXTERNAL MODULE: ./src/client/ui/Icon/index.ts + 1 modules
var Icon = __webpack_require__(5146);
// EXTERNAL MODULE: ./src/client/components/ChatMembersList/ChatMembersListItem/ChatMembersListItem.module.scss
var ChatMembersListItem_module = __webpack_require__(2941);
var ChatMembersListItem_module_default = /*#__PURE__*/__webpack_require__.n(ChatMembersListItem_module);
;// CONCATENATED MODULE: ./src/client/components/ChatMembersList/ChatMembersListItem/ChatMembersListItem.tsx





const ChatMembersListItem = /*#__PURE__*/ (0,external_react_.memo)(({ name, className })=>{
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(Box/* Box */.x, {
        direction: "row",
        alignItems: "center",
        className: className,
        children: [
            /*#__PURE__*/ jsx_runtime.jsx(Icon/* Icon */.J, {
                width: 14,
                name: "profile",
                className: (ChatMembersListItem_module_default()).icon
            }),
            /*#__PURE__*/ jsx_runtime.jsx("span", {
                className: (ChatMembersListItem_module_default()).name,
                children: name
            })
        ]
    });
});

;// CONCATENATED MODULE: ./src/client/components/ChatMembersList/ChatMembersListItem/index.ts


// EXTERNAL MODULE: ./src/client/components/ChatMembersList/ChatMembersList.module.scss
var ChatMembersList_module = __webpack_require__(1501);
var ChatMembersList_module_default = /*#__PURE__*/__webpack_require__.n(ChatMembersList_module);
;// CONCATENATED MODULE: ./src/client/components/ChatMembersList/ChatMembersList.tsx






const ChatMembersList = /*#__PURE__*/ (0,external_react_.memo)(({ list, className })=>{
    return /*#__PURE__*/ jsx_runtime.jsx(Box/* Box */.x, {
        direction: "column",
        className: external_classnames_default()((ChatMembersList_module_default()).list, className),
        children: list.map(({ id, name })=>/*#__PURE__*/ jsx_runtime.jsx(ChatMembersListItem, {
                name: name,
                className: (ChatMembersList_module_default()).item
            }, id))
    });
});

;// CONCATENATED MODULE: ./src/client/components/ChatMembersList/index.ts



/***/ }),

/***/ 9750:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  c: () => (/* reexport */ MobileChatMembers)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5893);
// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(6689);
// EXTERNAL MODULE: external "classnames"
var external_classnames_ = __webpack_require__(9003);
var external_classnames_default = /*#__PURE__*/__webpack_require__.n(external_classnames_);
// EXTERNAL MODULE: ./src/client/components/Logo/index.ts + 1 modules
var Logo = __webpack_require__(9184);
// EXTERNAL MODULE: ./src/client/contexts/ThemeContext.tsx
var ThemeContext = __webpack_require__(6444);
// EXTERNAL MODULE: ./src/client/ui/Box/index.ts + 1 modules
var Box = __webpack_require__(2138);
// EXTERNAL MODULE: ./src/client/components/Cross/index.ts + 1 modules
var Cross = __webpack_require__(8949);
// EXTERNAL MODULE: ./src/client/components/ChatMembersCount/index.ts + 1 modules
var ChatMembersCount = __webpack_require__(3085);
// EXTERNAL MODULE: ./src/client/components/ChatMembersList/index.ts + 3 modules
var ChatMembersList = __webpack_require__(4670);
// EXTERNAL MODULE: ./src/client/components/MobileChatMembers/MobileChatMembers.module.scss
var MobileChatMembers_module = __webpack_require__(4288);
var MobileChatMembers_module_default = /*#__PURE__*/__webpack_require__.n(MobileChatMembers_module);
;// CONCATENATED MODULE: ./src/client/components/MobileChatMembers/MobileChatMembers.tsx










const MobileChatMembers = /*#__PURE__*/ (0,external_react_.memo)(({ className, onClickCross, list })=>{
    const { theme } = (0,ThemeContext/* useTheme */.Fg)();
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(Box/* Box */.x, {
        direction: "column",
        className: external_classnames_default()((MobileChatMembers_module_default()).wrap, className),
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsxs)(Box/* Box */.x, {
                alignItems: "center",
                justifyContent: "space-between",
                className: (MobileChatMembers_module_default()).header,
                children: [
                    /*#__PURE__*/ jsx_runtime.jsx(Box/* Box */.x, {
                        children: /*#__PURE__*/ jsx_runtime.jsx(Logo/* Logo */.T, {
                            theme: theme
                        })
                    }),
                    /*#__PURE__*/ jsx_runtime.jsx(Box/* Box */.x, {
                        children: /*#__PURE__*/ jsx_runtime.jsx(Cross/* Cross */.X, {
                            theme: theme,
                            onClick: onClickCross
                        })
                    })
                ]
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsxs)(Box/* Box */.x, {
                direction: "column",
                alignItems: "center",
                className: (MobileChatMembers_module_default()).content,
                children: [
                    /*#__PURE__*/ jsx_runtime.jsx(ChatMembersCount/* ChatMembersCount */.A, {
                        count: list.length,
                        className: (MobileChatMembers_module_default()).membersCount,
                        onClick: onClickCross
                    }),
                    /*#__PURE__*/ jsx_runtime.jsx(ChatMembersList/* ChatMembersList */.P, {
                        list: list,
                        className: (MobileChatMembers_module_default()).membersList
                    })
                ]
            })
        ]
    });
});

;// CONCATENATED MODULE: ./src/client/components/MobileChatMembers/index.ts



/***/ }),

/***/ 7319:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ ChatMembers)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5893);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6689);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _ui_Card__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4540);
/* harmony import */ var _components_RoomBtns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6330);
/* harmony import */ var _ui_Box__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2138);
/* harmony import */ var _contexts_MobileContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9719);
/* harmony import */ var _components_ChatMembersList__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4670);
/* harmony import */ var _components_ChatMembersCount__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3085);
/* harmony import */ var _ChatMembers_module_scss__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(945);
/* harmony import */ var _ChatMembers_module_scss__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_ChatMembers_module_scss__WEBPACK_IMPORTED_MODULE_8__);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_components_RoomBtns__WEBPACK_IMPORTED_MODULE_3__]);
_components_RoomBtns__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];









const ChatMembers = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ className, list, onLeaveRoom })=>{
    const { isMobile } = (0,_contexts_MobileContext__WEBPACK_IMPORTED_MODULE_5__/* .useMobile */ .XA)();
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_ui_Card__WEBPACK_IMPORTED_MODULE_2__/* .Card */ .Z, {
        rounded: true,
        className: className,
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_ui_Box__WEBPACK_IMPORTED_MODULE_4__/* .Box */ .x, {
                direction: "column",
                className: (_ChatMembers_module_scss__WEBPACK_IMPORTED_MODULE_8___default().membersWrap),
                children: [
                    /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_components_ChatMembersCount__WEBPACK_IMPORTED_MODULE_7__/* .ChatMembersCount */ .A, {
                        count: list.length,
                        className: (_ChatMembers_module_scss__WEBPACK_IMPORTED_MODULE_8___default().count),
                        isMobile: isMobile
                    }),
                    /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_components_ChatMembersList__WEBPACK_IMPORTED_MODULE_6__/* .ChatMembersList */ .P, {
                        list: list,
                        className: (_ChatMembers_module_scss__WEBPACK_IMPORTED_MODULE_8___default().members)
                    })
                ]
            }),
            /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_ui_Box__WEBPACK_IMPORTED_MODULE_4__/* .Box */ .x, {
                children: /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_components_RoomBtns__WEBPACK_IMPORTED_MODULE_3__/* .RoomBtns */ .d, {
                    onLeaveRoom: onLeaveRoom
                })
            })
        ]
    });
});

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 3537:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* reexport safe */ _ChatMembers__WEBPACK_IMPORTED_MODULE_0__.E)
/* harmony export */ });
/* harmony import */ var _ChatMembers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7319);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_ChatMembers__WEBPACK_IMPORTED_MODULE_0__]);
_ChatMembers__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 6318:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   k: () => (/* binding */ Info)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5893);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6689);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _ui_Box__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2138);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1740);
/* harmony import */ var _components_CopyInvationBlock__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3331);
/* harmony import */ var _InfoAccordion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2985);
/* harmony import */ var _Info_module_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2535);
/* harmony import */ var _Info_module_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_Info_module_scss__WEBPACK_IMPORTED_MODULE_6__);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_components_CopyInvationBlock__WEBPACK_IMPORTED_MODULE_4__]);
_components_CopyInvationBlock__WEBPACK_IMPORTED_MODULE_4__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];







const Info = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ className, roomName, connectPassword })=>{
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_ui_Box__WEBPACK_IMPORTED_MODULE_2__/* .Box */ .x, {
        direction: "column",
        className: className,
        children: [
            /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_InfoAccordion__WEBPACK_IMPORTED_MODULE_5__/* .InfoAccordion */ .r, {
                className: (_Info_module_scss__WEBPACK_IMPORTED_MODULE_6___default().accordion)
            }),
            /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_components_CopyInvationBlock__WEBPACK_IMPORTED_MODULE_4__/* .CopyInvationBlock */ .J, {
                connectPassword: connectPassword,
                domainUrl: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_3__/* .getDomainUrl */ .AT)(),
                roomName: roomName
            })
        ]
    });
});

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 6116:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   k: () => (/* reexport safe */ _Info__WEBPACK_IMPORTED_MODULE_0__.k)
/* harmony export */ });
/* harmony import */ var _Info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6318);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Info__WEBPACK_IMPORTED_MODULE_0__]);
_Info__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 9715:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: () => (/* binding */ Room)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5893);
/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5152);
/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9003);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6689);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var use_debounce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7105);
/* harmony import */ var _hooks_useChat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7799);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1740);
/* harmony import */ var _components_Header__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8098);
/* harmony import */ var _contexts_MobileContext__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9719);
/* harmony import */ var _components_ChatMembersCount__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(3085);
/* harmony import */ var _components_MobileChatMembers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(9750);
/* harmony import */ var _components_CopyInvationBlock__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(3331);
/* harmony import */ var _ChatMembers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(3537);
/* harmony import */ var _Info__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(6116);
/* harmony import */ var _ui_Box__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(2138);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(4357);
/* harmony import */ var _Room_module_scss__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(4002);
/* harmony import */ var _Room_module_scss__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_Room_module_scss__WEBPACK_IMPORTED_MODULE_16__);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([use_debounce__WEBPACK_IMPORTED_MODULE_4__, _hooks_useChat__WEBPACK_IMPORTED_MODULE_5__, _components_Header__WEBPACK_IMPORTED_MODULE_7__, _components_CopyInvationBlock__WEBPACK_IMPORTED_MODULE_11__, _ChatMembers__WEBPACK_IMPORTED_MODULE_12__, _Info__WEBPACK_IMPORTED_MODULE_13__]);
([use_debounce__WEBPACK_IMPORTED_MODULE_4__, _hooks_useChat__WEBPACK_IMPORTED_MODULE_5__, _components_Header__WEBPACK_IMPORTED_MODULE_7__, _components_CopyInvationBlock__WEBPACK_IMPORTED_MODULE_11__, _ChatMembers__WEBPACK_IMPORTED_MODULE_12__, _Info__WEBPACK_IMPORTED_MODULE_13__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);

















const Chat = next_dynamic__WEBPACK_IMPORTED_MODULE_1___default()(null, {
    loadableGenerated: {
        modules: [
            "../client/components/Room/Room.tsx -> " + "./Chat/Chat"
        ]
    },
    ssr: false
});
const Room = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(()=>{
    const canScrollToBottomRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(true);
    const triggerRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);
    const scrollerRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);
    const scrollTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();
    const [isShowMobileMembersCount, setIsShowMembersCount] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);
    const { isMobile } = (0,_contexts_MobileContext__WEBPACK_IMPORTED_MODULE_8__/* .useMobile */ .XA)();
    const scrollToBottom = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((index)=>{
        triggerRef.current?.scrollToIndex(index);
    }, []);
    const scrollToBottomTimeout = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((index, timeout = 1)=>{
        if (scrollTimeoutRef.current) {
            clearTimeout(scrollTimeoutRef.current);
        }
        scrollTimeoutRef.current = setTimeout(()=>{
            scrollToBottom(index);
        }, timeout);
    }, [
        scrollToBottom
    ]);
    const { room, socket, messages, firstItemIndex } = (0,_hooks_useChat__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)();
    const { connected, joinRoom, roomMembers } = socket;
    const messageData = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>messages.data, [
        messages
    ]);
    const { getRoomInfo, getAuthToken } = room;
    const list = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>(0,_helpers__WEBPACK_IMPORTED_MODULE_15__/* .getMembersList */ .P)(Object.values(roomMembers)), [
        roomMembers
    ]);
    const onClickMembersCount = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(()=>{
        setIsShowMembersCount(true);
    }, []);
    const onClickCloseMobileMembers = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(()=>{
        setIsShowMembersCount(false);
    }, []);
    const roomInfo = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>getRoomInfo(), [
        getRoomInfo
    ]);
    const authToken = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>getAuthToken(), [
        getAuthToken
    ]);
    const scrollToLastMessage = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(()=>{
        if (messageData?.length) {
            scrollToBottomTimeout(messageData.length - 1);
        }
    }, [
        messageData,
        scrollToBottomTimeout
    ]);
    const onSendMessage = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((message)=>{
        socket.sendMessage(message);
    }, [
        socket
    ]);
    const scrollerRefCallback = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((ref)=>{
        scrollerRef.current = ref;
    }, []);
    const onChangeScrolling = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(()=>{
        if (!scrollerRef.current) return;
        const div = scrollerRef.current;
        if (div.scrollHeight <= div.scrollTop + div.offsetHeight + _helpers__WEBPACK_IMPORTED_MODULE_15__/* .SCROLL_BOTTOM_DISTANCE */ .o) {
            canScrollToBottomRef.current = true;
        } else {
            canScrollToBottomRef.current = false;
        }
    }, []);
    const onChangeScrollingDebounce = (0,use_debounce__WEBPACK_IMPORTED_MODULE_4__.useDebouncedCallback)(onChangeScrolling, 100);
    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{
        if (connected) {
            joinRoom();
        }
    }, [
        joinRoom,
        connected
    ]);
    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{
        if (canScrollToBottomRef.current) {
            scrollToLastMessage();
        }
    }, [
        scrollToLastMessage
    ]);
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_ui_Box__WEBPACK_IMPORTED_MODULE_14__/* .Box */ .x, {
        direction: "column",
        className: classnames__WEBPACK_IMPORTED_MODULE_2___default()((_Room_module_scss__WEBPACK_IMPORTED_MODULE_16___default().wrap), {
            [(_Room_module_scss__WEBPACK_IMPORTED_MODULE_16___default().wrapMobile)]: isMobile
        }),
        children: [
            /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_components_Header__WEBPACK_IMPORTED_MODULE_7__/* .Header */ .h, {
                authToken: authToken
            }),
            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_ui_Box__WEBPACK_IMPORTED_MODULE_14__/* .Box */ .x, {
                className: classnames__WEBPACK_IMPORTED_MODULE_2___default()((_Room_module_scss__WEBPACK_IMPORTED_MODULE_16___default().container), {
                    [(_Room_module_scss__WEBPACK_IMPORTED_MODULE_16___default().containerMobile)]: isMobile
                }),
                children: [
                    isMobile && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_ui_Box__WEBPACK_IMPORTED_MODULE_14__/* .Box */ .x, {
                        justifyContent: "space-between",
                        className: (_Room_module_scss__WEBPACK_IMPORTED_MODULE_16___default().mobileTop),
                        children: [
                            /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_components_ChatMembersCount__WEBPACK_IMPORTED_MODULE_9__/* .ChatMembersCount */ .A, {
                                count: list.length,
                                onClick: onClickMembersCount
                            }),
                            /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_components_CopyInvationBlock__WEBPACK_IMPORTED_MODULE_11__/* .CopyInvationBlock */ .J, {
                                domainUrl: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_6__/* .getDomainUrl */ .AT)(),
                                roomName: roomInfo.roomName,
                                connectPassword: roomInfo.connectPassword,
                                className: (_Room_module_scss__WEBPACK_IMPORTED_MODULE_16___default().invationLinkMobile),
                                mode: "two"
                            })
                        ]
                    }),
                    !isMobile && /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_ChatMembers__WEBPACK_IMPORTED_MODULE_12__/* .ChatMembers */ .E, {
                        className: (_Room_module_scss__WEBPACK_IMPORTED_MODULE_16___default().members),
                        list: list
                    }),
                    isMobile && isShowMobileMembersCount && /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_components_MobileChatMembers__WEBPACK_IMPORTED_MODULE_10__/* .MobileChatMembers */ .c, {
                        list: list,
                        className: (_Room_module_scss__WEBPACK_IMPORTED_MODULE_16___default().mobileMembersCount),
                        onClickCross: onClickCloseMobileMembers
                    }),
                    /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_ui_Box__WEBPACK_IMPORTED_MODULE_14__/* .Box */ .x, {
                        className: classnames__WEBPACK_IMPORTED_MODULE_2___default()((_Room_module_scss__WEBPACK_IMPORTED_MODULE_16___default().chat), {
                            [(_Room_module_scss__WEBPACK_IMPORTED_MODULE_16___default().chatMobile)]: isMobile
                        }),
                        children: /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(Chat, {
                            scrollerRef: scrollerRefCallback,
                            forwardRef: triggerRef,
                            messages: messages.data,
                            fetchNextPage: messages.fetchNextPage,
                            roomInfo: roomInfo,
                            onSendMessage: onSendMessage,
                            firstItemIndex: firstItemIndex,
                            pageSize: messages.pageSize,
                            isScrolling: onChangeScrollingDebounce
                        })
                    }),
                    !isMobile && /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_Info__WEBPACK_IMPORTED_MODULE_13__/* .Info */ .k, {
                        className: (_Room_module_scss__WEBPACK_IMPORTED_MODULE_16___default().info),
                        roomName: roomInfo.roomName,
                        connectPassword: roomInfo.connectPassword
                    })
                ]
            })
        ]
    });
});

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 4357:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ getMembersList),
/* harmony export */   o: () => (/* binding */ SCROLL_BOTTOM_DISTANCE)
/* harmony export */ });
/* eslint-disable max-len */ const getMembersList = (values)=>{
    const kv = values.reduce((acc, { token, name })=>({
            ...acc,
            [token]: name
        }), {});
    return Object.entries(kv).reduce((acc, [id, name])=>[
            ...acc,
            {
                id,
                name
            }
        ], []);
};
const SCROLL_BOTTOM_DISTANCE = 100;


/***/ }),

/***/ 5844:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: () => (/* reexport safe */ _Room__WEBPACK_IMPORTED_MODULE_0__.d)
/* harmony export */ });
/* harmony import */ var _Room__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9715);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Room__WEBPACK_IMPORTED_MODULE_0__]);
_Room__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 7799:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6689);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1635);
/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dayjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _connectors_rooms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2819);
/* harmony import */ var _hooks_useLazyPaginationTimestamp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6156);
/* harmony import */ var _hooks_useSocket__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6666);
/* harmony import */ var _services_MessagesService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(458);
/* harmony import */ var _hooks_useRoom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8760);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_hooks_useSocket__WEBPACK_IMPORTED_MODULE_4__]);
_hooks_useSocket__WEBPACK_IMPORTED_MODULE_4__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];







const PAGE_SIZE = 50;
const useChat = ()=>{
    const pageSize = PAGE_SIZE;
    const [firstItemIndex, setFirstItemIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);
    const room = (0,_hooks_useRoom__WEBPACK_IMPORTED_MODULE_6__/* .useRoom */ .N)();
    const [socketMessages, setSocketMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
    const lazyMessages = (0,_hooks_useLazyPaginationTimestamp__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)({
        connector: async (props)=>{
            const { timestamp = +dayjs__WEBPACK_IMPORTED_MODULE_1___default()() } = props || {};
            return (0,_connectors_rooms__WEBPACK_IMPORTED_MODULE_2__/* .getRoomMessagesTimestamp */ .rZ)(timestamp, pageSize).then(async (response)=>({
                    ...response,
                    list: await new _services_MessagesService__WEBPACK_IMPORTED_MODULE_5__/* .MessagesService */ .K().setMessages(response?.messages).getMessagesDecrypted(room.getConnectPassword())
                })).then((result)=>{
                if (!firstItemIndex) {
                    setFirstItemIndex(Math.max(0, result?.total || 0));
                } else if (result.list.length) {
                    setFirstItemIndex((firstItemIndex)=>Math.max(0, firstItemIndex - result.list.length));
                }
                return result;
            });
        },
        key: "messages"
    });
    const messages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({
            ...lazyMessages,
            data: [
                ...lazyMessages.data,
                ...socketMessages
            ].sort((a, b)=>new Date(a.updatedAt).valueOf() - new Date(b.updatedAt).valueOf()),
            pageSize: Math.abs(pageSize)
        }), [
        lazyMessages,
        socketMessages,
        pageSize
    ]);
    const socket = (0,_hooks_useSocket__WEBPACK_IMPORTED_MODULE_4__/* .useSocket */ .s)({
        messages: messages.data,
        setMessages: setSocketMessages,
        room
    });
    return {
        socket,
        room,
        messages,
        firstItemIndex,
        setFirstItemIndex
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useChat);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 6156:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6689);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1175);
/* harmony import */ var react_query__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_query__WEBPACK_IMPORTED_MODULE_1__);


function useLazyPagination({ connector, key }) {
    const { data: responseData, isFetchingNextPage, fetchNextPage, hasNextPage } = (0,react_query__WEBPACK_IMPORTED_MODULE_1__.useInfiniteQuery)([
        key
    ], ({ pageParam })=>connector(pageParam), {
        refetchOnWindowFocus: false,
        getNextPageParam: (lastPage)=>lastPage.hasNextPage ? {
                timestamp: lastPage.timestamp
            } : undefined
    });
    const { pages } = responseData || {};
    const list = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(pages || []).reduce((acc, { list })=>[
                ...acc,
                ...list || []
            ], []), [
        pages
    ]);
    return {
        isFetchingNextPage,
        data: list,
        total: pages?.length ? pages[pages.length - 1].total : 0,
        fetchNextPage,
        hasNextPage: hasNextPage || false
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useLazyPagination);


/***/ }),

/***/ 6666:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   s: () => (/* binding */ useSocket)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6689);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6555);
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1853);
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4612);
/* harmony import */ var _services_MessagesService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(458);
/* harmony import */ var _services_UsersService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5594);
/* harmony import */ var _connectors_rooms__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2819);
/* harmony import */ var _hooks_usePrevious__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6969);
/* harmony import */ var _common_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1546);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([uuid__WEBPACK_IMPORTED_MODULE_1__, socket_io_client__WEBPACK_IMPORTED_MODULE_3__]);
([uuid__WEBPACK_IMPORTED_MODULE_1__, socket_io_client__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);









const REDIRECT_TIME = process.env.NEXT_PUBLIC_REDIRECT_TIME || "300000";
const useSocket = ({ messages, setMessages, room })=>{
    const messaveServiceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new _services_MessagesService__WEBPACK_IMPORTED_MODULE_4__/* .MessagesService */ .K());
    const usersServiceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new _services_UsersService__WEBPACK_IMPORTED_MODULE_5__/* .UsersService */ .f());
    const [connected, setConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
    const [canRedirect, setCanRedirect] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_2__.useRouter)();
    const { push } = router;
    const { getRoomInfo, getAuthToken, getConnectPassword } = room;
    const socket = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    const [roomMembers, setRoomMembers] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});
    const currentUserRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    const socketSubscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
    const timerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    const prevConnected = (0,_hooks_usePrevious__WEBPACK_IMPORTED_MODULE_7__/* .usePrevious */ .D)(connected);
    const messagesOfflineRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);
    const roomStatusRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    const joinRoom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{
        const { userName } = getRoomInfo();
        if (socket.current) {
            socket.current.emit("joinRoom", userName);
        }
    }, [
        getRoomInfo
    ]);
    const resetRoom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{
        setMessages([]);
        setRoomMembers({});
        currentUserRef.current = null;
    }, [
        setMessages
    ]);
    const leaveRoom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{
        if (socket.current) {
            socket.current.emit("leaveRoom");
            if (socket.current?.connected) {
                socket.current.disconnect();
            }
            resetRoom();
        }
    }, [
        resetRoom
    ]);
    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message)=>{
        try {
            const createdAt = new Date().toISOString();
            const messageClientId = (0,uuid__WEBPACK_IMPORTED_MODULE_1__.v1)();
            const { userName, connectPassword } = getRoomInfo();
            setMessages((messages)=>[
                    ...messages,
                    {
                        messageClientId,
                        senderName: userName,
                        message,
                        createdAt,
                        updatedAt: createdAt,
                        id: "",
                        senderId: currentUserRef.current?.id || ""
                    }
                ]);
            const messageEnc = {
                encryption: JSON.stringify(await messaveServiceRef.current.encryptMessage(message, connectPassword)),
                messageClientId
            };
            if (!connected || roomStatusRef.current !== _common_types__WEBPACK_IMPORTED_MODULE_8__/* .RoomStatus */ .J.AVAILABLE || !socket.current?.connected) {
                messagesOfflineRef.current = [
                    ...messagesOfflineRef.current,
                    messageEnc
                ];
            } else {
                socket.current.emit("message", messageEnc);
            }
        } catch (e) {
            ;
        }
    }, [
        socket,
        getRoomInfo,
        connected,
        setMessages
    ]);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        const subscription = ()=>{
            socket.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_3__["default"])({
                query: {
                    token: getAuthToken()
                },
                reconnectionDelay: 2000,
                transports: [
                    "websocket"
                ]
            });
            const _deleteRoom = async ()=>{
                if (socket.current?.connected) {
                    socket.current.disconnect();
                }
                resetRoom();
                await (0,_connectors_rooms__WEBPACK_IMPORTED_MODULE_6__/* .leaveRoom */ .jL)().catch((e)=>{
                    ;
                });
                push({
                    pathname: "/",
                    query: {
                        deleted: true
                    }
                });
            };
            const _connectError = (e)=>{
                ;
                if (socket.current?.connected) {
                    socket.current.disconnect();
                }
                if (canRedirect) {
                    resetRoom();
                    push("/");
                }
            };
            const _disconnect = (reason)=>{
                setConnected(false);
                // the disconnection was initiated by the server, you need to reconnect manually
                if (reason === "io server disconnect") {
                    ;
                    socketSubscription.current?.();
                    socketSubscription.current = subscription();
                } else {
                    ;
                }
            };
            const _leaveRoom = (userIds)=>{
                if (!Array.isArray(userIds) || !userIds.length) return;
                setRoomMembers((oldRoomMembers)=>{
                    const newRoomMembers = {
                        ...oldRoomMembers
                    };
                    userIds.forEach((userId)=>{
                        delete newRoomMembers[userId];
                    });
                    return newRoomMembers;
                });
            };
            const _newUserJoinedToRoom = async (profile)=>{
                if (socket.current) {
                    const newProfile = usersServiceRef.current.setUsers([
                        profile
                    ]).getUserResponseById(profile.id);
                    if (newProfile) {
                        setRoomMembers((roomMembers)=>({
                                ...roomMembers,
                                [newProfile.id]: newProfile
                            }));
                    }
                }
            };
            const _usersUpdatedInRoom = async (profiles)=>{
                if (socket.current) {
                    const newProfiles = usersServiceRef.current.setUsers(profiles).getUsersResponse();
                    setRoomMembers(newProfiles.reduce((acc, user)=>({
                            ...acc,
                            [user.id]: user
                        }), {}));
                }
            };
            const _getRoomUsers = async (users)=>{
                const newUsers = usersServiceRef.current.setUsers(users).getUsersResponse();
                setRoomMembers(newUsers.reduce((acc, profile)=>({
                        ...acc,
                        [profile.id]: profile
                    }), {}));
            };
            const _updateMessagesFromSocket = async (messages)=>{
                const messageDecrypted = await messaveServiceRef.current.setMessages(messages).getMessagesDecrypted(getConnectPassword());
                if (messageDecrypted.length) {
                    setMessages((oldMessages)=>{
                        const messagesByClients = new Map(messageDecrypted.map((message)=>[
                                message.messageClientId,
                                message
                            ]));
                        const updatedOldMessages = oldMessages.map((oldMessage)=>{
                            const messageFromServer = messagesByClients.get(oldMessage.messageClientId);
                            if (messageFromServer) {
                                messagesByClients.delete(oldMessage.messageClientId);
                                return messageFromServer;
                            }
                            return oldMessage;
                        });
                        return [
                            ...updatedOldMessages,
                            ...messagesByClients.values()
                        ].sort((a, b)=>new Date(a.createdAt).valueOf() - new Date(b.createdAt).valueOf());
                    });
                }
            };
            const _message = async (messageDb)=>{
                if (messageDb) {
                    await _updateMessagesFromSocket([
                        messageDb
                    ]);
                }
            };
            const _messages = async (messagesDb)=>{
                if (messagesDb?.length) {
                    await _updateMessagesFromSocket(messagesDb);
                }
            };
            const _connect = async ()=>{
                setConnected(true);
            };
            const sendMessagesOffine = ()=>{
                if (messagesOfflineRef.current.length) {
                    messagesOfflineRef.current.forEach((item)=>{
                        if (socket.current) {
                            socket.current.emit("message", item);
                        }
                    });
                    messagesOfflineRef.current = [];
                }
            };
            const _getRoomStatus = (status)=>{
                roomStatusRef.current = status;
                if (status === _common_types__WEBPACK_IMPORTED_MODULE_8__/* .RoomStatus */ .J.AVAILABLE) {
                    sendMessagesOffine();
                }
            };
            const _getCurrentUser = (user)=>{
                const newProfile = usersServiceRef.current.setUsers([
                    user
                ]).getUserResponseById(user.id);
                currentUserRef.current = newProfile;
            };
            socket.current.on("leaveRoom", _leaveRoom);
            socket.current.on("newUserJoinedToRoom", _newUserJoinedToRoom);
            socket.current.on("usersUpdatedInRoom", _usersUpdatedInRoom);
            socket.current.on("message", _message);
            socket.current.on("messages", _messages);
            socket.current.on("getRoomUsers", _getRoomUsers);
            socket.current.on("deleteRoom", _deleteRoom);
            socket.current.on("getRoomStatus", _getRoomStatus);
            socket.current.on("getCurrentUser", _getCurrentUser);
            socket.current.on("connect_error", _connectError);
            socket.current.on("disconnect", _disconnect);
            socket.current.on("connect", _connect);
            return ()=>{
                if (socket.current) {
                    socket.current.off("leaveRoom", _leaveRoom);
                    socket.current.off("newUserJoinedToRoom", _newUserJoinedToRoom);
                    socket.current.off("usersUpdatedInRoom", _usersUpdatedInRoom);
                    socket.current.off("getRoomUsers", _getRoomUsers);
                    socket.current.off("message", _message);
                    socket.current.off("messages", _messages);
                    socket.current.off("deleteRoom", _deleteRoom);
                    socket.current.off("getRoomStatus", _getRoomStatus);
                    socket.current.off("getCurrentUser", _getCurrentUser);
                    socket.current.off("connect_error", _connectError);
                    socket.current.off("disconnect", _disconnect);
                    socket.current.off("connect", _connect);
                }
            };
        };
        socketSubscription.current = subscription();
        return ()=>{
            socketSubscription.current?.();
            if (socket.current?.connected) {
                socket.current.disconnect();
            }
        };
    }, [
        getAuthToken,
        resetRoom,
        push,
        getConnectPassword,
        canRedirect,
        setMessages
    ]);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{
        if (timerRef.current) clearTimeout(timerRef.current);
        if (!connected && prevConnected) {
            timerRef.current = setTimeout(()=>{
                setCanRedirect(true);
            }, Number(REDIRECT_TIME));
        }
        return ()=>{
            if (timerRef.current) {
                clearTimeout(timerRef.current);
            }
        };
    }, [
        connected,
        prevConnected
    ]);
    const data = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({
            socket,
            joinRoom,
            leaveRoom,
            sendMessage,
            messages,
            roomMembers,
            connected
        }), [
        socket,
        joinRoom,
        leaveRoom,
        sendMessage,
        messages,
        roomMembers,
        connected
    ]);
    return data;
};

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 458:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ MessagesService)
/* harmony export */ });
/* harmony import */ var _common_services_CipherService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4703);
/* harmony import */ var _common_services_MessagesService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2748);
/* harmony import */ var _common_services_HelperService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8159);



class MessagesService extends _common_services_MessagesService__WEBPACK_IMPORTED_MODULE_1__/* .MessagesService */ .K {
    constructor(){
        super({
            helperService: new _common_services_HelperService__WEBPACK_IMPORTED_MODULE_2__/* .HelperService */ .W(),
            cipherService: new _common_services_CipherService__WEBPACK_IMPORTED_MODULE_0__/* .CipherService */ .u()
        });
    }
}


/***/ }),

/***/ 5594:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   f: () => (/* binding */ UsersService)
/* harmony export */ });
/* harmony import */ var _common_services_CipherService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4703);
/* harmony import */ var _common_services_UsersService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3269);
/* harmony import */ var _common_services_HelperService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8159);



class UsersService extends _common_services_UsersService__WEBPACK_IMPORTED_MODULE_1__/* .UsersService */ .f {
    constructor(){
        super({
            helperService: new _common_services_HelperService__WEBPACK_IMPORTED_MODULE_2__/* .HelperService */ .W(),
            cipherService: new _common_services_CipherService__WEBPACK_IMPORTED_MODULE_0__/* .CipherService */ .u()
        });
    }
}


/***/ }),

/***/ 4540:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* reexport */ Card)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5893);
// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(6689);
// EXTERNAL MODULE: external "classnames"
var external_classnames_ = __webpack_require__(9003);
var external_classnames_default = /*#__PURE__*/__webpack_require__.n(external_classnames_);
// EXTERNAL MODULE: ./src/client/ui/Box/index.ts + 1 modules
var Box = __webpack_require__(2138);
// EXTERNAL MODULE: ./src/client/ui/Card/Card.module.scss
var Card_module = __webpack_require__(249);
var Card_module_default = /*#__PURE__*/__webpack_require__.n(Card_module);
;// CONCATENATED MODULE: ./src/client/ui/Card/Card.tsx





const Card = /*#__PURE__*/ (0,external_react_.memo)(({ rounded, children, className })=>{
    return /*#__PURE__*/ jsx_runtime.jsx(Box/* Box */.x, {
        direction: "column",
        className: external_classnames_default()((Card_module_default()).wrap, {
            [(Card_module_default()).rounded]: rounded
        }, className),
        children: children
    });
});

;// CONCATENATED MODULE: ./src/client/ui/Card/index.ts



/***/ }),

/***/ 4703:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  u: () => (/* binding */ CipherService)
});

// EXTERNAL MODULE: external "@super-protocol/sdk-js"
var sdk_js_ = __webpack_require__(2461);
;// CONCATENATED MODULE: external "@super-protocol/dto-js/build/enum/index.js"
const index_js_namespaceObject = require("@super-protocol/dto-js/build/enum/index.js");
// EXTERNAL MODULE: external "@super-protocol/dto-js"
var dto_js_ = __webpack_require__(4005);
;// CONCATENATED MODULE: ./src/common/services/CipherService.ts



class CipherService {
    generatePrivateKeyByType(privateKey, type = "hex") {
        switch(type){
            case "hex":
                return Buffer.from(privateKey, "hex").toString("base64");
            default:
                return privateKey;
        }
    }
    setPrivateKey(privateKey, type = "hex") {
        this._privateKey = this.generatePrivateKeyByType(privateKey, type);
        return this;
    }
    async encrypt(content) {
        if (!this._privateKey) throw new Error("Private key required");
        return sdk_js_.Crypto.encrypt(content, {
            algo: index_js_namespaceObject.CryptoAlgorithm.AES,
            encoding: index_js_namespaceObject.Encoding.base64,
            key: this._privateKey,
            cipher: dto_js_.Cipher.AES_256_GCM
        });
    }
    async decrypt(encryption) {
        if (!this._privateKey) throw new Error("Private key required");
        if (!encryption) throw new Error("Encryption is not defined");
        encryption.key = this._privateKey;
        return sdk_js_.Crypto.decrypt(encryption);
    }
    constructor(){
        this._privateKey = "";
    }
}


/***/ }),

/***/ 8159:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ HelperService)
/* harmony export */ });
class HelperService {
    textToBase64(text) {
        if (!text || typeof text !== "string") return "";
        return Buffer.from(text).toString("base64");
    }
    textFromBase64(base64) {
        if (!base64 || typeof base64 !== "string") return "";
        return Buffer.from(base64, "base64").toString("utf8");
    }
    bufferFromHex(hex) {
        return Buffer.from(hex, "hex");
    }
}


/***/ }),

/***/ 2748:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ MessagesService)
/* harmony export */ });
class MessagesService {
    constructor(prop){
        this._messages = [];
        this.undecryptedMessageText = "This message cannot be decrypted";
        const { helperService, cipherService } = prop || {};
        this._helpers = helperService;
        this._cipher = cipherService;
    }
    async encryptMessage(message, privateKey) {
        if (!message) throw new Error("Message required for encription service");
        if (typeof message !== "string") throw new Error("Message must be string");
        if (!privateKey) throw new Error("Private key required for encription service");
        return this._cipher.setPrivateKey(privateKey).encrypt(Buffer.from(message, "utf-8").toString("binary"));
    }
    async decryptMessage(encryption, privateKey) {
        if (!encryption) throw new Error("Encription required for encription service");
        if (!privateKey) throw new Error("Private key required for encription service");
        return Buffer.from(await this._cipher.setPrivateKey(privateKey).decrypt(encryption), "binary").toString("utf-8");
    }
    setMessages(messages) {
        this._messages = messages;
        return this;
    }
    async getMessagesDecrypted(connectPassword) {
        return Promise.all(this.messages.map(async ({ encryption, senderName, ...rest })=>{
            const message = await this.decryptMessage(JSON.parse(encryption), connectPassword).catch(()=>this.undecryptedMessageText);
            return {
                ...rest,
                message,
                senderName: this._helpers.textFromBase64(senderName)
            };
        }));
    }
    async getMessageDecrypted(messageDb, connectPassword) {
        if (!connectPassword) throw new Error("Password required");
        if (!messageDb) return null;
        const { encryption, senderName, ...rest } = messageDb;
        const message = await this.decryptMessage(JSON.parse(encryption), connectPassword).catch(()=>this.undecryptedMessageText);
        return {
            ...rest,
            message,
            senderName: this._helpers.textFromBase64(senderName)
        };
    }
    async getMessageDecryptedById(id, connectPassword) {
        if (!connectPassword) throw new Error("Password required");
        if (!id) throw new Error("Message id required");
        const messageFromDb = this._messages.find((message)=>message.id === id);
        if (!messageFromDb) return null;
        return this.getMessageDecrypted(messageFromDb, connectPassword);
    }
    async getMessage(id) {
        if (!id) throw new Error("Message id required");
        const message = this._messages.find((message)=>message.id === id);
        return message || null;
    }
    async getMessages(ids) {
        if (!ids?.length) return [];
        const messages = this._messages.filter((message)=>!ids.includes(message.id));
        return messages || [];
    }
    get messages() {
        return this._messages;
    }
}


/***/ }),

/***/ 3269:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   f: () => (/* binding */ UsersService)
/* harmony export */ });
class UsersService {
    constructor(prop){
        this._users = [];
        const { helperService, cipherService } = prop || {};
        this._helpers = helperService;
        this._cipherService = cipherService;
    }
    setUsers(users) {
        this._users = users;
        return this;
    }
    getUsersDb() {
        return this._users;
    }
    getUsersResponse() {
        return this._users.map(({ name, ...rest })=>({
                ...rest,
                name: this._helpers.textFromBase64(name)
            }));
    }
    getUserResponseById(id) {
        if (!id) throw new Error("User id required");
        const user = this._users.find(({ id: userId })=>id === userId);
        if (!user) return null;
        return {
            ...user,
            name: this._helpers.textFromBase64(user?.name)
        };
    }
    getUserDbById(id) {
        if (!id) throw new Error("User id required");
        const user = this._users.find(({ id: userId })=>id === userId);
        return user || null;
    }
    getUsersResponseByIds(ids) {
        if (!ids?.length) {
            throw new Error("Users ids are empty");
        }
        return this._users.filter((user)=>ids.includes(user.id)).map(({ name, ...rest })=>({
                ...rest,
                name: this._helpers.textFromBase64(name)
            }));
    }
    getUsersDbByIds(ids) {
        if (!ids?.length) {
            throw new Error("Users ids are empty");
        }
        return this._users.filter((user)=>ids.includes(user.id));
    }
    get users() {
        return this._users;
    }
}


/***/ }),

/***/ 1546:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ RoomStatus)
/* harmony export */ });
var RoomStatus;
(function(RoomStatus) {
    RoomStatus["AVAILABLE"] = "AVAILABLE";
})(RoomStatus || (RoomStatus = {}));


/***/ }),

/***/ 4791:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getServerSideProps: () => (/* binding */ getServerSideProps)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5893);
/* harmony import */ var _components_Room__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5844);
/* harmony import */ var _server_getServerSideProps_checkRoomAuth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9411);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_components_Room__WEBPACK_IMPORTED_MODULE_1__, _server_getServerSideProps_checkRoomAuth__WEBPACK_IMPORTED_MODULE_2__]);
([_components_Room__WEBPACK_IMPORTED_MODULE_1__, _server_getServerSideProps_checkRoomAuth__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);



const RoomPage = ()=>{
    return /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx(_components_Room__WEBPACK_IMPORTED_MODULE_1__/* .Room */ .d, {});
};
const getServerSideProps = (0,_server_getServerSideProps_checkRoomAuth__WEBPACK_IMPORTED_MODULE_2__/* .checkRoomAuth */ .dw)();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoomPage);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 9369:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ getConfig)
/* harmony export */ });
/* harmony import */ var _client_utils_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5528);

const getConfig = ()=>({
        ...(0,_client_utils_config__WEBPACK_IMPORTED_MODULE_0__/* .getConfig */ .i)(),
        DOWNLOADER: {
            lruCache: {
                max: 500
            },
            writeInterval: Number(process.env.WRITE_INTERVAL) || 4000,
            readInterval: Number(process.env.READ_INTERVAL) || 1000,
            objectDeletedFlag: "deleted"
        },
        IPFS_URL: process.env.IPFS_URL,
        CLIENT: process.env.CLIENT,
        STORJ_CREDENTIALS: {
            prefix: process.env.STORJ_PREFIX || "",
            bucket: process.env.STORJ_BUCKET,
            token: process.env.STORJ_TOKEN
        },
        S3_CREDENTIALS: {
            accessKeyId: process.env.S3_ACCESS_KEY_ID,
            secretAccessKey: process.env.S3_ACCESS_SECRET_KEY,
            endpoint: process.env.S3_ENDPOINT || "https://gateway.storjshare.io",
            bucket: process.env.STORJ_BUCKET,
            region: process.env.S3_REGION || "us-east-1"
        },
        jwt: {
            expires: 14
        }
    });


/***/ }),

/***/ 9411:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dw: () => (/* binding */ checkRoomAuth)
/* harmony export */ });
/* unused harmony exports getUnauthorizedParams, getRoomPasswordParams */
/* harmony import */ var _services_jwt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3744);
/* harmony import */ var _services_authCookie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9639);
/* harmony import */ var _services_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(826);
/* harmony import */ var _services_db__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4130);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_services_db__WEBPACK_IMPORTED_MODULE_3__]);
_services_db__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];





const roomAuthLogger = _services_logger__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z.child({
    class: "check room auth"
});
const getUnauthorizedParams = (resolvedUrl, query, params)=>{
    const newQuery = getQSFromObj({
        ...deleteKeysFromObject(query, Object.keys(params || {})),
        redirect: resolvedUrl && isRelative(resolvedUrl) ? getPathFromUrl(resolvedUrl) // keep only the pathname in the redirect url
         : undefined
    });
    return {
        redirect: {
            destination: `/${newQuery}`,
            permanent: false
        }
    };
};
const getRoomPasswordParams = ()=>{
    return {
        redirect: {
            destination: "/room-password",
            permanent: false
        }
    };
};
const checkRoomAuth = (getServerSideProps)=>{
    return async (ctx)=>{
        try {
            const token = _services_authCookie__WEBPACK_IMPORTED_MODULE_1__/* .AuthCookieService */ .n.getCookie(ctx?.req, ctx?.res);
            const { connectPassword, userName } = new _services_jwt__WEBPACK_IMPORTED_MODULE_0__/* .JWTService */ .Z().decode(token);
            new _services_jwt__WEBPACK_IMPORTED_MODULE_0__/* .JWTService */ .Z().setPrivateKey(connectPassword).verify(token);
            if (connectPassword) {
                await _services_db__WEBPACK_IMPORTED_MODULE_3__.db.rooms.getRoomToken(connectPassword, userName);
            } else {
                return getRoomPasswordParams();
            }
        } catch (err) {
            roomAuthLogger.error({
                err
            });
            return getRoomPasswordParams();
        }
        if (getServerSideProps) {
            return getServerSideProps(ctx);
        }
        return {
            props: {}
        };
    };
};

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 6678:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ PubSub)
/* harmony export */ });
class PubSub {
    subscribe(event, listener) {
        this.subscriptions.set(event, (this.subscriptions.get(event) || []).concat(listener));
        return ()=>{
            this.unsubscribe(event, listener);
        };
    }
    unsubscribe(event, listener) {
        const eventListeners = this.subscriptions.get(event);
        if (eventListeners) {
            this.subscriptions.set(event, eventListeners.filter((l)=>l !== listener));
        }
    }
    publish(event, message) {
        const eventListeners = this.subscriptions.get(event);
        if (eventListeners) {
            eventListeners.forEach((listener)=>{
                listener(message);
            });
        }
    }
    clear(event) {
        if (event) {
            this.subscriptions.delete(event);
        } else {
            this.subscriptions.clear();
        }
    }
    constructor(){
        this.subscriptions = new Map();
    }
}


/***/ }),

/***/ 9639:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  n: () => (/* reexport */ AuthCookieService)
});

// EXTERNAL MODULE: external "cookies-next"
var external_cookies_next_ = __webpack_require__(8982);
// EXTERNAL MODULE: ./src/common/constants.ts
var constants = __webpack_require__(1677);
;// CONCATENATED MODULE: ./src/server/services/authCookie/AuthCookieService.ts


class AuthCookieService {
    static updateCookie(req, res, token) {
        (0,external_cookies_next_.setCookie)(constants/* Cookies */.LJ.AUTH_TOKEN, token, {
            req,
            res,
            // httpOnly: true,
            secure: "production" !== "development",
            maxAge: 14 * 24 * 60 * 60,
            sameSite: "lax",
            path: "/"
        });
    }
    static deleteCookie(req, res) {
        (0,external_cookies_next_.deleteCookie)(constants/* Cookies */.LJ.AUTH_TOKEN, {
            req,
            res
        });
    }
    static getCookie(req, res) {
        const { [constants/* Cookies */.LJ.AUTH_TOKEN]: token } = (0,external_cookies_next_.getCookies)({
            req,
            res
        });
        return token || "";
    }
}

;// CONCATENATED MODULE: ./src/server/services/authCookie/index.ts



/***/ }),

/***/ 4930:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: () => (/* binding */ DbService)
/* harmony export */ });
/* harmony import */ var _clients_ClientService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4330);
/* harmony import */ var _RoomsService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(903);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_RoomsService__WEBPACK_IMPORTED_MODULE_1__]);
_RoomsService__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


class DbService {
    static getInstance() {
        if (DbService.instance) {
            return DbService.instance;
        }
        DbService.instance = new DbService();
        return DbService.instance;
    }
    get isConnected() {
        return this._isConnected;
    }
    async connect() {
        if (this.isConnected) return this;
        this.client = await (0,_clients_ClientService__WEBPACK_IMPORTED_MODULE_0__/* .getClientService */ .S)();
        this.rooms = new _RoomsService__WEBPACK_IMPORTED_MODULE_1__/* .RoomsService */ .L({
            client: this.client
        });
        this._isConnected = true;
        return this;
    }
    async disconnect() {
        if (this.isConnected) {
            await this.client.close();
        }
    }
    async shutdown() {
        await this.client?.shutdown();
    }
    constructor(){
        this._isConnected = false;
    }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 1881:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   db: () => (/* binding */ db)
/* harmony export */ });
/* harmony import */ var _DbService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4930);
/* harmony import */ var _globalRef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9803);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_DbService__WEBPACK_IMPORTED_MODULE_0__]);
_DbService__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


const dbRef = new _globalRef__WEBPACK_IMPORTED_MODULE_1__/* .GlobalRef */ .w("db"); // nextjs doesn't share instance between routers :/
if (!dbRef.value) {
    dbRef.value = _DbService__WEBPACK_IMPORTED_MODULE_0__/* .DbService */ .M.getInstance();
}
const db = dbRef.value;

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 8476:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ MessagesService)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6555);
/* harmony import */ var _common_services_CipherService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4703);
/* harmony import */ var _common_services_MessagesService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2748);
/* harmony import */ var _helper_HelperService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5519);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([uuid__WEBPACK_IMPORTED_MODULE_0__]);
uuid__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




class MessagesService extends _common_services_MessagesService__WEBPACK_IMPORTED_MODULE_3__/* .MessagesService */ .K {
    constructor(){
        super({
            helperService: new _helper_HelperService__WEBPACK_IMPORTED_MODULE_2__/* .HelperService */ .W(),
            cipherService: new _common_services_CipherService__WEBPACK_IMPORTED_MODULE_1__/* .CipherService */ .u()
        });
    }
    async createMessage(data, connectPassword) {
        if (!connectPassword) throw new Error("Password required");
        const { encryption, senderName, senderId, messageClientId } = data;
        if (!encryption) throw new Error("Encryption required");
        if (!(0,uuid__WEBPACK_IMPORTED_MODULE_0__.validate)(messageClientId)) {
            throw new Error("Bad client id");
        }
        const createdAt = new Date().toISOString();
        const id = (0,uuid__WEBPACK_IMPORTED_MODULE_0__.v1)();
        const messageBeforeSave = {
            encryption,
            id,
            createdAt,
            updatedAt: createdAt,
            senderName: this._helpers.textToBase64(senderName),
            senderId,
            messageClientId
        };
        return messageBeforeSave;
    }
    async deleteMessage(id) {
        if (!id) throw new Error("User id required");
        const index = this._messages.findIndex((user)=>user.id === id);
        if (index === -1) return null;
        const message = this._messages.splice(index, 1)?.[0];
        return message || null;
    }
    async deleteMessages(ids) {
        if (!ids?.length) return this._messages;
        const { newMessages, deletedMessages } = this._messages.reduce((acc, user)=>{
            if (ids.includes(user.id)) {
                return {
                    ...acc,
                    deletedMessages: [
                        ...acc.deletedMessages,
                        user
                    ]
                };
            }
            return {
                ...acc,
                newMessages: [
                    ...acc.newMessages,
                    user
                ]
            };
        }, {
            newMessages: [],
            deletedMessages: []
        });
        this._messages = newMessages;
        return deletedMessages;
    }
    async addMessage(data, connectPassword) {
        if (!connectPassword) throw new Error("Password required");
        const newMessage = await this.createMessage(data, connectPassword);
        this._messages.push(newMessage);
        return newMessage;
    }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 903:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ RoomsService)
/* harmony export */ });
/* unused harmony export RoomsEvents */
/* harmony import */ var _super_protocol_sdk_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2461);
/* harmony import */ var _super_protocol_sdk_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_super_protocol_sdk_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7556);
/* harmony import */ var _helper_HelperService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5519);
/* harmony import */ var _MessagesService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8476);
/* harmony import */ var _UsersService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6977);
/* harmony import */ var _PubSub__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6678);
/* harmony import */ var _jwt__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3744);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(826);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_MessagesService__WEBPACK_IMPORTED_MODULE_3__]);
_MessagesService__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];








var RoomsEvents;
(function(RoomsEvents) {
    RoomsEvents["ROOM_DELETE"] = "ROOM_DELETE";
    RoomsEvents["MESSAGE_ADD"] = "MESSAGE_ADD";
    RoomsEvents["MESSAGES_ADD"] = "MESSAGES_ADD";
    RoomsEvents["USER_ADD"] = "USER_ADD";
    RoomsEvents["USERS_UPDATE"] = "USERS_UPDATE";
    RoomsEvents["USER_DELETE"] = "USER_DELETE";
})(RoomsEvents || (RoomsEvents = {}));
class RoomsService {
    constructor({ client }){
        this.helpers = new _helper_HelperService__WEBPACK_IMPORTED_MODULE_2__/* .HelperService */ .W();
        this.pubSub = new _PubSub__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z();
        this.eventName = "rooms";
        this.messageSevice = new _MessagesService__WEBPACK_IMPORTED_MODULE_3__/* .MessagesService */ .K();
        this.usersService = new _UsersService__WEBPACK_IMPORTED_MODULE_4__/* .UsersService */ .f();
        this.passwords = new Map();
        this.client = client;
        this.logger = _logger__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z.child({
            class: RoomsService.name
        });
        this.usersService = new _UsersService__WEBPACK_IMPORTED_MODULE_4__/* .UsersService */ .f();
        const cb = async ({ type, message: roomId })=>{
            switch(type){
                case _super_protocol_sdk_js__WEBPACK_IMPORTED_MODULE_0__.CacheEvents.INSTANCES_CHANGED:
                    this.onInstancesChanged(roomId);
                    break;
                case _super_protocol_sdk_js__WEBPACK_IMPORTED_MODULE_0__.CacheEvents.KEY_DELETED:
                    this.publish(RoomsEvents.ROOM_DELETE, {
                        room: null,
                        roomId
                    });
                    break;
                default:
                    break;
            }
        };
        this.client.subscribe((props)=>cb.call(this, props));
    }
    async subscribe(cb) {
        this.pubSub.subscribe(this.eventName, cb);
        return async ()=>{
            this.pubSub.unsubscribe(this.eventName, cb);
        };
    }
    publish(type, message) {
        this.pubSub.publish(this.eventName, {
            type,
            message
        });
    }
    async createRoom(roomName) {
        const deletePassword = (0,_utils_crypto__WEBPACK_IMPORTED_MODULE_1__/* .generateMnemonic */ .OF)();
        const connectPassword = this.helpers.generateHash(deletePassword);
        const createdAt = new Date().toISOString();
        const params = {
            messages: [],
            users: [],
            createdAt,
            updatedAt: createdAt,
            name: this.helpers.textToBase64(roomName)
        };
        await this.updateRoom(connectPassword, params);
        return {
            ...params,
            connectPassword,
            deletePassword
        };
    }
    async updateRoom(connectPassword, content) {
        if (!connectPassword) throw new Error("Password required");
        const roomId = this.helpers.generateHash(connectPassword);
        this.passwords.set(roomId, connectPassword);
        await this.client.set(roomId, content, this.helpers.bufferFromHex(connectPassword));
    }
    getRoomIdByConnectPassword(connectPassword) {
        if (!connectPassword) throw new Error("Password required");
        const roomId = this.helpers.generateHash(connectPassword);
        if (!roomId) throw new Error("Room is not defined");
        return roomId;
    }
    getConnectPasswordByDeletePassword(deletePassword) {
        if (!deletePassword) throw new Error("Password required");
        return this.helpers.generateHash(deletePassword);
    }
    getRoomIdByDeletePassword(deletePassword) {
        if (!deletePassword) throw new Error("Password required");
        return this.helpers.generateHash(this.getConnectPasswordByDeletePassword(deletePassword));
    }
    async getRoomFromAllInstances(connectPassword) {
        if (!connectPassword) {
            throw new Error("Password required");
        }
        const roomId = this.getRoomIdByConnectPassword(connectPassword);
        const instances = await this.client.get(roomId, this.helpers.bufferFromHex(connectPassword));
        if (!instances?.length) return null;
        this.passwords.set(roomId, connectPassword);
        return this.mergeRooms(instances) || null;
    }
    async getRoomFromCurrentInstance(connectPassword) {
        if (!connectPassword) {
            throw new Error("Password required");
        }
        const roomId = this.getRoomIdByConnectPassword(connectPassword);
        const instances = await this.client.get(roomId, this.helpers.bufferFromHex(connectPassword));
        const hasNonNullInstances = instances?.some((instance)=>!!instance);
        if (!instances || !hasNonNullInstances) return null;
        const firstInstance = instances[0];
        if (!firstInstance) {
            const mergedInstance = this.mergeRooms(instances);
            const newDecryptedRoomForCurrentInstance = {
                ...mergedInstance,
                users: []
            };
            await this.updateRoom(connectPassword, newDecryptedRoomForCurrentInstance);
            return newDecryptedRoomForCurrentInstance;
        }
        this.passwords.set(roomId, connectPassword);
        // merging messages is potentially redundant
        if (this.hasUnmergedMessages(firstInstance, instances)) {
            firstInstance.messages = this.mergeMessages(instances.map((instance)=>instance.messages));
        }
        return firstInstance;
    }
    async getRoomToken(connectPassword, userName) {
        if (!connectPassword) throw new Error("Password required");
        if (!userName) throw new Error("User name required");
        const room = await this.getRoomFromCurrentInstance(connectPassword); // do not need to merge
        if (!room) throw new Error("Room is not defined");
        const { createdAt, name } = room;
        return new _jwt__WEBPACK_IMPORTED_MODULE_5__/* .JWTService */ .Z().setPrivateKey(connectPassword).sign({
            createdAt,
            roomName: this.helpers.textFromBase64(name),
            userName,
            connectPassword
        });
    }
    async deleteRoom(deletePassword) {
        if (!deletePassword) throw new Error("Delete password required");
        const roomId = this.getRoomIdByDeletePassword(deletePassword);
        const connectPassword = this.getConnectPasswordByDeletePassword(deletePassword);
        const room = await this.getRoomFromCurrentInstance(connectPassword);
        if (!room) throw new Error("Room is not defined");
        await this.client.delete(roomId);
        this.publish(RoomsEvents.ROOM_DELETE, {
            room,
            roomId
        });
        return true;
    }
    async replaceUsersInRoomByNewUser(params) {
        return this.addUserToRoom(params, true);
    }
    async addUserToRoom(params, replace = false) {
        const { connectPassword, userInfo } = params;
        if (!userInfo?.name) throw new Error("User name required");
        if (!connectPassword) throw new Error("Password required");
        const roomId = this.getRoomIdByConnectPassword(connectPassword);
        const room = await this.getRoomFromCurrentInstance(connectPassword);
        if (!room) throw new Error("Room is not defined");
        this.usersService.setUsers(replace ? [] : room.users);
        const newUser = await this.usersService.addUser(params);
        await this.updateRoom(connectPassword, {
            ...room,
            users: this.usersService.users,
            updatedAt: new Date().toISOString()
        });
        this.publish(RoomsEvents.USER_ADD, {
            user: newUser,
            roomId
        });
        return newUser;
    }
    async addMessageToRoom(message, connectPassword) {
        if (!connectPassword) throw new Error("Password required");
        const roomId = this.getRoomIdByConnectPassword(connectPassword);
        const room = await this.getRoomFromCurrentInstance(connectPassword);
        if (!room) return false;
        this.messageSevice.setMessages(room?.messages);
        const savedMessage = await this.messageSevice.addMessage(message, connectPassword);
        await this.updateRoom(connectPassword, {
            ...room,
            messages: this.messageSevice.messages,
            updatedAt: new Date().toISOString()
        });
        this.publish(RoomsEvents.MESSAGE_ADD, {
            message: savedMessage,
            roomId
        });
        return true;
    }
    async getUserByIdInRoom(connectPassword, userId) {
        if (!connectPassword) throw new Error("Password id required");
        const room = await this.getRoomFromCurrentInstance(connectPassword);
        return (room?.users || []).find(({ id })=>id === userId) || null;
    }
    async deleteUserFromRoom(userId, connectPassword) {
        if (!userId) throw new Error("User id required");
        const roomId = this.getRoomIdByConnectPassword(connectPassword);
        const room = await this.getRoomFromCurrentInstance(connectPassword);
        if (!room) throw new Error("Room is not defined");
        this.usersService.setUsers(room?.users);
        const deletedUser = this.usersService.deleteUser(userId);
        await this.updateRoom(connectPassword, {
            ...room,
            users: this.usersService.users,
            updatedAt: new Date().toISOString()
        });
        this.publish(RoomsEvents.USER_DELETE, {
            user: deletedUser,
            roomId
        });
        return true;
    }
    async onInstancesChanged(roomId) {
        const connectPassword = this.passwords.get(roomId);
        if (!connectPassword) {
            this.logger.info({
                roomId
            }, "Password not found");
            return;
        }
        const updatedMessagesAndUsers = await this.getUpdatedMessagesAndUsers(connectPassword);
        if (!updatedMessagesAndUsers) return;
        const { messagesAdded, usersAll } = updatedMessagesAndUsers;
        if (messagesAdded.length) {
            this.publish(RoomsEvents.MESSAGES_ADD, {
                messages: messagesAdded,
                roomId
            });
        }
        this.publish(RoomsEvents.USERS_UPDATE, {
            users: usersAll,
            roomId
        });
    }
    async getUpdatedMessagesAndUsers(connectPassword) {
        if (!connectPassword) throw new Error("Password id required");
        const roomId = this.getRoomIdByConnectPassword(connectPassword);
        const instances = await this.client.get(roomId, this.helpers.bufferFromHex(connectPassword));
        if (!instances) return null;
        const [currentInstance, ...otherInstances] = instances;
        if (!currentInstance) return null;
        if (!otherInstances?.length) return null;
        const messagesAdded = this.findAddedMessages(currentInstance.messages, otherInstances.flatMap((instance)=>instance?.messages || []));
        const usersAll = this.mergeUsers([
            currentInstance.users,
            otherInstances.flatMap((instance)=>instance?.users || [])
        ]);
        return {
            messagesAdded,
            usersAll
        };
    }
    async isRoomExists(roomId) {
        return this.client.has(roomId);
    }
    findAddedMessages(currMessages, allMessages) {
        const map = new Set(currMessages.map((copy)=>copy?.id));
        return allMessages.filter((newMessage)=>!map.has(newMessage?.id));
    }
    hasUnmergedMessages(firstInstance, otherInstances) {
        const firstInstanceMessagesUpdate = new Date(firstInstance.messages.at(-1)?.updatedAt || 0).getTime();
        const someInstancesUpdated = otherInstances.some((instance)=>{
            const otherInstanceMessagesUpdate = new Date(instance.messages.at(-1)?.updatedAt || 0).getTime();
            return otherInstanceMessagesUpdate > firstInstanceMessagesUpdate;
        });
        return someInstancesUpdated;
    }
    mergeRooms(copies) {
        if (!copies?.length) {
            return null;
        }
        const result = copies.filter((room)=>!!room)[0]; // find the first null room
        if (!result) return null;
        return {
            ...result,
            messages: this.mergeMessages(copies.map((copy)=>copy?.messages || [])),
            users: this.mergeUsers(copies.map((copy)=>copy?.users || []))
        };
    }
    mergeMessages(copies) {
        const map = new Map(copies.flat().map((copy)=>[
                copy.id,
                copy
            ]));
        return Array.from(map.values()).sort((a, b)=>{
            if (a?.createdAt === b?.createdAt) {
                return a.id > b.id ? 1 : -1;
            }
            return new Date(a?.createdAt).getTime() - new Date(b?.createdAt).getTime();
        });
    }
    mergeUsers(copies) {
        const map = new Map(copies.flat().map((copy)=>[
                copy.id,
                copy
            ]));
        return Array.from(map.values());
    }
    async deleteAllUsers(connectPassword) {
        if (!connectPassword) throw new Error("Password id required");
        const room = await this.getRoomFromCurrentInstance(connectPassword);
        if (!room) return;
        await this.updateRoom(connectPassword, {
            ...room,
            users: []
        });
    }
}

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 6977:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   f: () => (/* binding */ UsersService)
/* harmony export */ });
/* harmony import */ var _common_services_CipherService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4703);
/* harmony import */ var _common_services_UsersService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3269);
/* harmony import */ var _helper_HelperService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5519);



class UsersService extends _common_services_UsersService__WEBPACK_IMPORTED_MODULE_2__/* .UsersService */ .f {
    constructor(){
        super({
            helperService: new _helper_HelperService__WEBPACK_IMPORTED_MODULE_1__/* .HelperService */ .W(),
            cipherService: new _common_services_CipherService__WEBPACK_IMPORTED_MODULE_0__/* .CipherService */ .u()
        });
    }
    async createUser(params) {
        const { userInfo, connectPassword } = params;
        const { token } = userInfo || {};
        if (!userInfo) throw new Error("Profile required");
        if (!token) throw new Error("Token required");
        if (!connectPassword) throw new Error("Password required");
        const createdAt = new Date().toISOString();
        const id = this._helpers.generateHash();
        const userBeforeSave = {
            id,
            name: this._helpers.textToBase64(userInfo.name),
            token: this._helpers.generateHash(token),
            createdAt,
            updatedAt: createdAt
        };
        return userBeforeSave;
    }
    async addUser(params) {
        const { userInfo, connectPassword } = params;
        if (!userInfo) throw new Error("Profile required");
        if (!connectPassword) throw new Error("Password required");
        const newUser = await this.createUser(params);
        this._users.push(newUser);
        return newUser;
    }
    async addUsers(usersInfo, connectPassword) {
        if (!usersInfo?.length) return [];
        if (!connectPassword) throw new Error("Password required");
        const newUsers = await Promise.all(usersInfo.map(async (userInfo)=>this.createUser({
                userInfo,
                connectPassword
            })));
        this._users.push(...newUsers);
        return newUsers;
    }
    async deleteUser(id) {
        if (!id) throw new Error("User id required");
        const index = this._users.findIndex((user)=>user.id === id);
        if (index === -1) return null;
        const deletedUser = this._users.splice(index, 1)?.[0];
        return deletedUser || null;
    }
    async deleteUsers(ids) {
        if (!ids?.length) return this._users;
        const { newUsers, deletedUsers } = this._users.reduce((acc, user)=>{
            if (ids.includes(user.id)) {
                return {
                    ...acc,
                    deletedUsers: [
                        ...acc.deletedUsers,
                        user
                    ]
                };
            }
            return {
                ...acc,
                newUsers: [
                    ...acc.newUsers,
                    user
                ]
            };
        }, {
            newUsers: [],
            deletedUsers: []
        });
        this._users = newUsers;
        return deletedUsers;
    }
}


/***/ }),

/***/ 4330:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  S: () => (/* binding */ getClientService)
});

;// CONCATENATED MODULE: external "node:perf_hooks"
const external_node_perf_hooks_namespaceObject = require("node:perf_hooks");
// EXTERNAL MODULE: external "@super-protocol/dto-js"
var dto_js_ = __webpack_require__(4005);
;// CONCATENATED MODULE: ./src/server/services/db/clients/types.ts
var Clients;
(function(Clients) {
    Clients["ORBITDB"] = "ORBITDB";
    Clients["STORJ"] = "STORJ";
    Clients["S3"] = "S3";
})(Clients || (Clients = {}));

// EXTERNAL MODULE: external "@super-protocol/sdk-js"
var sdk_js_ = __webpack_require__(2461);
// EXTERNAL MODULE: ./src/server/services/logger.ts + 1 modules
var logger = __webpack_require__(826);
;// CONCATENATED MODULE: ./src/server/services/db/clients/StorjClientService.ts


class StorjClientService {
    constructor(){
        this._client = null;
        this.logger = logger/* default */.Z.child({
            class: StorjClientService.name
        });
    }
    async connect(storageAccess, config) {
        this._client = new sdk_js_.StorjAdapter(storageAccess, config);
        return this;
    }
    subscribe(cb) {
        return this._client?.subscribe(cb);
    }
    async get(key, encryptionKey) {
        return this._client?.get(key, encryptionKey);
    }
    async has(key) {
        return !!this._client && this._client.has(key);
    }
    async set(key, value, encryptionKey) {
        return this._client?.set(key, value, encryptionKey);
    }
    async delete(key) {
        return this._client?.del(key);
    }
    async close() {
        this._client?.stop();
        this._client = null;
    }
    async shutdown() {
        await this._client?.shutdown();
    }
}

// EXTERNAL MODULE: ./src/server/config.ts
var server_config = __webpack_require__(9369);
;// CONCATENATED MODULE: ./src/server/services/db/clients/ClientService.ts





// key/value services
const getClientService = async ()=>{
    const config = (0,server_config/* getConfig */.i)();
    const client = config.CLIENT;
    const clientConfig = {
        ...config.DOWNLOADER,
        performance: external_node_perf_hooks_namespaceObject.performance
    };
    switch(client){
        case Clients.STORJ:
            return new StorjClientService().connect({
                storageType: dto_js_.StorageType.StorJ,
                credentials: config.STORJ_CREDENTIALS
            }, clientConfig);
        case Clients.S3:
            return new StorjClientService().connect({
                storageType: dto_js_.StorageType.S3,
                credentials: config.S3_CREDENTIALS
            }, clientConfig);
        default:
            throw new Error(`Unknown client ${client}`);
    }
};


/***/ }),

/***/ 4130:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   db: () => (/* reexport safe */ _DbServiceShare__WEBPACK_IMPORTED_MODULE_0__.db)
/* harmony export */ });
/* harmony import */ var _DbServiceShare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1881);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_DbServiceShare__WEBPACK_IMPORTED_MODULE_0__]);
_DbServiceShare__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ 9803:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w: () => (/* binding */ GlobalRef)
/* harmony export */ });
class GlobalRef {
    constructor(uniqueName){
        this.sym = Symbol.for(uniqueName);
    }
    get value() {
        return global[this.sym];
    }
    set value(value) {
        global[this.sym] = value;
    }
}


/***/ }),

/***/ 5519:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  W: () => (/* binding */ HelperService)
});

;// CONCATENATED MODULE: external "node:crypto"
const external_node_crypto_namespaceObject = require("node:crypto");
// EXTERNAL MODULE: ./src/common/services/HelperService.ts
var services_HelperService = __webpack_require__(8159);
;// CONCATENATED MODULE: ./src/server/services/helper/HelperService.ts


class HelperService extends services_HelperService/* HelperService */.W {
    generateHash(str) {
        return (0,external_node_crypto_namespaceObject.createHash)("sha256").update(str || (0,external_node_crypto_namespaceObject.randomUUID)()).digest("hex");
    }
}


/***/ }),

/***/ 3744:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* reexport */ JWTService)
});

;// CONCATENATED MODULE: external "jsonwebtoken"
const external_jsonwebtoken_namespaceObject = require("jsonwebtoken");
var external_jsonwebtoken_default = /*#__PURE__*/__webpack_require__.n(external_jsonwebtoken_namespaceObject);
// EXTERNAL MODULE: ./src/server/services/helper/HelperService.ts + 1 modules
var HelperService = __webpack_require__(5519);
// EXTERNAL MODULE: ./src/server/config.ts
var config = __webpack_require__(9369);
;// CONCATENATED MODULE: ./src/server/services/jwt/JWTService.ts



class JWTService {
    setPrivateKey(jwtSecret) {
        this.jwtSecret = jwtSecret;
        return this;
    }
    updateJwtSecret(jwtSecret) {
        this.jwtSecret = jwtSecret;
        return this;
    }
    verify(token) {
        if (!token) throw new Error("Token is empty");
        const tokenWithoutBearer = token?.replace("Bearer ", "");
        if (!tokenWithoutBearer) {
            throw new Error("No token provided");
        }
        if (!this.jwtSecret) {
            throw new Error("jwt secret required");
        }
        try {
            return external_jsonwebtoken_default().verify(tokenWithoutBearer, this.jwtSecret);
        } catch (e) {
            throw new Error("Invalid token");
        }
    }
    decode(token) {
        if (!token) throw new Error("Token is empty");
        try {
            return external_jsonwebtoken_default().decode(token);
        } catch (e) {
            throw new Error("Decode token error");
        }
    }
    sign(props) {
        if (!this.jwtSecret) {
            throw new Error("jwt secret required");
        }
        const { createdAt, roomName, userName, connectPassword } = props || {};
        return external_jsonwebtoken_default().sign({
            createdAt,
            roomName,
            userName,
            connectPassword
        }, this.jwtSecret, {
            expiresIn: `${(0,config/* getConfig */.i)().jwt.expires}d`
        });
    }
    generateJwtKey(privateKey) {
        if (!privateKey) throw new Error("Private key required");
        return this.helpers.generateHash(privateKey);
    }
    updateJwtKeyByPrivateKey(privateKey) {
        this.jwtSecret = this.generateJwtKey(privateKey);
    }
    constructor(){
        this.helpers = new HelperService/* HelperService */.W();
    }
}

;// CONCATENATED MODULE: ./src/server/services/jwt/index.ts



/***/ }),

/***/ 826:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ services_logger)
});

;// CONCATENATED MODULE: external "pino"
const external_pino_namespaceObject = require("pino");
var external_pino_default = /*#__PURE__*/__webpack_require__.n(external_pino_namespaceObject);
;// CONCATENATED MODULE: ./src/server/services/logger.ts

const logger = external_pino_default()();
/* harmony default export */ const services_logger = (logger);


/***/ }),

/***/ 7556:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  OF: () => (/* binding */ generateMnemonic)
});

// UNUSED EXPORTS: generateECIESKeys, generateRandomKeys, validateMnemonic

;// CONCATENATED MODULE: external "crypto"
const external_crypto_namespaceObject = require("crypto");
;// CONCATENATED MODULE: external "bip39"
const external_bip39_namespaceObject = require("bip39");
;// CONCATENATED MODULE: ./src/server/utils/crypto.ts


const generateMnemonic = ()=>(0,external_bip39_namespaceObject.generateMnemonic)(256);
const generateECIESKeys = (mnemonic)=>{
    const entropy = mnemonicToEntropyBip39(mnemonic);
    const privateKeyBuffer = Buffer.from(entropy, "hex");
    const ecdh = createECDH("secp256k1");
    ecdh.setPrivateKey(privateKeyBuffer);
    const publicKeyBuffer = ecdh.getPublicKey();
    const privateKeyBase64 = privateKeyBuffer.toString("base64");
    const publicKeyBase64 = publicKeyBuffer.toString("base64");
    return {
        privateKeyBase64,
        publicKeyBase64,
        privateKeyBuffer,
        publicKeyBuffer,
        mnemonic
    };
};
const validateMnemonic = (mnemonic)=>{
    let validate = validateMnemonicBip39(mnemonic);
    if (!validate) return validate;
    try {
        generateECIESKeys(mnemonic);
    } catch (e) {
        validate = false;
    }
    return validate;
};
const generateRandomKeys = ()=>{
    const ecdh = createECDH("secp256k1");
    ecdh.generateKeys();
    const privateKeyBuffer = ecdh.getPrivateKey();
    const publicKeyBuffer = ecdh.getPublicKey();
    const privateKeyBase64 = privateKeyBuffer.toString("base64");
    const publicKeyBase64 = publicKeyBuffer.toString("base64");
    return {
        privateKeyBuffer,
        publicKeyBuffer,
        privateKeyBase64,
        publicKeyBase64
    };
};


/***/ }),

/***/ 4005:
/***/ ((module) => {

"use strict";
module.exports = require("@super-protocol/dto-js");

/***/ }),

/***/ 2461:
/***/ ((module) => {

"use strict";
module.exports = require("@super-protocol/sdk-js");

/***/ }),

/***/ 9003:
/***/ ((module) => {

"use strict";
module.exports = require("classnames");

/***/ }),

/***/ 8982:
/***/ ((module) => {

"use strict";
module.exports = require("cookies-next");

/***/ }),

/***/ 8887:
/***/ ((module) => {

"use strict";
module.exports = require("copy-to-clipboard");

/***/ }),

/***/ 1635:
/***/ ((module) => {

"use strict";
module.exports = require("dayjs");

/***/ }),

/***/ 2296:
/***/ ((module) => {

"use strict";
module.exports = require("formik");

/***/ }),

/***/ 3076:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/future/route-modules/route-module.js");

/***/ }),

/***/ 4140:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/get-page-files.js");

/***/ }),

/***/ 9716:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/htmlescape.js");

/***/ }),

/***/ 3100:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/render.js");

/***/ }),

/***/ 6368:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/utils.js");

/***/ }),

/***/ 3280:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/app-router-context.js");

/***/ }),

/***/ 6724:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/constants.js");

/***/ }),

/***/ 8743:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/html-context.js");

/***/ }),

/***/ 8524:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/is-plain-object.js");

/***/ }),

/***/ 5832:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/loadable.js");

/***/ }),

/***/ 4964:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router-context.js");

/***/ }),

/***/ 1751:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/add-path-prefix.js");

/***/ }),

/***/ 3938:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/format-url.js");

/***/ }),

/***/ 1109:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/is-local-url.js");

/***/ }),

/***/ 8854:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/parse-path.js");

/***/ }),

/***/ 3297:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/remove-trailing-slash.js");

/***/ }),

/***/ 7782:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/resolve-href.js");

/***/ }),

/***/ 9232:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/utils.js");

/***/ }),

/***/ 968:
/***/ ((module) => {

"use strict";
module.exports = require("next/head");

/***/ }),

/***/ 1853:
/***/ ((module) => {

"use strict";
module.exports = require("next/router");

/***/ }),

/***/ 8890:
/***/ ((module) => {

"use strict";
module.exports = require("nextjs-progressbar");

/***/ }),

/***/ 6689:
/***/ ((module) => {

"use strict";
module.exports = require("react");

/***/ }),

/***/ 3742:
/***/ ((module) => {

"use strict";
module.exports = require("react-bootstrap/Spinner");

/***/ }),

/***/ 4648:
/***/ ((module) => {

"use strict";
module.exports = require("react-input-mask");

/***/ }),

/***/ 1175:
/***/ ((module) => {

"use strict";
module.exports = require("react-query");

/***/ }),

/***/ 9816:
/***/ ((module) => {

"use strict";
module.exports = require("styled-jsx/style");

/***/ }),

/***/ 5609:
/***/ ((module) => {

"use strict";
module.exports = require("yup");

/***/ }),

/***/ 4853:
/***/ ((module) => {

"use strict";
module.exports = import("react-textarea-autosize");;

/***/ }),

/***/ 3590:
/***/ ((module) => {

"use strict";
module.exports = import("react-toastify");;

/***/ }),

/***/ 4612:
/***/ ((module) => {

"use strict";
module.exports = import("socket.io-client");;

/***/ }),

/***/ 7105:
/***/ ((module) => {

"use strict";
module.exports = import("use-debounce");;

/***/ }),

/***/ 6555:
/***/ ((module) => {

"use strict";
module.exports = import("uuid");;

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, [158,152,535,112,923], () => (__webpack_exec__(1496)));
module.exports = __webpack_exports__;

})();